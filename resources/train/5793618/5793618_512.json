{"test_class": {"identifier": "TinylogLoggingConfigurationTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n\tpublic final SystemStreamCollector systemStream = new SystemStreamCollector(true);", "modifier": "@Rule\n\tpublic final", "type": "SystemStreamCollector", "declarator": "systemStream = new SystemStreamCollector(true)", "var_name": "systemStream"}], "file": "tinylog-impl/src/test/java/org/tinylog/core/TinylogLoggingConfigurationTest.java"}, "test_case": {"identifier": "singleMultipleTaggedWriter", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void singleMultipleTaggedWriter() {\n\t\tConfiguration.set(\"writer\", \"console\");\n\t\tConfiguration.set(\"writer.tag\", \" system , , backup  , test, , \"); // Test also unusual tag entries\n\t\t\n\t\tList<String> tags = ConfigurationParser.getTags();\n\t\tTinylogLoggingConfiguration config = new TinylogLoggingConfiguration();\n\t\tCollection<Writer>[][] writers = config.createWriters(tags, Level.TRACE, false);\n\n\t\tassertThat(writers)\n\t\t\t.hasSize(5)\n\t\t\t.allSatisfy(element -> assertThat(element).hasSize(5));\n\n\t\tassertThat(writers[0]).allSatisfy(collection -> assertThat(collection).isEmpty());\n\t\tassertThat(writers[1]).allSatisfy(collection -> {\n\t\t\tassertThat(collection).hasSize(1).allSatisfy(writer -> assertThat(writer).isInstanceOf(ConsoleWriter.class));\n\t\t});\n\t\tassertThat(writers[2]).allSatisfy(collection -> {\n\t\t\tassertThat(collection).hasSize(1).allSatisfy(writer -> assertThat(writer).isInstanceOf(ConsoleWriter.class));\n\t\t});\n\t\tassertThat(writers[3]).allSatisfy(collection -> {\n\t\t\tassertThat(collection).hasSize(1).allSatisfy(writer -> assertThat(writer).isInstanceOf(ConsoleWriter.class));\n\t\t});\n\t\tassertThat(writers[4]).allSatisfy(collection -> assertThat(collection).isEmpty());\n\t}", "signature": "void singleMultipleTaggedWriter()", "full_signature": "@Test public void singleMultipleTaggedWriter()", "class_method_signature": "TinylogLoggingConfigurationTest.singleMultipleTaggedWriter()", "testcase": true, "constructor": false, "invocations": ["set", "set", "getTags", "createWriters", "allSatisfy", "hasSize", "assertThat", "hasSize", "assertThat", "allSatisfy", "assertThat", "isEmpty", "assertThat", "allSatisfy", "assertThat", "allSatisfy", "hasSize", "assertThat", "isInstanceOf", "assertThat", "allSatisfy", "assertThat", "allSatisfy", "hasSize", "assertThat", "isInstanceOf", "assertThat", "allSatisfy", "assertThat", "allSatisfy", "hasSize", "assertThat", "isInstanceOf", "assertThat", "allSatisfy", "assertThat", "isEmpty", "assertThat"]}, "focal_class": {"identifier": "TinylogLoggingConfiguration", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "TinylogLoggingConfiguration", "parameters": "()", "modifiers": "public", "return": "", "signature": " TinylogLoggingConfiguration()", "full_signature": "public  TinylogLoggingConfiguration()", "class_method_signature": "TinylogLoggingConfiguration.TinylogLoggingConfiguration()", "testcase": false, "constructor": true}, {"identifier": "createWriters", "parameters": "(final List<String> tags, final Level minimumLevel, final boolean writingThread)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "Collection<Writer>[][]", "signature": "Collection<Writer>[][] createWriters(final List<String> tags, final Level minimumLevel, final boolean writingThread)", "full_signature": "@SuppressWarnings(\"unchecked\") public Collection<Writer>[][] createWriters(final List<String> tags, final Level minimumLevel, final boolean writingThread)", "class_method_signature": "TinylogLoggingConfiguration.createWriters(final List<String> tags, final Level minimumLevel, final boolean writingThread)", "testcase": false, "constructor": false}, {"identifier": "addWriter", "parameters": "(final Writer writer, final Collection<Writer>[][] matrix, final int tagIndex, final Level level)", "modifiers": "protected", "return": "void", "signature": "void addWriter(final Writer writer, final Collection<Writer>[][] matrix, final int tagIndex, final Level level)", "full_signature": "protected void addWriter(final Writer writer, final Collection<Writer>[][] matrix, final int tagIndex, final Level level)", "class_method_signature": "TinylogLoggingConfiguration.addWriter(final Writer writer, final Collection<Writer>[][] matrix, final int tagIndex, final Level level)", "testcase": false, "constructor": false}, {"identifier": "calculateMinimumLevel", "parameters": "(final Level globalLevel, final Map<String, Level> customLevels)", "modifiers": "public", "return": "Level", "signature": "Level calculateMinimumLevel(final Level globalLevel, final Map<String, Level> customLevels)", "full_signature": "public Level calculateMinimumLevel(final Level globalLevel, final Map<String, Level> customLevels)", "class_method_signature": "TinylogLoggingConfiguration.calculateMinimumLevel(final Level globalLevel, final Map<String, Level> customLevels)", "testcase": false, "constructor": false}, {"identifier": "calculateRequiredLogEntryValues", "parameters": "(final Collection<Writer>[][] writers)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "Collection<LogEntryValue>[][]", "signature": "Collection<LogEntryValue>[][] calculateRequiredLogEntryValues(final Collection<Writer>[][] writers)", "full_signature": "@SuppressWarnings(\"unchecked\") public Collection<LogEntryValue>[][] calculateRequiredLogEntryValues(final Collection<Writer>[][] writers)", "class_method_signature": "TinylogLoggingConfiguration.calculateRequiredLogEntryValues(final Collection<Writer>[][] writers)", "testcase": false, "constructor": false}, {"identifier": "calculateFullStackTraceRequirements", "parameters": "(final Collection<LogEntryValue>[][] logEntryValues)", "modifiers": "public", "return": "BitSet", "signature": "BitSet calculateFullStackTraceRequirements(final Collection<LogEntryValue>[][] logEntryValues)", "full_signature": "public BitSet calculateFullStackTraceRequirements(final Collection<LogEntryValue>[][] logEntryValues)", "class_method_signature": "TinylogLoggingConfiguration.calculateFullStackTraceRequirements(final Collection<LogEntryValue>[][] logEntryValues)", "testcase": false, "constructor": false}, {"identifier": "createWritingThread", "parameters": "(final Collection<Writer>[][] matrix)", "modifiers": "public", "return": "WritingThread", "signature": "WritingThread createWritingThread(final Collection<Writer>[][] matrix)", "full_signature": "public WritingThread createWritingThread(final Collection<Writer>[][] matrix)", "class_method_signature": "TinylogLoggingConfiguration.createWritingThread(final Collection<Writer>[][] matrix)", "testcase": false, "constructor": false}, {"identifier": "getAllWriters", "parameters": "(final Collection<Writer>[][] matrix)", "modifiers": "public static", "return": "Collection<Writer>", "signature": "Collection<Writer> getAllWriters(final Collection<Writer>[][] matrix)", "full_signature": "public static Collection<Writer> getAllWriters(final Collection<Writer>[][] matrix)", "class_method_signature": "TinylogLoggingConfiguration.getAllWriters(final Collection<Writer>[][] matrix)", "testcase": false, "constructor": false}, {"identifier": "createLogEntry", "parameters": "(final StackTraceElement stackTraceElement, final String tag, \n\t\tfinal Level level, final Throwable exception, final MessageFormatter formatter, final Object obj,\n\t\tfinal Object[] arguments, final Collection<LogEntryValue>[] requiredLogEntryValues, \n\t\tfinal TinylogContextProvider contextProvider)", "modifiers": "public static", "return": "LogEntry", "signature": "LogEntry createLogEntry(final StackTraceElement stackTraceElement, final String tag, \n\t\tfinal Level level, final Throwable exception, final MessageFormatter formatter, final Object obj,\n\t\tfinal Object[] arguments, final Collection<LogEntryValue>[] requiredLogEntryValues, \n\t\tfinal TinylogContextProvider contextProvider)", "full_signature": "public static LogEntry createLogEntry(final StackTraceElement stackTraceElement, final String tag, \n\t\tfinal Level level, final Throwable exception, final MessageFormatter formatter, final Object obj,\n\t\tfinal Object[] arguments, final Collection<LogEntryValue>[] requiredLogEntryValues, \n\t\tfinal TinylogContextProvider contextProvider)", "class_method_signature": "TinylogLoggingConfiguration.createLogEntry(final StackTraceElement stackTraceElement, final String tag, \n\t\tfinal Level level, final Throwable exception, final MessageFormatter formatter, final Object obj,\n\t\tfinal Object[] arguments, final Collection<LogEntryValue>[] requiredLogEntryValues, \n\t\tfinal TinylogContextProvider contextProvider)", "testcase": false, "constructor": false}], "file": "tinylog-impl/src/main/java/org/tinylog/core/TinylogLoggingConfiguration.java"}, "focal_method": {"identifier": "createWriters", "parameters": "(final List<String> tags, final Level minimumLevel, final boolean writingThread)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "Collection<Writer>[][]", "body": "@SuppressWarnings(\"unchecked\")\n\tpublic Collection<Writer>[][] createWriters(final List<String> tags, final Level minimumLevel, final boolean writingThread) {\n\t\tif (RuntimeProvider.getProcessId() == Long.MIN_VALUE) {\n\t\t\tjava.util.ServiceLoader.load(Writer.class); // Workaround for ProGuard (see issue #126)\n\t\t}\n\t\t\n\t\tCollection<Writer>[][] matrix = new Collection[tags.size() + 2][Level.values().length - 1];\n\t\tServiceLoader<Writer> loader = new ServiceLoader<Writer>(Writer.class, Map.class);\n\n\t\tMap<String, String> writerProperties = Configuration.getSiblings(\"writer\");\n\n\t\tif (writerProperties.isEmpty()) {\n\t\t\twriterProperties = Collections.singletonMap(\"writer\", RuntimeProvider.getDefaultWriter());\n\t\t}\n\n\t\tfor (Entry<String, String> entry : writerProperties.entrySet()) {\n\t\t\tMap<String, String> configuration = Configuration.getChildren(entry.getKey());\n\t\t\tString tag = configuration.get(\"tag\");\n\t\t\tLevel level = ConfigurationParser.parse(configuration.get(\"level\"), minimumLevel);\n\t\t\tif (level.ordinal() < minimumLevel.ordinal()) {\n\t\t\t\tlevel = minimumLevel;\n\t\t\t}\n\t\t\t\n\t\t\tString exception = Configuration.get(\"exception\");\n\t\t\tif (exception != null && !configuration.containsKey(\"exception\")) {\n\t\t\t\tconfiguration.put(\"exception\", exception);\n\t\t\t}\n\n\t\t\tconfiguration.put(\"ID\", entry.getKey());\n\t\t\tconfiguration.put(\"writingthread\", Boolean.toString(writingThread));\n\n\t\t\tWriter writer = loader.create(entry.getValue(), configuration);\n\t\t\tif (writer != null) {\n\t\t\t\tif (tag == null || tag.isEmpty()) {\n\t\t\t\t\tfor (int tagIndex = 0; tagIndex < matrix.length; ++tagIndex) {\n\t\t\t\t\t\taddWriter(writer, matrix, tagIndex, level);\n\t\t\t\t\t}\n\t\t\t\t} else if (tag.equals(\"-\")) {\n\t\t\t\t\taddWriter(writer, matrix, 0, level);\n\t\t\t\t} else {\n\t\t\t\t\tString[] tagArray = tag.split(\",\");\n\t\t\t\t\tfor (String tagArrayItem : tagArray) {\n\t\t\t\t\t\ttagArrayItem = tagArrayItem.trim(); \n\t\t\t\t\t\tString[] tagLevelItem = tagArrayItem.split(\"@\", 2);\n\t\t\t\t\t\tLevel currentLevel;\n\t\t\t\t\t\tString currentTag;\n\t\t\t\t\t\tif (tagLevelItem.length == 1) {\n\t\t\t\t\t\t\tcurrentTag = tagArrayItem;\n\t\t\t\t\t\t\tcurrentLevel = level;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentTag = tagLevelItem[0].trim();\n\t\t\t\t\t\t\tcurrentLevel = ConfigurationParser.parse(tagLevelItem[1].trim(), level);\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!tagArrayItem.isEmpty()) {\n\t\t\t\t\t\t\taddWriter(writer, matrix, tags.indexOf(currentTag) + 1, currentLevel);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int tagIndex = 0; tagIndex < matrix.length; ++tagIndex) {\n\t\t\tfor (int levelIndex = 0; levelIndex < matrix[tagIndex].length; ++levelIndex) {\n\t\t\t\tif (matrix[tagIndex][levelIndex] == null) {\n\t\t\t\t\tmatrix[tagIndex][levelIndex] = Collections.emptyList();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn matrix;\n\t}", "signature": "Collection<Writer>[][] createWriters(final List<String> tags, final Level minimumLevel, final boolean writingThread)", "full_signature": "@SuppressWarnings(\"unchecked\") public Collection<Writer>[][] createWriters(final List<String> tags, final Level minimumLevel, final boolean writingThread)", "class_method_signature": "TinylogLoggingConfiguration.createWriters(final List<String> tags, final Level minimumLevel, final boolean writingThread)", "testcase": false, "constructor": false, "invocations": ["getProcessId", "load", "size", "values", "getSiblings", "isEmpty", "singletonMap", "getDefaultWriter", "entrySet", "getChildren", "getKey", "get", "parse", "get", "ordinal", "ordinal", "get", "containsKey", "put", "put", "getKey", "put", "toString", "create", "getValue", "isEmpty", "addWriter", "equals", "addWriter", "split", "trim", "split", "trim", "parse", "trim", "isEmpty", "addWriter", "indexOf", "emptyList"]}, "repository": {"repo_id": 5793618, "url": "https://github.com/pmwmedia/tinylog", "stars": 274, "created": "9/13/2012 11:21:42 AM +00:00", "updates": "2020-01-23T21:53:25+00:00", "fork": "False", "license": "licensed"}}