{"test_class": {"identifier": "TestSchemas", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String SCHEMA = \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"SampleNode\\\",\\\"doc\\\":\\\"caca\\\",\"\n      + \"\\\"namespace\\\":\\\"org.spf4j.ssdump2.avro\\\",\\n\" + \" \\\"fields\\\":[\\n\"\n      + \"    {\\\"name\\\":\\\"count\\\",\\\"type\\\":\\\"int\\\",\\\"default\\\":0,\\\"doc\\\":\\\"caca\\\"},\\n\"\n      + \"    {\\\"name\\\":\\\"kind1\\\",\\\"type\\\":{\\\"type\\\":\\\"enum\\\", \\\"name\\\": \\\"Kind1\\\", \\\"symbols\\\": [\\\"A1\\\", \\\"B1\\\"]}},\\n\"\n      + \"    {\\\"name\\\":\\\"kind2\\\",\\\"type\\\":{\\\"type\\\":\\\"enum\\\", \\\"name\\\": \\\"Kind2\\\", \\\"symbols\\\": [\\\"A2\\\", \\\"B2\\\"], \\\"doc\\\": \\\"doc\\\"}},\\n\"\n      + \"    {\\\"name\\\":\\\"pat\\\",\\\"type\\\":{\\\"type\\\":\\\"fixed\\\", \\\"name\\\": \\\"FixedPattern\\\", \\\"size\\\": 10}},\\n\"\n      + \"    {\\\"name\\\":\\\"uni\\\",\\\"type\\\":[\\\"int\\\", \\\"double\\\"]},\\n\"\n      + \"    {\\\"name\\\":\\\"mp\\\",\\\"type\\\":{\\\"type\\\":\\\"map\\\", \\\"values\\\": \\\"int\\\"}},\\n\"\n      + \"    {\\\"name\\\":\\\"subNodes\\\",\\\"type\\\":\\n\" + \"       {\\\"type\\\":\\\"array\\\",\\\"items\\\":{\\n\"\n      + \"           \\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"SamplePair\\\",\\n\" + \"           \\\"fields\\\":[\\n\"\n      + \"              {\\\"name\\\":\\\"method\\\",\\\"type\\\":\\n\"\n      + \"                  {\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"Method\\\",\\n\" + \"                  \\\"fields\\\":[\\n\"\n      + \"                     {\\\"name\\\":\\\"declaringClass\\\",\\\"type\\\":{\\\"type\\\":\\\"string\\\",\\\"avro.java.string\\\":\\\"String\\\"}},\\n\"\n      + \"                     {\\\"name\\\":\\\"methodName\\\",\\\"type\\\":{\\\"type\\\":\\\"string\\\",\\\"avro.java.string\\\":\\\"String\\\"}}\\n\"\n      + \"                  ]}},\\n\" + \"              {\\\"name\\\":\\\"node\\\",\\\"type\\\":\\\"SampleNode\\\"}]}}}\" + \"]}\";", "modifier": "private static final", "type": "String", "declarator": "SCHEMA = \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"SampleNode\\\",\\\"doc\\\":\\\"caca\\\",\"\n      + \"\\\"namespace\\\":\\\"org.spf4j.ssdump2.avro\\\",\\n\" + \" \\\"fields\\\":[\\n\"\n      + \"    {\\\"name\\\":\\\"count\\\",\\\"type\\\":\\\"int\\\",\\\"default\\\":0,\\\"doc\\\":\\\"caca\\\"},\\n\"\n      + \"    {\\\"name\\\":\\\"kind1\\\",\\\"type\\\":{\\\"type\\\":\\\"enum\\\", \\\"name\\\": \\\"Kind1\\\", \\\"symbols\\\": [\\\"A1\\\", \\\"B1\\\"]}},\\n\"\n      + \"    {\\\"name\\\":\\\"kind2\\\",\\\"type\\\":{\\\"type\\\":\\\"enum\\\", \\\"name\\\": \\\"Kind2\\\", \\\"symbols\\\": [\\\"A2\\\", \\\"B2\\\"], \\\"doc\\\": \\\"doc\\\"}},\\n\"\n      + \"    {\\\"name\\\":\\\"pat\\\",\\\"type\\\":{\\\"type\\\":\\\"fixed\\\", \\\"name\\\": \\\"FixedPattern\\\", \\\"size\\\": 10}},\\n\"\n      + \"    {\\\"name\\\":\\\"uni\\\",\\\"type\\\":[\\\"int\\\", \\\"double\\\"]},\\n\"\n      + \"    {\\\"name\\\":\\\"mp\\\",\\\"type\\\":{\\\"type\\\":\\\"map\\\", \\\"values\\\": \\\"int\\\"}},\\n\"\n      + \"    {\\\"name\\\":\\\"subNodes\\\",\\\"type\\\":\\n\" + \"       {\\\"type\\\":\\\"array\\\",\\\"items\\\":{\\n\"\n      + \"           \\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"SamplePair\\\",\\n\" + \"           \\\"fields\\\":[\\n\"\n      + \"              {\\\"name\\\":\\\"method\\\",\\\"type\\\":\\n\"\n      + \"                  {\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"Method\\\",\\n\" + \"                  \\\"fields\\\":[\\n\"\n      + \"                     {\\\"name\\\":\\\"declaringClass\\\",\\\"type\\\":{\\\"type\\\":\\\"string\\\",\\\"avro.java.string\\\":\\\"String\\\"}},\\n\"\n      + \"                     {\\\"name\\\":\\\"methodName\\\",\\\"type\\\":{\\\"type\\\":\\\"string\\\",\\\"avro.java.string\\\":\\\"String\\\"}}\\n\"\n      + \"                  ]}},\\n\" + \"              {\\\"name\\\":\\\"node\\\",\\\"type\\\":\\\"SampleNode\\\"}]}}}\" + \"]}\"", "var_name": "SCHEMA"}], "file": "lang/java/compiler/src/test/java/org/apache/avro/compiler/schema/TestSchemas.java"}, "test_case": {"identifier": "testVisit1", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testVisit1() {\n    String s1 = \"{\\\"type\\\": \\\"record\\\", \\\"name\\\": \\\"t1\\\", \\\"fields\\\": [\" + \"{\\\"name\\\": \\\"f1\\\", \\\"type\\\": \\\"int\\\"}\"\n        + \"]}\";\n    Assert.assertEquals(\"t1.\", Schemas.visit(new Schema.Parser().parse(s1), new TestVisitor()));\n  }", "signature": "void testVisit1()", "full_signature": "@Test public void testVisit1()", "class_method_signature": "TestSchemas.testVisit1()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "visit", "parse"]}, "focal_class": {"identifier": "Schemas", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "Schemas", "parameters": "()", "modifiers": "private", "return": "", "signature": " Schemas()", "full_signature": "private  Schemas()", "class_method_signature": "Schemas.Schemas()", "testcase": false, "constructor": true}, {"identifier": "copyAliases", "parameters": "(final Schema from, final Schema to)", "modifiers": "public static", "return": "void", "signature": "void copyAliases(final Schema from, final Schema to)", "full_signature": "public static void copyAliases(final Schema from, final Schema to)", "class_method_signature": "Schemas.copyAliases(final Schema from, final Schema to)", "testcase": false, "constructor": false}, {"identifier": "copyAliases", "parameters": "(final Schema.Field from, final Schema.Field to)", "modifiers": "public static", "return": "void", "signature": "void copyAliases(final Schema.Field from, final Schema.Field to)", "full_signature": "public static void copyAliases(final Schema.Field from, final Schema.Field to)", "class_method_signature": "Schemas.copyAliases(final Schema.Field from, final Schema.Field to)", "testcase": false, "constructor": false}, {"identifier": "copyLogicalTypes", "parameters": "(final Schema from, final Schema to)", "modifiers": "public static", "return": "void", "signature": "void copyLogicalTypes(final Schema from, final Schema to)", "full_signature": "public static void copyLogicalTypes(final Schema from, final Schema to)", "class_method_signature": "Schemas.copyLogicalTypes(final Schema from, final Schema to)", "testcase": false, "constructor": false}, {"identifier": "copyProperties", "parameters": "(final JsonProperties from, final JsonProperties to)", "modifiers": "public static", "return": "void", "signature": "void copyProperties(final JsonProperties from, final JsonProperties to)", "full_signature": "public static void copyProperties(final JsonProperties from, final JsonProperties to)", "class_method_signature": "Schemas.copyProperties(final JsonProperties from, final JsonProperties to)", "testcase": false, "constructor": false}, {"identifier": "hasGeneratedJavaClass", "parameters": "(final Schema schema)", "modifiers": "public static", "return": "boolean", "signature": "boolean hasGeneratedJavaClass(final Schema schema)", "full_signature": "public static boolean hasGeneratedJavaClass(final Schema schema)", "class_method_signature": "Schemas.hasGeneratedJavaClass(final Schema schema)", "testcase": false, "constructor": false}, {"identifier": "getJavaClassName", "parameters": "(final Schema schema)", "modifiers": "public static", "return": "String", "signature": "String getJavaClassName(final Schema schema)", "full_signature": "public static String getJavaClassName(final Schema schema)", "class_method_signature": "Schemas.getJavaClassName(final Schema schema)", "testcase": false, "constructor": false}, {"identifier": "visit", "parameters": "(final Schema start, final SchemaVisitor<T> visitor)", "modifiers": "public static", "return": "T", "signature": "T visit(final Schema start, final SchemaVisitor<T> visitor)", "full_signature": "public static T visit(final Schema start, final SchemaVisitor<T> visitor)", "class_method_signature": "Schemas.visit(final Schema start, final SchemaVisitor<T> visitor)", "testcase": false, "constructor": false}, {"identifier": "visitNonTerminal", "parameters": "(final SchemaVisitor visitor, final Schema schema, final Deque<Object> dq,\n      final Iterable<Schema> itSupp)", "modifiers": "private static", "return": "boolean", "signature": "boolean visitNonTerminal(final SchemaVisitor visitor, final Schema schema, final Deque<Object> dq,\n      final Iterable<Schema> itSupp)", "full_signature": "private static boolean visitNonTerminal(final SchemaVisitor visitor, final Schema schema, final Deque<Object> dq,\n      final Iterable<Schema> itSupp)", "class_method_signature": "Schemas.visitNonTerminal(final SchemaVisitor visitor, final Schema schema, final Deque<Object> dq,\n      final Iterable<Schema> itSupp)", "testcase": false, "constructor": false}, {"identifier": "visitTerminal", "parameters": "(final SchemaVisitor visitor, final Schema schema, final Deque<Object> dq)", "modifiers": "private static", "return": "boolean", "signature": "boolean visitTerminal(final SchemaVisitor visitor, final Schema schema, final Deque<Object> dq)", "full_signature": "private static boolean visitTerminal(final SchemaVisitor visitor, final Schema schema, final Deque<Object> dq)", "class_method_signature": "Schemas.visitTerminal(final SchemaVisitor visitor, final Schema schema, final Deque<Object> dq)", "testcase": false, "constructor": false}], "file": "lang/java/compiler/src/main/java/org/apache/avro/compiler/schema/Schemas.java"}, "focal_method": {"identifier": "visit", "parameters": "(final Schema start, final SchemaVisitor<T> visitor)", "modifiers": "public static", "return": "T", "body": "public static <T> T visit(final Schema start, final SchemaVisitor<T> visitor) {\n    // Set of Visited Schemas\n    IdentityHashMap<Schema, Schema> visited = new IdentityHashMap<>();\n    // Stack that contains the Schams to process and afterVisitNonTerminal\n    // functions.\n    // Deque<Either<Schema, Supplier<SchemaVisitorAction>>>\n    // Using either has a cost which we want to avoid...\n    Deque<Object> dq = new ArrayDeque<>();\n    dq.addLast(start);\n    Object current;\n    while ((current = dq.pollLast()) != null) {\n      if (current instanceof Supplier) {\n        // we are executing a non terminal post visit.\n        SchemaVisitorAction action = ((Supplier<SchemaVisitorAction>) current).get();\n        switch (action) {\n        case CONTINUE:\n          break;\n        case SKIP_SUBTREE:\n          throw new UnsupportedOperationException();\n        case SKIP_SIBLINGS:\n          while (dq.getLast() instanceof Schema) {\n            dq.removeLast();\n          }\n          break;\n        case TERMINATE:\n          return visitor.get();\n        default:\n          throw new UnsupportedOperationException(\"Invalid action \" + action);\n        }\n      } else {\n        Schema schema = (Schema) current;\n        boolean terminate;\n        if (!visited.containsKey(schema)) {\n          Schema.Type type = schema.getType();\n          switch (type) {\n          case ARRAY:\n            terminate = visitNonTerminal(visitor, schema, dq, Collections.singleton(schema.getElementType()));\n            visited.put(schema, schema);\n            break;\n          case RECORD:\n            Iterator<Schema> reverseSchemas = schema.getFields().stream().map(Field::schema)\n                .collect(Collectors.toCollection(ArrayDeque::new)).descendingIterator();\n            terminate = visitNonTerminal(visitor, schema, dq, () -> reverseSchemas);\n            visited.put(schema, schema);\n            break;\n          case UNION:\n            terminate = visitNonTerminal(visitor, schema, dq, schema.getTypes());\n            visited.put(schema, schema);\n            break;\n          case MAP:\n            terminate = visitNonTerminal(visitor, schema, dq, Collections.singleton(schema.getValueType()));\n            visited.put(schema, schema);\n            break;\n          case NULL:\n          case BOOLEAN:\n          case BYTES:\n          case DOUBLE:\n          case ENUM:\n          case FIXED:\n          case FLOAT:\n          case INT:\n          case LONG:\n          case STRING:\n            terminate = visitTerminal(visitor, schema, dq);\n            break;\n          default:\n            throw new UnsupportedOperationException(\"Invalid type \" + type);\n          }\n\n        } else {\n          terminate = visitTerminal(visitor, schema, dq);\n        }\n        if (terminate) {\n          return visitor.get();\n        }\n      }\n    }\n    return visitor.get();\n  }", "signature": "T visit(final Schema start, final SchemaVisitor<T> visitor)", "full_signature": "public static T visit(final Schema start, final SchemaVisitor<T> visitor)", "class_method_signature": "Schemas.visit(final Schema start, final SchemaVisitor<T> visitor)", "testcase": false, "constructor": false, "invocations": ["addLast", "pollLast", "get", "getLast", "removeLast", "get", "containsKey", "getType", "visitNonTerminal", "singleton", "getElementType", "put", "descendingIterator", "collect", "map", "stream", "getFields", "toCollection", "visitNonTerminal", "put", "visitNonTerminal", "getTypes", "put", "visitNonTerminal", "singleton", "getValueType", "put", "visitTerminal", "visitTerminal", "get", "get"]}, "repository": {"repo_id": 206459, "url": "https://github.com/apache/avro", "stars": 1473, "created": "5/21/2009 2:48:37 AM +00:00", "updates": "2020-01-23T18:50:51+00:00", "fork": "False", "license": "licensed"}}