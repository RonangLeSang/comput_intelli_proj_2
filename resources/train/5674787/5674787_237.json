{"test_class": {"identifier": "CFGTest", "superclass": "", "interfaces": "", "fields": [], "file": "java-frontend/src/test/java/org/sonar/java/cfg/CFGTest.java"}, "test_case": {"identifier": "conditionalOR", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n  void conditionalOR() {\n    final CFG cfg = buildCFG(\"void fun() {if(a || b) { foo(); } }\");\n    final CFGChecker cfgChecker = checker(\n      block(\n        element(Tree.Kind.IDENTIFIER, \"a\")\n        ).terminator(Tree.Kind.CONDITIONAL_OR).successors(1, 2),\n      block(\n        element(Tree.Kind.IDENTIFIER, \"b\")\n        ).terminator(Tree.Kind.IF_STATEMENT).successors(0, 1),\n      block(\n        element(Tree.Kind.IDENTIFIER, \"foo\"),\n        element(Tree.Kind.METHOD_INVOCATION)\n        ).successors(0));\n    cfgChecker.check(cfg);\n  }", "signature": "void conditionalOR()", "full_signature": "@Test void conditionalOR()", "class_method_signature": "CFGTest.conditionalOR()", "testcase": true, "constructor": false, "invocations": ["buildCFG", "checker", "successors", "terminator", "block", "element", "successors", "terminator", "block", "element", "successors", "block", "element", "element", "check"]}, "focal_class": {"identifier": "CFG", "superclass": "", "interfaces": "implements ControlFlowGraph", "fields": [{"original_string": "private final boolean ignoreBreakAndContinue;", "modifier": "private final", "type": "boolean", "declarator": "ignoreBreakAndContinue", "var_name": "ignoreBreakAndContinue"}, {"original_string": "@Nullable\n  private Symbol.MethodSymbol methodSymbol;", "modifier": "@Nullable\n  private", "type": "Symbol.MethodSymbol", "declarator": "methodSymbol", "var_name": "methodSymbol"}, {"original_string": "private Block currentBlock;", "modifier": "private", "type": "Block", "declarator": "currentBlock", "var_name": "currentBlock"}, {"original_string": "private final List<Block> blocks = new ArrayList<>();", "modifier": "private final", "type": "List<Block>", "declarator": "blocks = new ArrayList<>()", "var_name": "blocks"}, {"original_string": "private final Deque<Block> breakTargets = new LinkedList<>();", "modifier": "private final", "type": "Deque<Block>", "declarator": "breakTargets = new LinkedList<>()", "var_name": "breakTargets"}, {"original_string": "private final Deque<Block> continueTargets = new LinkedList<>();", "modifier": "private final", "type": "Deque<Block>", "declarator": "continueTargets = new LinkedList<>()", "var_name": "continueTargets"}, {"original_string": "private final Deque<Block> exitBlocks = new LinkedList<>();", "modifier": "private final", "type": "Deque<Block>", "declarator": "exitBlocks = new LinkedList<>()", "var_name": "exitBlocks"}, {"original_string": "private final Deque<TryStatement> enclosingTry = new LinkedList<>();", "modifier": "private final", "type": "Deque<TryStatement>", "declarator": "enclosingTry = new LinkedList<>()", "var_name": "enclosingTry"}, {"original_string": "private final Deque<Boolean> enclosedByCatch = new LinkedList<>();", "modifier": "private final", "type": "Deque<Boolean>", "declarator": "enclosedByCatch = new LinkedList<>()", "var_name": "enclosedByCatch"}, {"original_string": "private final TryStatement outerTry;", "modifier": "private final", "type": "TryStatement", "declarator": "outerTry", "var_name": "outerTry"}, {"original_string": "private String pendingLabel = null;", "modifier": "private", "type": "String", "declarator": "pendingLabel = null", "var_name": "pendingLabel"}, {"original_string": "private Map<String, Block> labelsBreakTarget = new HashMap<>();", "modifier": "private", "type": "Map<String, Block>", "declarator": "labelsBreakTarget = new HashMap<>()", "var_name": "labelsBreakTarget"}, {"original_string": "private Map<String, Block> labelsContinueTarget = new HashMap<>();", "modifier": "private", "type": "Map<String, Block>", "declarator": "labelsContinueTarget = new HashMap<>()", "var_name": "labelsContinueTarget"}], "methods": [{"identifier": "CFG", "parameters": "(List<? extends Tree> trees, @Nullable Symbol.MethodSymbol symbol, boolean ignoreBreakAndContinue)", "modifiers": "private", "return": "", "signature": " CFG(List<? extends Tree> trees, @Nullable Symbol.MethodSymbol symbol, boolean ignoreBreakAndContinue)", "full_signature": "private  CFG(List<? extends Tree> trees, @Nullable Symbol.MethodSymbol symbol, boolean ignoreBreakAndContinue)", "class_method_signature": "CFG.CFG(List<? extends Tree> trees, @Nullable Symbol.MethodSymbol symbol, boolean ignoreBreakAndContinue)", "testcase": false, "constructor": true}, {"identifier": "exitBlock", "parameters": "()", "modifiers": "@Override public", "return": "Block", "signature": "Block exitBlock()", "full_signature": "@Override public Block exitBlock()", "class_method_signature": "CFG.exitBlock()", "testcase": false, "constructor": false}, {"identifier": "methodSymbol", "parameters": "()", "modifiers": "@Nullable public", "return": "Symbol.MethodSymbol", "signature": "Symbol.MethodSymbol methodSymbol()", "full_signature": "@Nullable public Symbol.MethodSymbol methodSymbol()", "class_method_signature": "CFG.methodSymbol()", "testcase": false, "constructor": false}, {"identifier": "entryBlock", "parameters": "()", "modifiers": "@Override public", "return": "Block", "signature": "Block entryBlock()", "full_signature": "@Override public Block entryBlock()", "class_method_signature": "CFG.entryBlock()", "testcase": false, "constructor": false}, {"identifier": "blocks", "parameters": "()", "modifiers": "@Override public", "return": "List<Block>", "signature": "List<Block> blocks()", "full_signature": "@Override public List<Block> blocks()", "class_method_signature": "CFG.blocks()", "testcase": false, "constructor": false}, {"identifier": "reversedBlocks", "parameters": "()", "modifiers": "public", "return": "List<Block>", "signature": "List<Block> reversedBlocks()", "full_signature": "public List<Block> reversedBlocks()", "class_method_signature": "CFG.reversedBlocks()", "testcase": false, "constructor": false}, {"identifier": "computePredecessors", "parameters": "(List<Block> blocks)", "modifiers": "private static", "return": "void", "signature": "void computePredecessors(List<Block> blocks)", "full_signature": "private static void computePredecessors(List<Block> blocks)", "class_method_signature": "CFG.computePredecessors(List<Block> blocks)", "testcase": false, "constructor": false}, {"identifier": "cleanupUnfeasibleBreakPaths", "parameters": "(List<Block> blocks)", "modifiers": "private static", "return": "void", "signature": "void cleanupUnfeasibleBreakPaths(List<Block> blocks)", "full_signature": "private static void cleanupUnfeasibleBreakPaths(List<Block> blocks)", "class_method_signature": "CFG.cleanupUnfeasibleBreakPaths(List<Block> blocks)", "testcase": false, "constructor": false}, {"identifier": "isLoop", "parameters": "(Block successor)", "modifiers": "private static", "return": "boolean", "signature": "boolean isLoop(Block successor)", "full_signature": "private static boolean isLoop(Block successor)", "class_method_signature": "CFG.isLoop(Block successor)", "testcase": false, "constructor": false}, {"identifier": "getAfterLoopBlock", "parameters": "(Block loop)", "modifiers": "@CheckForNull private static", "return": "Block", "signature": "Block getAfterLoopBlock(Block loop)", "full_signature": "@CheckForNull private static Block getAfterLoopBlock(Block loop)", "class_method_signature": "CFG.getAfterLoopBlock(Block loop)", "testcase": false, "constructor": false}, {"identifier": "prune", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void prune()", "full_signature": "private void prune()", "class_method_signature": "CFG.prune()", "testcase": false, "constructor": false}, {"identifier": "isInactive", "parameters": "(Block block)", "modifiers": "private", "return": "boolean", "signature": "boolean isInactive(Block block)", "full_signature": "private boolean isInactive(Block block)", "class_method_signature": "CFG.isInactive(Block block)", "testcase": false, "constructor": false}, {"identifier": "removeInactiveBlocks", "parameters": "(List<Block> inactiveBlocks)", "modifiers": "private", "return": "void", "signature": "void removeInactiveBlocks(List<Block> inactiveBlocks)", "full_signature": "private void removeInactiveBlocks(List<Block> inactiveBlocks)", "class_method_signature": "CFG.removeInactiveBlocks(List<Block> inactiveBlocks)", "testcase": false, "constructor": false}, {"identifier": "createBlock", "parameters": "(Block successor)", "modifiers": "private", "return": "Block", "signature": "Block createBlock(Block successor)", "full_signature": "private Block createBlock(Block successor)", "class_method_signature": "CFG.createBlock(Block successor)", "testcase": false, "constructor": false}, {"identifier": "createBlock", "parameters": "()", "modifiers": "private", "return": "Block", "signature": "Block createBlock()", "full_signature": "private Block createBlock()", "class_method_signature": "CFG.createBlock()", "testcase": false, "constructor": false}, {"identifier": "buildCFG", "parameters": "(List<? extends Tree> trees, boolean ignoreBreak)", "modifiers": "public static", "return": "CFG", "signature": "CFG buildCFG(List<? extends Tree> trees, boolean ignoreBreak)", "full_signature": "public static CFG buildCFG(List<? extends Tree> trees, boolean ignoreBreak)", "class_method_signature": "CFG.buildCFG(List<? extends Tree> trees, boolean ignoreBreak)", "testcase": false, "constructor": false}, {"identifier": "buildCFG", "parameters": "(List<? extends Tree> trees)", "modifiers": "public static", "return": "CFG", "signature": "CFG buildCFG(List<? extends Tree> trees)", "full_signature": "public static CFG buildCFG(List<? extends Tree> trees)", "class_method_signature": "CFG.buildCFG(List<? extends Tree> trees)", "testcase": false, "constructor": false}, {"identifier": "build", "parameters": "(MethodTree tree)", "modifiers": "public static", "return": "CFG", "signature": "CFG build(MethodTree tree)", "full_signature": "public static CFG build(MethodTree tree)", "class_method_signature": "CFG.build(MethodTree tree)", "testcase": false, "constructor": false}, {"identifier": "build", "parameters": "(ListTree<? extends Tree> trees)", "modifiers": "private", "return": "void", "signature": "void build(ListTree<? extends Tree> trees)", "full_signature": "private void build(ListTree<? extends Tree> trees)", "class_method_signature": "CFG.build(ListTree<? extends Tree> trees)", "testcase": false, "constructor": false}, {"identifier": "build", "parameters": "(List<? extends Tree> trees)", "modifiers": "private", "return": "void", "signature": "void build(List<? extends Tree> trees)", "full_signature": "private void build(List<? extends Tree> trees)", "class_method_signature": "CFG.build(List<? extends Tree> trees)", "testcase": false, "constructor": false}, {"identifier": "build", "parameters": "(Tree tree)", "modifiers": "private", "return": "void", "signature": "void build(Tree tree)", "full_signature": "private void build(Tree tree)", "class_method_signature": "CFG.build(Tree tree)", "testcase": false, "constructor": false}, {"identifier": "buildReturnStatement", "parameters": "(ReturnStatementTree returnStatement)", "modifiers": "private", "return": "void", "signature": "void buildReturnStatement(ReturnStatementTree returnStatement)", "full_signature": "private void buildReturnStatement(ReturnStatementTree returnStatement)", "class_method_signature": "CFG.buildReturnStatement(ReturnStatementTree returnStatement)", "testcase": false, "constructor": false}, {"identifier": "buildMethodInvocation", "parameters": "(MethodInvocationTree mit)", "modifiers": "private", "return": "void", "signature": "void buildMethodInvocation(MethodInvocationTree mit)", "full_signature": "private void buildMethodInvocation(MethodInvocationTree mit)", "class_method_signature": "CFG.buildMethodInvocation(MethodInvocationTree mit)", "testcase": false, "constructor": false}, {"identifier": "buildIfStatement", "parameters": "(IfStatementTree ifStatementTree)", "modifiers": "private", "return": "void", "signature": "void buildIfStatement(IfStatementTree ifStatementTree)", "full_signature": "private void buildIfStatement(IfStatementTree ifStatementTree)", "class_method_signature": "CFG.buildIfStatement(IfStatementTree ifStatementTree)", "testcase": false, "constructor": false}, {"identifier": "buildConditionalExpression", "parameters": "(ConditionalExpressionTree cond)", "modifiers": "private", "return": "void", "signature": "void buildConditionalExpression(ConditionalExpressionTree cond)", "full_signature": "private void buildConditionalExpression(ConditionalExpressionTree cond)", "class_method_signature": "CFG.buildConditionalExpression(ConditionalExpressionTree cond)", "testcase": false, "constructor": false}, {"identifier": "buildVariable", "parameters": "(VariableTree tree)", "modifiers": "private", "return": "void", "signature": "void buildVariable(VariableTree tree)", "full_signature": "private void buildVariable(VariableTree tree)", "class_method_signature": "CFG.buildVariable(VariableTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildBinaryExpression", "parameters": "(Tree tree)", "modifiers": "private", "return": "void", "signature": "void buildBinaryExpression(Tree tree)", "full_signature": "private void buildBinaryExpression(Tree tree)", "class_method_signature": "CFG.buildBinaryExpression(Tree tree)", "testcase": false, "constructor": false}, {"identifier": "buildAssignment", "parameters": "(AssignmentExpressionTree tree)", "modifiers": "private", "return": "void", "signature": "void buildAssignment(AssignmentExpressionTree tree)", "full_signature": "private void buildAssignment(AssignmentExpressionTree tree)", "class_method_signature": "CFG.buildAssignment(AssignmentExpressionTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildMemberSelect", "parameters": "(MemberSelectExpressionTree mse)", "modifiers": "private", "return": "void", "signature": "void buildMemberSelect(MemberSelectExpressionTree mse)", "full_signature": "private void buildMemberSelect(MemberSelectExpressionTree mse)", "class_method_signature": "CFG.buildMemberSelect(MemberSelectExpressionTree mse)", "testcase": false, "constructor": false}, {"identifier": "buildConditionalAnd", "parameters": "(BinaryExpressionTree tree)", "modifiers": "private", "return": "void", "signature": "void buildConditionalAnd(BinaryExpressionTree tree)", "full_signature": "private void buildConditionalAnd(BinaryExpressionTree tree)", "class_method_signature": "CFG.buildConditionalAnd(BinaryExpressionTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildConditionalOr", "parameters": "(BinaryExpressionTree tree)", "modifiers": "private", "return": "void", "signature": "void buildConditionalOr(BinaryExpressionTree tree)", "full_signature": "private void buildConditionalOr(BinaryExpressionTree tree)", "class_method_signature": "CFG.buildConditionalOr(BinaryExpressionTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildConditionalBinaryLHS", "parameters": "(BinaryExpressionTree tree, Block trueBlock, Block falseBlock)", "modifiers": "private", "return": "void", "signature": "void buildConditionalBinaryLHS(BinaryExpressionTree tree, Block trueBlock, Block falseBlock)", "full_signature": "private void buildConditionalBinaryLHS(BinaryExpressionTree tree, Block trueBlock, Block falseBlock)", "class_method_signature": "CFG.buildConditionalBinaryLHS(BinaryExpressionTree tree, Block trueBlock, Block falseBlock)", "testcase": false, "constructor": false}, {"identifier": "buildLabeledStatement", "parameters": "(LabeledStatementTree labeledStatement)", "modifiers": "private", "return": "void", "signature": "void buildLabeledStatement(LabeledStatementTree labeledStatement)", "full_signature": "private void buildLabeledStatement(LabeledStatementTree labeledStatement)", "class_method_signature": "CFG.buildLabeledStatement(LabeledStatementTree labeledStatement)", "testcase": false, "constructor": false}, {"identifier": "buildSwitchStatement", "parameters": "(SwitchStatementTree switchStatementTree)", "modifiers": "private", "return": "void", "signature": "void buildSwitchStatement(SwitchStatementTree switchStatementTree)", "full_signature": "private void buildSwitchStatement(SwitchStatementTree switchStatementTree)", "class_method_signature": "CFG.buildSwitchStatement(SwitchStatementTree switchStatementTree)", "testcase": false, "constructor": false}, {"identifier": "buildSwitchExpression", "parameters": "(SwitchExpressionTree switchExpressionTree)", "modifiers": "private", "return": "void", "signature": "void buildSwitchExpression(SwitchExpressionTree switchExpressionTree)", "full_signature": "private void buildSwitchExpression(SwitchExpressionTree switchExpressionTree)", "class_method_signature": "CFG.buildSwitchExpression(SwitchExpressionTree switchExpressionTree)", "testcase": false, "constructor": false}, {"identifier": "buildSwitchExpression", "parameters": "(SwitchExpressionTree switchExpressionTree, Tree terminator)", "modifiers": "private", "return": "void", "signature": "void buildSwitchExpression(SwitchExpressionTree switchExpressionTree, Tree terminator)", "full_signature": "private void buildSwitchExpression(SwitchExpressionTree switchExpressionTree, Tree terminator)", "class_method_signature": "CFG.buildSwitchExpression(SwitchExpressionTree switchExpressionTree, Tree terminator)", "testcase": false, "constructor": false}, {"identifier": "switchWithoutFallThrough", "parameters": "(SwitchExpressionTree switchExpressionTree)", "modifiers": "private static", "return": "boolean", "signature": "boolean switchWithoutFallThrough(SwitchExpressionTree switchExpressionTree)", "full_signature": "private static boolean switchWithoutFallThrough(SwitchExpressionTree switchExpressionTree)", "class_method_signature": "CFG.switchWithoutFallThrough(SwitchExpressionTree switchExpressionTree)", "testcase": false, "constructor": false}, {"identifier": "containsDefaultCase", "parameters": "(List<CaseLabelTree> labels)", "modifiers": "private static", "return": "boolean", "signature": "boolean containsDefaultCase(List<CaseLabelTree> labels)", "full_signature": "private static boolean containsDefaultCase(List<CaseLabelTree> labels)", "class_method_signature": "CFG.containsDefaultCase(List<CaseLabelTree> labels)", "testcase": false, "constructor": false}, {"identifier": "buildBreakStatement", "parameters": "(BreakStatementTree tree)", "modifiers": "private", "return": "void", "signature": "void buildBreakStatement(BreakStatementTree tree)", "full_signature": "private void buildBreakStatement(BreakStatementTree tree)", "class_method_signature": "CFG.buildBreakStatement(BreakStatementTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildYieldStatement", "parameters": "(YieldStatementTree tree)", "modifiers": "private", "return": "void", "signature": "void buildYieldStatement(YieldStatementTree tree)", "full_signature": "private void buildYieldStatement(YieldStatementTree tree)", "class_method_signature": "CFG.buildYieldStatement(YieldStatementTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildContinueStatement", "parameters": "(ContinueStatementTree tree)", "modifiers": "private", "return": "void", "signature": "void buildContinueStatement(ContinueStatementTree tree)", "full_signature": "private void buildContinueStatement(ContinueStatementTree tree)", "class_method_signature": "CFG.buildContinueStatement(ContinueStatementTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildWhileStatement", "parameters": "(WhileStatementTree whileStatement)", "modifiers": "private", "return": "void", "signature": "void buildWhileStatement(WhileStatementTree whileStatement)", "full_signature": "private void buildWhileStatement(WhileStatementTree whileStatement)", "class_method_signature": "CFG.buildWhileStatement(WhileStatementTree whileStatement)", "testcase": false, "constructor": false}, {"identifier": "buildDoWhileStatement", "parameters": "(DoWhileStatementTree doWhileStatementTree)", "modifiers": "private", "return": "void", "signature": "void buildDoWhileStatement(DoWhileStatementTree doWhileStatementTree)", "full_signature": "private void buildDoWhileStatement(DoWhileStatementTree doWhileStatementTree)", "class_method_signature": "CFG.buildDoWhileStatement(DoWhileStatementTree doWhileStatementTree)", "testcase": false, "constructor": false}, {"identifier": "buildForEachStatement", "parameters": "(ForEachStatement tree)", "modifiers": "private", "return": "void", "signature": "void buildForEachStatement(ForEachStatement tree)", "full_signature": "private void buildForEachStatement(ForEachStatement tree)", "class_method_signature": "CFG.buildForEachStatement(ForEachStatement tree)", "testcase": false, "constructor": false}, {"identifier": "addContinueTarget", "parameters": "(Block target)", "modifiers": "private", "return": "void", "signature": "void addContinueTarget(Block target)", "full_signature": "private void addContinueTarget(Block target)", "class_method_signature": "CFG.addContinueTarget(Block target)", "testcase": false, "constructor": false}, {"identifier": "buildForStatement", "parameters": "(ForStatementTree tree)", "modifiers": "private", "return": "void", "signature": "void buildForStatement(ForStatementTree tree)", "full_signature": "private void buildForStatement(ForStatementTree tree)", "class_method_signature": "CFG.buildForStatement(ForStatementTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildTryStatement", "parameters": "(TryStatementTree tryStatementTree)", "modifiers": "private", "return": "void", "signature": "void buildTryStatement(TryStatementTree tryStatementTree)", "full_signature": "private void buildTryStatement(TryStatementTree tryStatementTree)", "class_method_signature": "CFG.buildTryStatement(TryStatementTree tryStatementTree)", "testcase": false, "constructor": false}, {"identifier": "buildThrowStatement", "parameters": "(ThrowStatementTree throwStatementTree)", "modifiers": "private", "return": "void", "signature": "void buildThrowStatement(ThrowStatementTree throwStatementTree)", "full_signature": "private void buildThrowStatement(ThrowStatementTree throwStatementTree)", "class_method_signature": "CFG.buildThrowStatement(ThrowStatementTree throwStatementTree)", "testcase": false, "constructor": false}, {"identifier": "buildSynchronizedStatement", "parameters": "(SynchronizedStatementTree sst)", "modifiers": "private", "return": "void", "signature": "void buildSynchronizedStatement(SynchronizedStatementTree sst)", "full_signature": "private void buildSynchronizedStatement(SynchronizedStatementTree sst)", "class_method_signature": "CFG.buildSynchronizedStatement(SynchronizedStatementTree sst)", "testcase": false, "constructor": false}, {"identifier": "buildUnaryExpression", "parameters": "(UnaryExpressionTree tree)", "modifiers": "private", "return": "void", "signature": "void buildUnaryExpression(UnaryExpressionTree tree)", "full_signature": "private void buildUnaryExpression(UnaryExpressionTree tree)", "class_method_signature": "CFG.buildUnaryExpression(UnaryExpressionTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildArrayAccessExpression", "parameters": "(ArrayAccessExpressionTree tree)", "modifiers": "private", "return": "void", "signature": "void buildArrayAccessExpression(ArrayAccessExpressionTree tree)", "full_signature": "private void buildArrayAccessExpression(ArrayAccessExpressionTree tree)", "class_method_signature": "CFG.buildArrayAccessExpression(ArrayAccessExpressionTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildArrayDimension", "parameters": "(ArrayDimensionTree tree)", "modifiers": "private", "return": "void", "signature": "void buildArrayDimension(ArrayDimensionTree tree)", "full_signature": "private void buildArrayDimension(ArrayDimensionTree tree)", "class_method_signature": "CFG.buildArrayDimension(ArrayDimensionTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildNewClass", "parameters": "(NewClassTree tree)", "modifiers": "private", "return": "void", "signature": "void buildNewClass(NewClassTree tree)", "full_signature": "private void buildNewClass(NewClassTree tree)", "class_method_signature": "CFG.buildNewClass(NewClassTree tree)", "testcase": false, "constructor": false}, {"identifier": "handleExceptionalPaths", "parameters": "(Symbol symbol)", "modifiers": "private", "return": "void", "signature": "void handleExceptionalPaths(Symbol symbol)", "full_signature": "private void handleExceptionalPaths(Symbol symbol)", "class_method_signature": "CFG.handleExceptionalPaths(Symbol symbol)", "testcase": false, "constructor": false}, {"identifier": "buildTypeCast", "parameters": "(Tree tree)", "modifiers": "private", "return": "void", "signature": "void buildTypeCast(Tree tree)", "full_signature": "private void buildTypeCast(Tree tree)", "class_method_signature": "CFG.buildTypeCast(Tree tree)", "testcase": false, "constructor": false}, {"identifier": "buildInstanceOf", "parameters": "(InstanceOfTree instanceOfTree)", "modifiers": "private", "return": "void", "signature": "void buildInstanceOf(InstanceOfTree instanceOfTree)", "full_signature": "private void buildInstanceOf(InstanceOfTree instanceOfTree)", "class_method_signature": "CFG.buildInstanceOf(InstanceOfTree instanceOfTree)", "testcase": false, "constructor": false}, {"identifier": "buildNewArray", "parameters": "(NewArrayTree tree)", "modifiers": "private", "return": "void", "signature": "void buildNewArray(NewArrayTree tree)", "full_signature": "private void buildNewArray(NewArrayTree tree)", "class_method_signature": "CFG.buildNewArray(NewArrayTree tree)", "testcase": false, "constructor": false}, {"identifier": "buildAssertStatement", "parameters": "(AssertStatementTree assertStatementTree)", "modifiers": "private", "return": "void", "signature": "void buildAssertStatement(AssertStatementTree assertStatementTree)", "full_signature": "private void buildAssertStatement(AssertStatementTree assertStatementTree)", "class_method_signature": "CFG.buildAssertStatement(AssertStatementTree assertStatementTree)", "testcase": false, "constructor": false}, {"identifier": "createUnconditionalJump", "parameters": "(Tree terminator, @Nullable Block target, @Nullable Block successorWithoutJump)", "modifiers": "private", "return": "Block", "signature": "Block createUnconditionalJump(Tree terminator, @Nullable Block target, @Nullable Block successorWithoutJump)", "full_signature": "private Block createUnconditionalJump(Tree terminator, @Nullable Block target, @Nullable Block successorWithoutJump)", "class_method_signature": "CFG.createUnconditionalJump(Tree terminator, @Nullable Block target, @Nullable Block successorWithoutJump)", "testcase": false, "constructor": false}, {"identifier": "buildCondition", "parameters": "(Tree syntaxNode, Block trueBlock, Block falseBlock)", "modifiers": "private", "return": "void", "signature": "void buildCondition(Tree syntaxNode, Block trueBlock, Block falseBlock)", "full_signature": "private void buildCondition(Tree syntaxNode, Block trueBlock, Block falseBlock)", "class_method_signature": "CFG.buildCondition(Tree syntaxNode, Block trueBlock, Block falseBlock)", "testcase": false, "constructor": false}, {"identifier": "buildConditionalOr", "parameters": "(BinaryExpressionTree conditionalOr, Block trueBlock, Block falseBlock)", "modifiers": "private", "return": "void", "signature": "void buildConditionalOr(BinaryExpressionTree conditionalOr, Block trueBlock, Block falseBlock)", "full_signature": "private void buildConditionalOr(BinaryExpressionTree conditionalOr, Block trueBlock, Block falseBlock)", "class_method_signature": "CFG.buildConditionalOr(BinaryExpressionTree conditionalOr, Block trueBlock, Block falseBlock)", "testcase": false, "constructor": false}, {"identifier": "buildConditionalAnd", "parameters": "(BinaryExpressionTree conditionalAnd, Block trueBlock, Block falseBlock)", "modifiers": "private", "return": "void", "signature": "void buildConditionalAnd(BinaryExpressionTree conditionalAnd, Block trueBlock, Block falseBlock)", "full_signature": "private void buildConditionalAnd(BinaryExpressionTree conditionalAnd, Block trueBlock, Block falseBlock)", "class_method_signature": "CFG.buildConditionalAnd(BinaryExpressionTree conditionalAnd, Block trueBlock, Block falseBlock)", "testcase": false, "constructor": false}, {"identifier": "createBranch", "parameters": "(Tree terminator, Block trueBranch, Block falseBranch)", "modifiers": "private", "return": "Block", "signature": "Block createBranch(Tree terminator, Block trueBranch, Block falseBranch)", "full_signature": "private Block createBranch(Tree terminator, Block trueBranch, Block falseBranch)", "class_method_signature": "CFG.createBranch(Tree terminator, Block trueBranch, Block falseBranch)", "testcase": false, "constructor": false}, {"identifier": "setMethodSymbol", "parameters": "(Symbol.MethodSymbol methodSymbol)", "modifiers": "public", "return": "void", "signature": "void setMethodSymbol(Symbol.MethodSymbol methodSymbol)", "full_signature": "public void setMethodSymbol(Symbol.MethodSymbol methodSymbol)", "class_method_signature": "CFG.setMethodSymbol(Symbol.MethodSymbol methodSymbol)", "testcase": false, "constructor": false}], "file": "java-frontend/src/main/java/org/sonar/java/cfg/CFG.java"}, "focal_method": {"identifier": "buildCFG", "parameters": "(List<? extends Tree> trees, boolean ignoreBreak)", "modifiers": "public static", "return": "CFG", "body": "public static CFG buildCFG(List<? extends Tree> trees, boolean ignoreBreak) {\n    return new CFG(trees, null, ignoreBreak);\n  }", "signature": "CFG buildCFG(List<? extends Tree> trees, boolean ignoreBreak)", "full_signature": "public static CFG buildCFG(List<? extends Tree> trees, boolean ignoreBreak)", "class_method_signature": "CFG.buildCFG(List<? extends Tree> trees, boolean ignoreBreak)", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 5674787, "url": "https://github.com/SonarSource/sonar-java", "stars": 597, "created": "9/4/2012 3:53:13 PM +00:00", "updates": "2020-01-27T13:20:27+00:00", "fork": "False", "license": "licensed"}}