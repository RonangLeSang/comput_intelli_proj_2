{"test_class": {"identifier": "AbstractRegexCheckTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String JAVA_CODE = \"\"\n    + \"package org.foo;\\n\"\n    + \"import static java.util.regex.Pattern.MULTILINE;\"\n    + \"class A {\\n\"\n    + \"  void m(Object arg) {\\n\"\n    + \"    %s\\n\"\n    + \"    m(%s);\\n\"\n    + \"  }\\n\"\n    + \"  public static final String A_CONST = \\\"a_constant_value\\\";\\n\"\n    + \"}\";", "modifier": "private static final", "type": "String", "declarator": "JAVA_CODE = \"\"\n    + \"package org.foo;\\n\"\n    + \"import static java.util.regex.Pattern.MULTILINE;\"\n    + \"class A {\\n\"\n    + \"  void m(Object arg) {\\n\"\n    + \"    %s\\n\"\n    + \"    m(%s);\\n\"\n    + \"  }\\n\"\n    + \"  public static final String A_CONST = \\\"a_constant_value\\\";\\n\"\n    + \"}\"", "var_name": "JAVA_CODE"}], "file": "java-checks/src/test/java/org/sonar/java/checks/regex/AbstractRegexCheckTest.java"}, "test_case": {"identifier": "test_GetLiterals_string_concatenation", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n  void test_GetLiterals_string_concatenation() {\n    TestCase testcase = getArg(\"\\\"a\\\" + \\\"b\\\" + \\\"c\\\"\");\n    ExpressionTree expr = testcase.expr;\n\n    BinaryExpressionTree ab = (BinaryExpressionTree) ((BinaryExpressionTree) expr).leftOperand();\n    ExpressionTree a = ab.leftOperand();\n    ExpressionTree b = ab.rightOperand();\n    ExpressionTree c = ((BinaryExpressionTree) expr).rightOperand();\n\n    Optional<LiteralTree[]> result = getLiterals(expr);\n    assertThat(result).isPresent();\n\n    assertThat(result.get())\n      .hasSize(3)\n      .allMatch(t -> t.is(Tree.Kind.STRING_LITERAL))\n      .containsExactly((LiteralTree) a, (LiteralTree) b, (LiteralTree) c);\n  }", "signature": "void test_GetLiterals_string_concatenation()", "full_signature": "@Test void test_GetLiterals_string_concatenation()", "class_method_signature": "AbstractRegexCheckTest.test_GetLiterals_string_concatenation()", "testcase": true, "constructor": false, "invocations": ["getArg", "leftOperand", "leftOperand", "rightOperand", "rightOperand", "getLiterals", "isPresent", "assertThat", "containsExactly", "allMatch", "hasSize", "assertThat", "get", "is"]}, "focal_class": {"identifier": "AbstractRegexCheck", "superclass": "extends AbstractMethodDetection", "interfaces": "implements RegexCheck", "fields": [{"original_string": "protected static final String JAVA_LANG_STRING = \"java.lang.String\";", "modifier": "protected static final", "type": "String", "declarator": "JAVA_LANG_STRING = \"java.lang.String\"", "var_name": "JAVA_LANG_STRING"}, {"original_string": "protected static final MethodMatchers REGEX_METHODS = MethodMatchers.or(\n    MethodMatchers.create()\n      .ofTypes(JAVA_LANG_STRING)\n      .names(\"matches\")\n      .addParametersMatcher(JAVA_LANG_STRING)\n      .build(),\n    MethodMatchers.create()\n      .ofTypes(JAVA_LANG_STRING)\n      .names(\"replaceAll\", \"replaceFirst\")\n      .withAnyParameters()\n      .build(),\n    MethodMatchers.create()\n      .ofTypes(\"java.util.regex.Pattern\")\n      .names(\"compile\", \"matches\")\n      .withAnyParameters()\n      .build());", "modifier": "protected static final", "type": "MethodMatchers", "declarator": "REGEX_METHODS = MethodMatchers.or(\n    MethodMatchers.create()\n      .ofTypes(JAVA_LANG_STRING)\n      .names(\"matches\")\n      .addParametersMatcher(JAVA_LANG_STRING)\n      .build(),\n    MethodMatchers.create()\n      .ofTypes(JAVA_LANG_STRING)\n      .names(\"replaceAll\", \"replaceFirst\")\n      .withAnyParameters()\n      .build(),\n    MethodMatchers.create()\n      .ofTypes(\"java.util.regex.Pattern\")\n      .names(\"compile\", \"matches\")\n      .withAnyParameters()\n      .build())", "var_name": "REGEX_METHODS"}, {"original_string": "private RegexScannerContext regexContext;", "modifier": "private", "type": "RegexScannerContext", "declarator": "regexContext", "var_name": "regexContext"}, {"original_string": "private final HashSet<RegexSyntaxElement> reportedRegexTrees = new HashSet<>();", "modifier": "private final", "type": "HashSet<RegexSyntaxElement>", "declarator": "reportedRegexTrees = new HashSet<>()", "var_name": "reportedRegexTrees"}], "methods": [{"identifier": "setContext", "parameters": "(JavaFileScannerContext context)", "modifiers": "@Override public final", "return": "void", "signature": "void setContext(JavaFileScannerContext context)", "full_signature": "@Override public final void setContext(JavaFileScannerContext context)", "class_method_signature": "AbstractRegexCheck.setContext(JavaFileScannerContext context)", "testcase": false, "constructor": false}, {"identifier": "nodesToVisit", "parameters": "()", "modifiers": "@Override public", "return": "List<Tree.Kind>", "signature": "List<Tree.Kind> nodesToVisit()", "full_signature": "@Override public List<Tree.Kind> nodesToVisit()", "class_method_signature": "AbstractRegexCheck.nodesToVisit()", "testcase": false, "constructor": false}, {"identifier": "getMethodInvocationMatchers", "parameters": "()", "modifiers": "@Override protected", "return": "MethodMatchers", "signature": "MethodMatchers getMethodInvocationMatchers()", "full_signature": "@Override protected MethodMatchers getMethodInvocationMatchers()", "class_method_signature": "AbstractRegexCheck.getMethodInvocationMatchers()", "testcase": false, "constructor": false}, {"identifier": "onMethodInvocationFound", "parameters": "(MethodInvocationTree mit)", "modifiers": "@Override protected", "return": "void", "signature": "void onMethodInvocationFound(MethodInvocationTree mit)", "full_signature": "@Override protected void onMethodInvocationFound(MethodInvocationTree mit)", "class_method_signature": "AbstractRegexCheck.onMethodInvocationFound(MethodInvocationTree mit)", "testcase": false, "constructor": false}, {"identifier": "regexForLiterals", "parameters": "(FlagSet flags, LiteralTree... literals)", "modifiers": "protected final", "return": "RegexParseResult", "signature": "RegexParseResult regexForLiterals(FlagSet flags, LiteralTree... literals)", "full_signature": "protected final RegexParseResult regexForLiterals(FlagSet flags, LiteralTree... literals)", "class_method_signature": "AbstractRegexCheck.regexForLiterals(FlagSet flags, LiteralTree... literals)", "testcase": false, "constructor": false}, {"identifier": "getLiterals", "parameters": "(ExpressionTree expr)", "modifiers": "@VisibleForTesting protected static", "return": "Optional<LiteralTree[]>", "signature": "Optional<LiteralTree[]> getLiterals(ExpressionTree expr)", "full_signature": "@VisibleForTesting protected static Optional<LiteralTree[]> getLiterals(ExpressionTree expr)", "class_method_signature": "AbstractRegexCheck.getLiterals(ExpressionTree expr)", "testcase": false, "constructor": false}, {"identifier": "getLiteralsFromStringConcatenation", "parameters": "(BinaryExpressionTree expr)", "modifiers": "private static", "return": "Optional<LiteralTree[]>", "signature": "Optional<LiteralTree[]> getLiteralsFromStringConcatenation(BinaryExpressionTree expr)", "full_signature": "private static Optional<LiteralTree[]> getLiteralsFromStringConcatenation(BinaryExpressionTree expr)", "class_method_signature": "AbstractRegexCheck.getLiteralsFromStringConcatenation(BinaryExpressionTree expr)", "testcase": false, "constructor": false}, {"identifier": "getFinalVariableInitializer", "parameters": "(IdentifierTree identifier)", "modifiers": "protected static", "return": "Optional<ExpressionTree>", "signature": "Optional<ExpressionTree> getFinalVariableInitializer(IdentifierTree identifier)", "full_signature": "protected static Optional<ExpressionTree> getFinalVariableInitializer(IdentifierTree identifier)", "class_method_signature": "AbstractRegexCheck.getFinalVariableInitializer(IdentifierTree identifier)", "testcase": false, "constructor": false}, {"identifier": "getLiteralsFromFinalVariables", "parameters": "(IdentifierTree identifier)", "modifiers": "private static", "return": "Optional<LiteralTree[]>", "signature": "Optional<LiteralTree[]> getLiteralsFromFinalVariables(IdentifierTree identifier)", "full_signature": "private static Optional<LiteralTree[]> getLiteralsFromFinalVariables(IdentifierTree identifier)", "class_method_signature": "AbstractRegexCheck.getLiteralsFromFinalVariables(IdentifierTree identifier)", "testcase": false, "constructor": false}, {"identifier": "checkRegex", "parameters": "(RegexParseResult regexForLiterals, MethodInvocationTree mit)", "modifiers": "public abstract", "return": "void", "signature": "void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit)", "full_signature": "public abstract void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit)", "class_method_signature": "AbstractRegexCheck.checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit)", "testcase": false, "constructor": false}, {"identifier": "reportIssue", "parameters": "(RegexSyntaxElement regexTree, String message, @Nullable Integer cost, List<RegexCheck.RegexIssueLocation> secondaries)", "modifiers": "public final", "return": "void", "signature": "void reportIssue(RegexSyntaxElement regexTree, String message, @Nullable Integer cost, List<RegexCheck.RegexIssueLocation> secondaries)", "full_signature": "public final void reportIssue(RegexSyntaxElement regexTree, String message, @Nullable Integer cost, List<RegexCheck.RegexIssueLocation> secondaries)", "class_method_signature": "AbstractRegexCheck.reportIssue(RegexSyntaxElement regexTree, String message, @Nullable Integer cost, List<RegexCheck.RegexIssueLocation> secondaries)", "testcase": false, "constructor": false}, {"identifier": "reportIssue", "parameters": "(Tree javaTree, String message, @Nullable Integer cost, List<RegexCheck.RegexIssueLocation> secondaries)", "modifiers": "public final", "return": "void", "signature": "void reportIssue(Tree javaTree, String message, @Nullable Integer cost, List<RegexCheck.RegexIssueLocation> secondaries)", "full_signature": "public final void reportIssue(Tree javaTree, String message, @Nullable Integer cost, List<RegexCheck.RegexIssueLocation> secondaries)", "class_method_signature": "AbstractRegexCheck.reportIssue(Tree javaTree, String message, @Nullable Integer cost, List<RegexCheck.RegexIssueLocation> secondaries)", "testcase": false, "constructor": false}, {"identifier": "getFlagsTree", "parameters": "(MethodInvocationTree mit)", "modifiers": "protected static", "return": "Optional<ExpressionTree>", "signature": "Optional<ExpressionTree> getFlagsTree(MethodInvocationTree mit)", "full_signature": "protected static Optional<ExpressionTree> getFlagsTree(MethodInvocationTree mit)", "class_method_signature": "AbstractRegexCheck.getFlagsTree(MethodInvocationTree mit)", "testcase": false, "constructor": false}, {"identifier": "getFlags", "parameters": "(MethodInvocationTree mit)", "modifiers": "private static", "return": "FlagSet", "signature": "FlagSet getFlags(MethodInvocationTree mit)", "full_signature": "private static FlagSet getFlags(MethodInvocationTree mit)", "class_method_signature": "AbstractRegexCheck.getFlags(MethodInvocationTree mit)", "testcase": false, "constructor": false}], "file": "java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheck.java"}, "focal_method": {"identifier": "getLiterals", "parameters": "(ExpressionTree expr)", "modifiers": "@VisibleForTesting protected static", "return": "Optional<LiteralTree[]>", "body": "@VisibleForTesting\n  protected static Optional<LiteralTree[]> getLiterals(ExpressionTree expr) {\n    switch (expr.kind()) {\n      case PLUS:\n        return getLiteralsFromStringConcatenation((BinaryExpressionTree) expr);\n      case IDENTIFIER:\n        return getLiteralsFromFinalVariables((IdentifierTree) expr);\n      case PARENTHESIZED_EXPRESSION:\n        return getLiterals(ExpressionUtils.skipParentheses(expr));\n      case STRING_LITERAL:\n        return Optional.of(new LiteralTree[] {(LiteralTree) expr});\n      default:\n        return Optional.empty();\n    }\n  }", "signature": "Optional<LiteralTree[]> getLiterals(ExpressionTree expr)", "full_signature": "@VisibleForTesting protected static Optional<LiteralTree[]> getLiterals(ExpressionTree expr)", "class_method_signature": "AbstractRegexCheck.getLiterals(ExpressionTree expr)", "testcase": false, "constructor": false, "invocations": ["kind", "getLiteralsFromStringConcatenation", "getLiteralsFromFinalVariables", "getLiterals", "skipParentheses", "of", "empty"]}, "repository": {"repo_id": 5674787, "url": "https://github.com/SonarSource/sonar-java", "stars": 597, "created": "9/4/2012 3:53:13 PM +00:00", "updates": "2020-01-27T13:20:27+00:00", "fork": "False", "license": "licensed"}}