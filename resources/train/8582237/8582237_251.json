{"test_class": {"identifier": "DDLWatchRefresherTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final WritableTxn txn=new WritableTxn(0x100l,0x100l,null,Txn.IsolationLevel.SNAPSHOT_ISOLATION,Txn.ROOT_TRANSACTION,null,true,null);", "modifier": "private static final", "type": "WritableTxn", "declarator": "txn=new WritableTxn(0x100l,0x100l,null,Txn.IsolationLevel.SNAPSHOT_ISOLATION,Txn.ROOT_TRANSACTION,null,true,null)", "var_name": "txn"}, {"original_string": "private static final SqlExceptionFactory ef = new SqlExceptionFactory(){\n        @Override\n        public IOException asIOException(StandardException se){\n            return new IOException(se);\n        }\n\n        @Override public IOException writeWriteConflict(long txn1,long txn2){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException readOnlyModification(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException noSuchFamily(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException transactionTimeout(long tnxId){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException cannotCommit(long txnId,Txn.State actualState){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException cannotCommit(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException additiveWriteConflict(){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException doNotRetry(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException doNotRetry(Throwable t){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException processRemoteException(Throwable e){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException callerDisconnected(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException failedServer(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException notServingPartition(String s){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException connectionClosingException() { throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public boolean allowsRetry(Throwable error){ throw new UnsupportedOperationException(\"Should not happen\"); }\n    };", "modifier": "private static final", "type": "SqlExceptionFactory", "declarator": "ef = new SqlExceptionFactory(){\n        @Override\n        public IOException asIOException(StandardException se){\n            return new IOException(se);\n        }\n\n        @Override public IOException writeWriteConflict(long txn1,long txn2){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException readOnlyModification(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException noSuchFamily(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException transactionTimeout(long tnxId){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException cannotCommit(long txnId,Txn.State actualState){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException cannotCommit(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException additiveWriteConflict(){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException doNotRetry(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException doNotRetry(Throwable t){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException processRemoteException(Throwable e){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException callerDisconnected(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException failedServer(String message){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException notServingPartition(String s){ throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public IOException connectionClosingException() { throw new UnsupportedOperationException(\"Should not happen\"); }\n        @Override public boolean allowsRetry(Throwable error){ throw new UnsupportedOperationException(\"Should not happen\"); }\n    }", "var_name": "ef"}], "file": "splice_machine/src/test/java/com/splicemachine/derby/ddl/DDLWatchRefresherTest.java"}, "test_case": {"identifier": "testDDLTimesOut", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDDLTimesOut() throws Exception{\n        /*\n         * Test that we do the right thing when we time out on a ddl operation (e.g. when the initiator of the\n         * change then dies and leaves behind junk that we have to clean up).\n         *\n         * This timeout is initiated only after it has been initiated, but failed to be cleaned up. In distributed\n         * terms, one server received the initial request, but the initiating node failed before it could complete\n         * the operation. In this case, we timeout, but only if it is still there\n         */\n        TestChecker checker=getTestChecker();\n        TickingClock clock = new IncrementingClock(0);\n\n        TxnStore supplier = new TestingTxnStore(clock,new TestingTimestampSource(),null,100l);\n        supplier.recordNewTransaction(txn);\n        long timeoutMs=10l;\n        TestDDLWatchRefresher refresher = new TestDDLWatchRefresher(checker,null,ef,supplier);\n        refresher.setTimeout(false);\n        //add a new change\n        final DDLChange testChange  = ProtoUtil.createNoOpDDLChange(txn.getTxnId(),\"change\",DDLMessage.DDLChangeType.ADD_PRIMARY_KEY );\n        CountingListener assertionListener = new CountingListener();\n\n        //check it and run it\n        checker.addChange(testChange);\n        boolean shouldCont=refresher.refreshDDL(Collections.<DDLWatcher.DDLListener>singleton(assertionListener));\n        Assert.assertTrue(\"Returned an error State!\",shouldCont);\n        /*\n         * We haven't \"finished\" the ddl change yet, so we should expect to have seen only a start, and a global\n         * start (e.g. no global stop, and a change count of 1)\n         */\n        Assert.assertEquals(\"Incorrect initiated count!\",1,assertionListener.getCount(testChange));\n//        Assert.assertEquals(\"Incorrect global start count!\",1,assertionListener.getStartGlobalCount());\n//        Assert.assertEquals(\"Incorrect global stop count!\",0,assertionListener.getEndGlobalCount());\n\n        //move the clock forward\n        clock.tickMillis(5l);\n        /*\n         * To simulate a change within the timeout hanging around, add it back to the checker, then refresh\n         * and make sure it wasn't re-processed. Nothing should have changed\n         */\n        checker.addChange(testChange);\n        shouldCont=refresher.refreshDDL(Collections.<DDLWatcher.DDLListener>singleton(assertionListener));\n        Assert.assertTrue(\"Returned an error State!\",shouldCont);\n        /*\n         * We haven't \"finished\" the ddl change yet, so we should expect to have seen only a start, and a global\n         * start (e.g. no global stop, and a change count of 1)\n         */\n        Assert.assertEquals(\"Incorrect initiated count!\",1,assertionListener.getCount(testChange));\n//        Assert.assertEquals(\"Incorrect global start count!\",1,assertionListener.getStartGlobalCount());\n//        Assert.assertEquals(\"Incorrect global stop count!\",0,assertionListener.getEndGlobalCount());\n\n        /*\n         * Now move the clock forward past the timeout position, and refresh again, making sure that it was terminated\n         */\n        clock.tickMillis(10);\n        refresher.setTimeout(true);\n        shouldCont=refresher.refreshDDL(Collections.<DDLWatcher.DDLListener>singleton(assertionListener));\n        Assert.assertTrue(\"Returned an error State!\",shouldCont);\n        /*\n         * We haven't \"finished\" the ddl change yet, so we should expect to have seen only a start, and a global\n         * start (e.g. no global stop, and a change count of 1)\n         */\n        Assert.assertEquals(\"Incorrect initiated count!\",1,assertionListener.getCount(testChange));\n        Assert.assertTrue(\"Incorrect failed count!\",assertionListener.isFailed(testChange));\n//        Assert.assertEquals(\"Incorrect global start count!\",1,assertionListener.getStartGlobalCount());\n//        Assert.assertEquals(\"Incorrect global stop count!\",1,assertionListener.getEndGlobalCount());\n    }", "signature": "void testDDLTimesOut()", "full_signature": "@Test public void testDDLTimesOut()", "class_method_signature": "DDLWatchRefresherTest.testDDLTimesOut()", "testcase": true, "constructor": false, "invocations": ["getTestChecker", "recordNewTransaction", "setTimeout", "createNoOpDDLChange", "getTxnId", "addChange", "refreshDDL", "singleton", "assertTrue", "assertEquals", "getCount", "tickMillis", "addChange", "refreshDDL", "singleton", "assertTrue", "assertEquals", "getCount", "tickMillis", "setTimeout", "refreshDDL", "singleton", "assertTrue", "assertEquals", "getCount", "assertTrue", "isFailed"]}, "focal_class": {"identifier": "DDLWatchRefresher", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG=Logger.getLogger(DDLWatchRefresher.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG=Logger.getLogger(DDLWatchRefresher.class)", "var_name": "LOG"}, {"original_string": "private final Set<String> seenDDLChanges;", "modifier": "private final", "type": "Set<String>", "declarator": "seenDDLChanges", "var_name": "seenDDLChanges"}, {"original_string": "private final Set<String> changeTimeouts;", "modifier": "private final", "type": "Set<String>", "declarator": "changeTimeouts", "var_name": "changeTimeouts"}, {"original_string": "private final Map<String, DDLChange> currentDDLChanges;", "modifier": "private final", "type": "Map<String, DDLChange>", "declarator": "currentDDLChanges", "var_name": "currentDDLChanges"}, {"original_string": "private final Map<String, DDLChange> tentativeDDLS;", "modifier": "private final", "type": "Map<String, DDLChange>", "declarator": "tentativeDDLS", "var_name": "tentativeDDLS"}, {"original_string": "private final AtomicReference<DDLFilter> ddlDemarcationPoint;", "modifier": "private final", "type": "AtomicReference<DDLFilter>", "declarator": "ddlDemarcationPoint", "var_name": "ddlDemarcationPoint"}, {"original_string": "private final DDLWatchChecker watchChecker;", "modifier": "private final", "type": "DDLWatchChecker", "declarator": "watchChecker", "var_name": "watchChecker"}, {"original_string": "private final TransactionReadController txController;", "modifier": "private final", "type": "TransactionReadController", "declarator": "txController", "var_name": "txController"}, {"original_string": "private final AtomicInteger currChangeCount= new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "currChangeCount= new AtomicInteger(0)", "var_name": "currChangeCount"}, {"original_string": "private final SqlExceptionFactory exceptionFactory;", "modifier": "private final", "type": "SqlExceptionFactory", "declarator": "exceptionFactory", "var_name": "exceptionFactory"}, {"original_string": "private final TxnSupplier txnSupplier;", "modifier": "private final", "type": "TxnSupplier", "declarator": "txnSupplier", "var_name": "txnSupplier"}], "methods": [{"identifier": "DDLWatchRefresher", "parameters": "(DDLWatchChecker watchChecker,\n                             TransactionReadController txnController,\n                             SqlExceptionFactory exceptionFactory,\n                             TxnSupplier txnSupplier)", "modifiers": "public", "return": "", "signature": " DDLWatchRefresher(DDLWatchChecker watchChecker,\n                             TransactionReadController txnController,\n                             SqlExceptionFactory exceptionFactory,\n                             TxnSupplier txnSupplier)", "full_signature": "public  DDLWatchRefresher(DDLWatchChecker watchChecker,\n                             TransactionReadController txnController,\n                             SqlExceptionFactory exceptionFactory,\n                             TxnSupplier txnSupplier)", "class_method_signature": "DDLWatchRefresher.DDLWatchRefresher(DDLWatchChecker watchChecker,\n                             TransactionReadController txnController,\n                             SqlExceptionFactory exceptionFactory,\n                             TxnSupplier txnSupplier)", "testcase": false, "constructor": true}, {"identifier": "tentativeDDLChanges", "parameters": "()", "modifiers": "public", "return": "Collection<DDLChange>", "signature": "Collection<DDLChange> tentativeDDLChanges()", "full_signature": "public Collection<DDLChange> tentativeDDLChanges()", "class_method_signature": "DDLWatchRefresher.tentativeDDLChanges()", "testcase": false, "constructor": false}, {"identifier": "numCurrentDDLChanges", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int numCurrentDDLChanges()", "full_signature": "public int numCurrentDDLChanges()", "class_method_signature": "DDLWatchRefresher.numCurrentDDLChanges()", "testcase": false, "constructor": false}, {"identifier": "refreshDDL", "parameters": "(Set<DDLWatcher.DDLListener> callbacks)", "modifiers": "public", "return": "boolean", "signature": "boolean refreshDDL(Set<DDLWatcher.DDLListener> callbacks)", "full_signature": "public boolean refreshDDL(Set<DDLWatcher.DDLListener> callbacks)", "class_method_signature": "DDLWatchRefresher.refreshDDL(Set<DDLWatcher.DDLListener> callbacks)", "testcase": false, "constructor": false}, {"identifier": "canUseSPSCache", "parameters": "(TransactionManager txnMgr)", "modifiers": "public", "return": "boolean", "signature": "boolean canUseSPSCache(TransactionManager txnMgr)", "full_signature": "public boolean canUseSPSCache(TransactionManager txnMgr)", "class_method_signature": "DDLWatchRefresher.canUseSPSCache(TransactionManager txnMgr)", "testcase": false, "constructor": false}, {"identifier": "canWriteCache", "parameters": "(TransactionManager xact_mgr)", "modifiers": "public", "return": "boolean", "signature": "boolean canWriteCache(TransactionManager xact_mgr)", "full_signature": "public boolean canWriteCache(TransactionManager xact_mgr)", "class_method_signature": "DDLWatchRefresher.canWriteCache(TransactionManager xact_mgr)", "testcase": false, "constructor": false}, {"identifier": "canReadCache", "parameters": "(TransactionManager xact_mgr)", "modifiers": "public", "return": "boolean", "signature": "boolean canReadCache(TransactionManager xact_mgr)", "full_signature": "public boolean canReadCache(TransactionManager xact_mgr)", "class_method_signature": "DDLWatchRefresher.canReadCache(TransactionManager xact_mgr)", "testcase": false, "constructor": false}, {"identifier": "processPreCommitChange", "parameters": "(DDLChange ddlChange,\n                                        Collection<DDLWatcher.DDLListener> ddlListeners)", "modifiers": "private", "return": "void", "signature": "void processPreCommitChange(DDLChange ddlChange,\n                                        Collection<DDLWatcher.DDLListener> ddlListeners)", "full_signature": "private void processPreCommitChange(DDLChange ddlChange,\n                                        Collection<DDLWatcher.DDLListener> ddlListeners)", "class_method_signature": "DDLWatchRefresher.processPreCommitChange(DDLChange ddlChange,\n                                        Collection<DDLWatcher.DDLListener> ddlListeners)", "testcase": false, "constructor": false}, {"identifier": "clearFinishedChanges", "parameters": "(Collection<String> children,Collection<DDLWatcher.DDLListener> ddlListeners)", "modifiers": "private", "return": "void", "signature": "void clearFinishedChanges(Collection<String> children,Collection<DDLWatcher.DDLListener> ddlListeners)", "full_signature": "private void clearFinishedChanges(Collection<String> children,Collection<DDLWatcher.DDLListener> ddlListeners)", "class_method_signature": "DDLWatchRefresher.clearFinishedChanges(Collection<String> children,Collection<DDLWatcher.DDLListener> ddlListeners)", "testcase": false, "constructor": false}, {"identifier": "assignDDLDemarcationPoint", "parameters": "(DDLChange ddlChange)", "modifiers": "private", "return": "void", "signature": "void assignDDLDemarcationPoint(DDLChange ddlChange)", "full_signature": "private void assignDDLDemarcationPoint(DDLChange ddlChange)", "class_method_signature": "DDLWatchRefresher.assignDDLDemarcationPoint(DDLChange ddlChange)", "testcase": false, "constructor": false}, {"identifier": "killTimeouts", "parameters": "(Set<DDLWatcher.DDLListener> listeners)", "modifiers": "private", "return": "int", "signature": "int killTimeouts(Set<DDLWatcher.DDLListener> listeners)", "full_signature": "private int killTimeouts(Set<DDLWatcher.DDLListener> listeners)", "class_method_signature": "DDLWatchRefresher.killTimeouts(Set<DDLWatcher.DDLListener> listeners)", "testcase": false, "constructor": false}, {"identifier": "isTimeout", "parameters": "(DDLChange ddlChange)", "modifiers": "protected", "return": "boolean", "signature": "boolean isTimeout(DDLChange ddlChange)", "full_signature": "protected boolean isTimeout(DDLChange ddlChange)", "class_method_signature": "DDLWatchRefresher.isTimeout(DDLChange ddlChange)", "testcase": false, "constructor": false}, {"identifier": "cacheIsValid", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean cacheIsValid()", "full_signature": "public boolean cacheIsValid()", "class_method_signature": "DDLWatchRefresher.cacheIsValid()", "testcase": false, "constructor": false}, {"identifier": "canSeeDDLDemarcationPoint", "parameters": "(TransactionManager xact_mgr)", "modifiers": "private", "return": "boolean", "signature": "boolean canSeeDDLDemarcationPoint(TransactionManager xact_mgr)", "full_signature": "private boolean canSeeDDLDemarcationPoint(TransactionManager xact_mgr)", "class_method_signature": "DDLWatchRefresher.canSeeDDLDemarcationPoint(TransactionManager xact_mgr)", "testcase": false, "constructor": false}], "file": "splice_machine/src/main/java/com/splicemachine/derby/ddl/DDLWatchRefresher.java"}, "focal_method": {"identifier": "refreshDDL", "parameters": "(Set<DDLWatcher.DDLListener> callbacks)", "modifiers": "public", "return": "boolean", "body": "public boolean refreshDDL(Set<DDLWatcher.DDLListener> callbacks) throws IOException{\n        Collection<String> ongoingDDLChangeIds=watchChecker.getCurrentChangeIds();\n        if(ongoingDDLChangeIds==null) return false;\n\n        Set<Pair<DDLChange,String>> newChanges=new HashSet<>();\n        boolean currentWasEmpty=currentDDLChanges.isEmpty();\n\n        try{\n            clearFinishedChanges(ongoingDDLChangeIds,callbacks);\n        }catch(StandardException se){\n            throw exceptionFactory.asIOException(se);\n        }\n\n        for(String changeId : ongoingDDLChangeIds){\n            if(!seenDDLChanges.contains(changeId)){\n                DDLChange change=watchChecker.getChange(changeId);\n                if(change==null)continue; //another thread took care of this for us\n\n                //inform the server of the first time we see this change\n                String cId=change.getChangeId();\n                changeTimeouts.add(cId);\n                SpliceLogUtils.info(LOG,\"New change with id=%s, and change=%s\",changeId,change);\n                try {\n                    processPreCommitChange(change, callbacks);\n                    seenDDLChanges.add(changeId);\n                    newChanges.add(new Pair<DDLChange, String>(change,null));\n                } catch (Exception e) {\n                    LOG.error(\"Encountered an exception processing DDL change\",e);\n                    newChanges.add(new Pair<>(change,e.getLocalizedMessage()));\n                }\n            }\n        }\n\n        watchChecker.notifyProcessed(newChanges);\n        int killed = killTimeouts(callbacks);\n        //\n        // CASE 1: currentDDLChanges was empty and we added changes.\n        //  OR\n        // CASE 2: currentDDLChanges was NOT empty and we removed everything.\n        //\n        if(currentWasEmpty!=currentDDLChanges.isEmpty()){\n            boolean case1=!currentDDLChanges.isEmpty();\n            for(DDLWatcher.DDLListener listener : callbacks){\n                if(case1){\n                    listener.startGlobalChange();\n                }else\n                    listener.finishGlobalChange();\n            }\n        }else if(killed>0){\n            /*\n             * DB-3816. We need to re-enable caches if we killed some DDL\n             * operations, because otherwise we may leak memory\n             */\n            for(DDLWatcher.DDLListener listener : callbacks){\n                listener.finishGlobalChange();\n            }\n        }\n\n        return true;\n    }", "signature": "boolean refreshDDL(Set<DDLWatcher.DDLListener> callbacks)", "full_signature": "public boolean refreshDDL(Set<DDLWatcher.DDLListener> callbacks)", "class_method_signature": "DDLWatchRefresher.refreshDDL(Set<DDLWatcher.DDLListener> callbacks)", "testcase": false, "constructor": false, "invocations": ["getCurrentChangeIds", "isEmpty", "clearFinishedChanges", "asIOException", "contains", "getChange", "getChangeId", "add", "info", "processPreCommitChange", "add", "add", "error", "add", "getLocalizedMessage", "notifyProcessed", "killTimeouts", "isEmpty", "isEmpty", "startGlobalChange", "finishGlobalChange", "finishGlobalChange"]}, "repository": {"repo_id": 8582237, "url": "https://github.com/splicemachine/spliceengine", "stars": 128, "created": "3/5/2013 3:07:56 PM +00:00", "updates": "2020-01-23T21:06:43+00:00", "fork": "False", "license": "licensed"}}