{"test_class": {"identifier": "SpliceDateFunctionsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final DateFormat DF = new SimpleDateFormat(\"yyyy/MM/dd\");", "modifier": "private static final", "type": "DateFormat", "declarator": "DF = new SimpleDateFormat(\"yyyy/MM/dd\")", "var_name": "DF"}, {"original_string": "private static final DateFormat DFT = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");", "modifier": "private static final", "type": "DateFormat", "declarator": "DFT = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\")", "var_name": "DFT"}, {"original_string": "@Rule\n    public ExpectedException expectedException = ExpectedException.none();", "modifier": "@Rule\n    public", "type": "ExpectedException", "declarator": "expectedException = ExpectedException.none()", "var_name": "expectedException"}], "file": "splice_machine/src/test/java/com/splicemachine/derby/utils/SpliceDateFunctionsTest.java"}, "test_case": {"identifier": "nextDay", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void nextDay() throws ParseException, SQLException {\n        Date date1 = new Date(DF.parse(\"2014/06/24\").getTime());\n        Date date2 = new Date(DF.parse(\"2014/06/29\").getTime());\n        Date date3 = new Date(DF.parse(\"2014/06/25\").getTime());\n        Date date4 = new Date(DF.parse(\"2014/06/27\").getTime());\n        Date date5 = new Date(DF.parse(\"2014/05/12\").getTime());\n        Date date6 = new Date(DF.parse(\"2014/05/17\").getTime());\n        assertEquals(date3, SpliceDateFunctions.NEXT_DAY(date1, \"wednesday\"));\n        assertEquals(date2, SpliceDateFunctions.NEXT_DAY(date1, \"sunday\"));\n        assertEquals(date4, SpliceDateFunctions.NEXT_DAY(date1, \"friday\"));\n        assertEquals(date6, SpliceDateFunctions.NEXT_DAY(date5, \"saturday\"));\n    }", "signature": "void nextDay()", "full_signature": "@Test public void nextDay()", "class_method_signature": "SpliceDateFunctionsTest.nextDay()", "testcase": true, "constructor": false, "invocations": ["getTime", "parse", "getTime", "parse", "getTime", "parse", "getTime", "parse", "getTime", "parse", "getTime", "parse", "assertEquals", "NEXT_DAY", "assertEquals", "NEXT_DAY", "assertEquals", "NEXT_DAY", "assertEquals", "NEXT_DAY"]}, "focal_class": {"identifier": "SpliceDateFunctions", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Map<String, Integer> WEEK_DAY_MAP = new ImmutableMap.Builder<String, Integer>()\n            .put(\"sunday\", 1).put(\"monday\", 2).put(\"tuesday\", 3).put(\"wednesday\", 4).put(\"thursday\", 5)\n            .put(\"friday\", 6).put(\"saturday\", 7).build();", "modifier": "private static final", "type": "Map<String, Integer>", "declarator": "WEEK_DAY_MAP = new ImmutableMap.Builder<String, Integer>()\n            .put(\"sunday\", 1).put(\"monday\", 2).put(\"tuesday\", 3).put(\"wednesday\", 4).put(\"thursday\", 5)\n            .put(\"friday\", 6).put(\"saturday\", 7).build()", "var_name": "WEEK_DAY_MAP"}], "methods": [{"identifier": "ADD_MONTHS", "parameters": "(Date source, Integer numOfMonths)", "modifiers": "public static", "return": "Date", "signature": "Date ADD_MONTHS(Date source, Integer numOfMonths)", "full_signature": "public static Date ADD_MONTHS(Date source, Integer numOfMonths)", "class_method_signature": "SpliceDateFunctions.ADD_MONTHS(Date source, Integer numOfMonths)", "testcase": false, "constructor": false}, {"identifier": "ADD_DAYS", "parameters": "(Date source, Integer numOfDays)", "modifiers": "public static", "return": "Date", "signature": "Date ADD_DAYS(Date source, Integer numOfDays)", "full_signature": "public static Date ADD_DAYS(Date source, Integer numOfDays)", "class_method_signature": "SpliceDateFunctions.ADD_DAYS(Date source, Integer numOfDays)", "testcase": false, "constructor": false}, {"identifier": "ADD_YEARS", "parameters": "(Date source, Integer numOfYears)", "modifiers": "public static", "return": "Date", "signature": "Date ADD_YEARS(Date source, Integer numOfYears)", "full_signature": "public static Date ADD_YEARS(Date source, Integer numOfYears)", "class_method_signature": "SpliceDateFunctions.ADD_YEARS(Date source, Integer numOfYears)", "testcase": false, "constructor": false}, {"identifier": "TO_TIMESTAMP", "parameters": "(String source)", "modifiers": "public static", "return": "Timestamp", "signature": "Timestamp TO_TIMESTAMP(String source)", "full_signature": "public static Timestamp TO_TIMESTAMP(String source)", "class_method_signature": "SpliceDateFunctions.TO_TIMESTAMP(String source)", "testcase": false, "constructor": false}, {"identifier": "TO_TIMESTAMP", "parameters": "(String source, String format, SpliceDateTimeFormatter formatter)", "modifiers": "public static", "return": "Timestamp", "signature": "Timestamp TO_TIMESTAMP(String source, String format, SpliceDateTimeFormatter formatter)", "full_signature": "public static Timestamp TO_TIMESTAMP(String source, String format, SpliceDateTimeFormatter formatter)", "class_method_signature": "SpliceDateFunctions.TO_TIMESTAMP(String source, String format, SpliceDateTimeFormatter formatter)", "testcase": false, "constructor": false}, {"identifier": "TO_TIMESTAMP", "parameters": "(String source, String format)", "modifiers": "public static", "return": "Timestamp", "signature": "Timestamp TO_TIMESTAMP(String source, String format)", "full_signature": "public static Timestamp TO_TIMESTAMP(String source, String format)", "class_method_signature": "SpliceDateFunctions.TO_TIMESTAMP(String source, String format)", "testcase": false, "constructor": false}, {"identifier": "TO_TIMESTAMP", "parameters": "(String source, String format, ZoneId zoneId)", "modifiers": "public static", "return": "Timestamp", "signature": "Timestamp TO_TIMESTAMP(String source, String format, ZoneId zoneId)", "full_signature": "public static Timestamp TO_TIMESTAMP(String source, String format, ZoneId zoneId)", "class_method_signature": "SpliceDateFunctions.TO_TIMESTAMP(String source, String format, ZoneId zoneId)", "testcase": false, "constructor": false}, {"identifier": "TO_TIME", "parameters": "(String source)", "modifiers": "public static", "return": "Time", "signature": "Time TO_TIME(String source)", "full_signature": "public static Time TO_TIME(String source)", "class_method_signature": "SpliceDateFunctions.TO_TIME(String source)", "testcase": false, "constructor": false}, {"identifier": "TO_TIME", "parameters": "(String source, String format)", "modifiers": "public static", "return": "Time", "signature": "Time TO_TIME(String source, String format)", "full_signature": "public static Time TO_TIME(String source, String format)", "class_method_signature": "SpliceDateFunctions.TO_TIME(String source, String format)", "testcase": false, "constructor": false}, {"identifier": "TO_TIME", "parameters": "(String source, String format, ZoneId zoneId)", "modifiers": "public static", "return": "Time", "signature": "Time TO_TIME(String source, String format, ZoneId zoneId)", "full_signature": "public static Time TO_TIME(String source, String format, ZoneId zoneId)", "class_method_signature": "SpliceDateFunctions.TO_TIME(String source, String format, ZoneId zoneId)", "testcase": false, "constructor": false}, {"identifier": "TO_TIME", "parameters": "(String source, String format, SpliceDateTimeFormatter formatter)", "modifiers": "public static", "return": "Time", "signature": "Time TO_TIME(String source, String format, SpliceDateTimeFormatter formatter)", "full_signature": "public static Time TO_TIME(String source, String format, SpliceDateTimeFormatter formatter)", "class_method_signature": "SpliceDateFunctions.TO_TIME(String source, String format, SpliceDateTimeFormatter formatter)", "testcase": false, "constructor": false}, {"identifier": "TO_DATE", "parameters": "(String source)", "modifiers": "public static", "return": "Date", "signature": "Date TO_DATE(String source)", "full_signature": "public static Date TO_DATE(String source)", "class_method_signature": "SpliceDateFunctions.TO_DATE(String source)", "testcase": false, "constructor": false}, {"identifier": "TO_DATE", "parameters": "(String source, String format)", "modifiers": "public static", "return": "Date", "signature": "Date TO_DATE(String source, String format)", "full_signature": "public static Date TO_DATE(String source, String format)", "class_method_signature": "SpliceDateFunctions.TO_DATE(String source, String format)", "testcase": false, "constructor": false}, {"identifier": "TO_DATE", "parameters": "(String source, String format, ZoneId zoneId)", "modifiers": "public static", "return": "Date", "signature": "Date TO_DATE(String source, String format, ZoneId zoneId)", "full_signature": "public static Date TO_DATE(String source, String format, ZoneId zoneId)", "class_method_signature": "SpliceDateFunctions.TO_DATE(String source, String format, ZoneId zoneId)", "testcase": false, "constructor": false}, {"identifier": "TO_DATE", "parameters": "(String source, String format, SpliceDateTimeFormatter formatter)", "modifiers": "public static", "return": "Date", "signature": "Date TO_DATE(String source, String format, SpliceDateTimeFormatter formatter)", "full_signature": "public static Date TO_DATE(String source, String format, SpliceDateTimeFormatter formatter)", "class_method_signature": "SpliceDateFunctions.TO_DATE(String source, String format, SpliceDateTimeFormatter formatter)", "testcase": false, "constructor": false}, {"identifier": "stringWithFormatToDate", "parameters": "(String source, SpliceDateTimeFormatter formatter)", "modifiers": "public static", "return": "Date", "signature": "Date stringWithFormatToDate(String source, SpliceDateTimeFormatter formatter)", "full_signature": "public static Date stringWithFormatToDate(String source, SpliceDateTimeFormatter formatter)", "class_method_signature": "SpliceDateFunctions.stringWithFormatToDate(String source, SpliceDateTimeFormatter formatter)", "testcase": false, "constructor": false}, {"identifier": "stringWithFormatToLocalDateTime", "parameters": "(String source,\n                                    SpliceDateTimeFormatter formatter)", "modifiers": "private static", "return": "LocalDateTime", "signature": "LocalDateTime stringWithFormatToLocalDateTime(String source,\n                                    SpliceDateTimeFormatter formatter)", "full_signature": "private static LocalDateTime stringWithFormatToLocalDateTime(String source,\n                                    SpliceDateTimeFormatter formatter)", "class_method_signature": "SpliceDateFunctions.stringWithFormatToLocalDateTime(String source,\n                                    SpliceDateTimeFormatter formatter)", "testcase": false, "constructor": false}, {"identifier": "stringWithFormatToLocalTime", "parameters": "(String source,\n                                SpliceDateTimeFormatter formatter)", "modifiers": "private static", "return": "LocalTime", "signature": "LocalTime stringWithFormatToLocalTime(String source,\n                                SpliceDateTimeFormatter formatter)", "full_signature": "private static LocalTime stringWithFormatToLocalTime(String source,\n                                SpliceDateTimeFormatter formatter)", "class_method_signature": "SpliceDateFunctions.stringWithFormatToLocalTime(String source,\n                                SpliceDateTimeFormatter formatter)", "testcase": false, "constructor": false}, {"identifier": "LAST_DAY", "parameters": "(Date source)", "modifiers": "public static", "return": "Date", "signature": "Date LAST_DAY(Date source)", "full_signature": "public static Date LAST_DAY(Date source)", "class_method_signature": "SpliceDateFunctions.LAST_DAY(Date source)", "testcase": false, "constructor": false}, {"identifier": "NEXT_DAY", "parameters": "(Date source, String weekday)", "modifiers": "public static", "return": "Date", "signature": "Date NEXT_DAY(Date source, String weekday)", "full_signature": "public static Date NEXT_DAY(Date source, String weekday)", "class_method_signature": "SpliceDateFunctions.NEXT_DAY(Date source, String weekday)", "testcase": false, "constructor": false}, {"identifier": "MONTH_BETWEEN", "parameters": "(Date source1, Date source2)", "modifiers": "public static", "return": "double", "signature": "double MONTH_BETWEEN(Date source1, Date source2)", "full_signature": "public static double MONTH_BETWEEN(Date source1, Date source2)", "class_method_signature": "SpliceDateFunctions.MONTH_BETWEEN(Date source1, Date source2)", "testcase": false, "constructor": false}, {"identifier": "TO_CHAR", "parameters": "(Date source, String format)", "modifiers": "public static", "return": "String", "signature": "String TO_CHAR(Date source, String format)", "full_signature": "public static String TO_CHAR(Date source, String format)", "class_method_signature": "SpliceDateFunctions.TO_CHAR(Date source, String format)", "testcase": false, "constructor": false}, {"identifier": "TIMESTAMP_TO_CHAR", "parameters": "(Timestamp stamp, String output)", "modifiers": "public static", "return": "String", "signature": "String TIMESTAMP_TO_CHAR(Timestamp stamp, String output)", "full_signature": "public static String TIMESTAMP_TO_CHAR(Timestamp stamp, String output)", "class_method_signature": "SpliceDateFunctions.TIMESTAMP_TO_CHAR(Timestamp stamp, String output)", "testcase": false, "constructor": false}, {"identifier": "TRUNC_DATE", "parameters": "(Timestamp source, String field)", "modifiers": "public static", "return": "Timestamp", "signature": "Timestamp TRUNC_DATE(Timestamp source, String field)", "full_signature": "public static Timestamp TRUNC_DATE(Timestamp source, String field)", "class_method_signature": "SpliceDateFunctions.TRUNC_DATE(Timestamp source, String field)", "testcase": false, "constructor": false}, {"identifier": "getNanoseconds", "parameters": "(String source)", "modifiers": "private static", "return": "int", "signature": "int getNanoseconds(String source)", "full_signature": "private static int getNanoseconds(String source)", "class_method_signature": "SpliceDateFunctions.getNanoseconds(String source)", "testcase": false, "constructor": false}], "file": "splice_machine/src/main/java/com/splicemachine/derby/utils/SpliceDateFunctions.java"}, "focal_method": {"identifier": "NEXT_DAY", "parameters": "(Date source, String weekday)", "modifiers": "public static", "return": "Date", "body": "public static Date NEXT_DAY(Date source, String weekday) throws SQLException {\n        if (source == null || weekday == null) return source;\n        String lowerWeekday = weekday.toLowerCase();\n        if (!WEEK_DAY_MAP.containsKey(lowerWeekday)) {\n            throw PublicAPI.wrapStandardException(ErrorState.LANG_INVALID_DAY.newException(weekday));\n        }\n        DateTime dt = new DateTime(source);\n        int increment = WEEK_DAY_MAP.get(lowerWeekday) - dt.getDayOfWeek() - 1;\n        if (increment > 0) {\n            return new Date(dt.plusDays(increment).getMillis());\n        } else {\n            return new Date(dt.plusDays(7 + increment).getMillis());\n        }\n    }", "signature": "Date NEXT_DAY(Date source, String weekday)", "full_signature": "public static Date NEXT_DAY(Date source, String weekday)", "class_method_signature": "SpliceDateFunctions.NEXT_DAY(Date source, String weekday)", "testcase": false, "constructor": false, "invocations": ["toLowerCase", "containsKey", "wrapStandardException", "newException", "get", "getDayOfWeek", "getMillis", "plusDays", "getMillis", "plusDays"]}, "repository": {"repo_id": 8582237, "url": "https://github.com/splicemachine/spliceengine", "stars": 128, "created": "3/5/2013 3:07:56 PM +00:00", "updates": "2020-01-23T21:06:43+00:00", "fork": "False", "license": "licensed"}}