{"test_class": {"identifier": "TestRuleEvaluator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private RuleEvaluator ruleEvaluator;", "modifier": "private", "type": "RuleEvaluator", "declarator": "ruleEvaluator", "var_name": "ruleEvaluator"}], "file": "proctor-common/src/test/java/com/indeed/proctor/common/TestRuleEvaluator.java"}, "test_case": {"identifier": "testNullReferenceRule", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testNullReferenceRule() {\n        assertFalse(\"null rule should be false\", ruleEvaluator.evaluateBooleanRule(\"${null}\", emptyMap()));\n    }", "signature": "void testNullReferenceRule()", "full_signature": "@Test public void testNullReferenceRule()", "class_method_signature": "TestRuleEvaluator.testNullReferenceRule()", "testcase": true, "constructor": false, "invocations": ["assertFalse", "evaluateBooleanRule", "emptyMap"]}, "focal_class": {"identifier": "RuleEvaluator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = Logger.getLogger(RuleEvaluator.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = Logger.getLogger(RuleEvaluator.class)", "var_name": "LOGGER"}, {"original_string": "static final FunctionMapper FUNCTION_MAPPER = defaultFunctionMapperBuilder().build();", "modifier": "static final", "type": "FunctionMapper", "declarator": "FUNCTION_MAPPER = defaultFunctionMapperBuilder().build()", "var_name": "FUNCTION_MAPPER"}, {"original_string": "static final ExpressionFactory EXPRESSION_FACTORY = new ExpressionFactoryImpl();", "modifier": "static final", "type": "ExpressionFactory", "declarator": "EXPRESSION_FACTORY = new ExpressionFactoryImpl()", "var_name": "EXPRESSION_FACTORY"}, {"original_string": "@Nonnull\n    final ExpressionFactory expressionFactory;", "modifier": "@Nonnull\n    final", "type": "ExpressionFactory", "declarator": "expressionFactory", "var_name": "expressionFactory"}, {"original_string": "@Nonnull\n    final CompositeELResolver elResolver;", "modifier": "@Nonnull\n    final", "type": "CompositeELResolver", "declarator": "elResolver", "var_name": "elResolver"}, {"original_string": "@Nonnull\n    private final Map<String, ValueExpression> testConstants;", "modifier": "@Nonnull\n    private final", "type": "Map<String, ValueExpression>", "declarator": "testConstants", "var_name": "testConstants"}, {"original_string": "@Nonnull\n    private final FunctionMapper functionMapper;", "modifier": "@Nonnull\n    private final", "type": "FunctionMapper", "declarator": "functionMapper", "var_name": "functionMapper"}], "methods": [{"identifier": "RuleEvaluator", "parameters": "(\n            @Nonnull final ExpressionFactory expressionFactory,\n            @Nonnull final FunctionMapper functionMapper,\n            @Nonnull final Map<String, Object> testConstantsMap\n    )", "modifiers": "", "return": "", "signature": " RuleEvaluator(\n            @Nonnull final ExpressionFactory expressionFactory,\n            @Nonnull final FunctionMapper functionMapper,\n            @Nonnull final Map<String, Object> testConstantsMap\n    )", "full_signature": "  RuleEvaluator(\n            @Nonnull final ExpressionFactory expressionFactory,\n            @Nonnull final FunctionMapper functionMapper,\n            @Nonnull final Map<String, Object> testConstantsMap\n    )", "class_method_signature": "RuleEvaluator.RuleEvaluator(\n            @Nonnull final ExpressionFactory expressionFactory,\n            @Nonnull final FunctionMapper functionMapper,\n            @Nonnull final Map<String, Object> testConstantsMap\n    )", "testcase": false, "constructor": true}, {"identifier": "createDefaultRuleEvaluator", "parameters": "(final Map<String, Object> testConstantsMap)", "modifiers": "public static", "return": "RuleEvaluator", "signature": "RuleEvaluator createDefaultRuleEvaluator(final Map<String, Object> testConstantsMap)", "full_signature": "public static RuleEvaluator createDefaultRuleEvaluator(final Map<String, Object> testConstantsMap)", "class_method_signature": "RuleEvaluator.createDefaultRuleEvaluator(final Map<String, Object> testConstantsMap)", "testcase": false, "constructor": false}, {"identifier": "constructStandardElResolver", "parameters": "()", "modifiers": "@Nonnull private static", "return": "CompositeELResolver", "signature": "CompositeELResolver constructStandardElResolver()", "full_signature": "@Nonnull private static CompositeELResolver constructStandardElResolver()", "class_method_signature": "RuleEvaluator.constructStandardElResolver()", "testcase": false, "constructor": false}, {"identifier": "defaultFunctionMapperBuilder", "parameters": "()", "modifiers": "public static", "return": "LibraryFunctionMapperBuilder", "signature": "LibraryFunctionMapperBuilder defaultFunctionMapperBuilder()", "full_signature": "public static LibraryFunctionMapperBuilder defaultFunctionMapperBuilder()", "class_method_signature": "RuleEvaluator.defaultFunctionMapperBuilder()", "testcase": false, "constructor": false}, {"identifier": "createElContext", "parameters": "(@Nonnull final Map<String, Object> values)", "modifiers": "@Nonnull", "return": "ELContext", "signature": "ELContext createElContext(@Nonnull final Map<String, Object> values)", "full_signature": "@Nonnull ELContext createElContext(@Nonnull final Map<String, Object> values)", "class_method_signature": "RuleEvaluator.createElContext(@Nonnull final Map<String, Object> values)", "testcase": false, "constructor": false}, {"identifier": "createELContext", "parameters": "(@Nonnull final VariableMapper variableMapper)", "modifiers": "@Nonnull", "return": "ELContext", "signature": "ELContext createELContext(@Nonnull final VariableMapper variableMapper)", "full_signature": "@Nonnull ELContext createELContext(@Nonnull final VariableMapper variableMapper)", "class_method_signature": "RuleEvaluator.createELContext(@Nonnull final VariableMapper variableMapper)", "testcase": false, "constructor": false}, {"identifier": "evaluateBooleanRule", "parameters": "(final String rule, @Nonnull final Map<String, Object> values)", "modifiers": "public", "return": "boolean", "signature": "boolean evaluateBooleanRule(final String rule, @Nonnull final Map<String, Object> values)", "full_signature": "public boolean evaluateBooleanRule(final String rule, @Nonnull final Map<String, Object> values)", "class_method_signature": "RuleEvaluator.evaluateBooleanRule(final String rule, @Nonnull final Map<String, Object> values)", "testcase": false, "constructor": false}, {"identifier": "checkRuleIsBooleanType", "parameters": "(final String rule, final ELContext elContext, final ValueExpression ve)", "modifiers": "static", "return": "void", "signature": "void checkRuleIsBooleanType(final String rule, final ELContext elContext, final ValueExpression ve)", "full_signature": "static void checkRuleIsBooleanType(final String rule, final ELContext elContext, final ValueExpression ve)", "class_method_signature": "RuleEvaluator.checkRuleIsBooleanType(final String rule, final ELContext elContext, final ValueExpression ve)", "testcase": false, "constructor": false}, {"identifier": "evaluateRule", "parameters": "(final String rule, final Map<String, Object> values, final Class expectedType)", "modifiers": "@CheckForNull @Deprecated public", "return": "Object", "signature": "Object evaluateRule(final String rule, final Map<String, Object> values, final Class expectedType)", "full_signature": "@CheckForNull @Deprecated public Object evaluateRule(final String rule, final Map<String, Object> values, final Class expectedType)", "class_method_signature": "RuleEvaluator.evaluateRule(final String rule, final Map<String, Object> values, final Class expectedType)", "testcase": false, "constructor": false}], "file": "proctor-common/src/main/java/com/indeed/proctor/common/RuleEvaluator.java"}, "focal_method": {"identifier": "evaluateBooleanRule", "parameters": "(final String rule, @Nonnull final Map<String, Object> values)", "modifiers": "public", "return": "boolean", "body": "public boolean evaluateBooleanRule(final String rule, @Nonnull final Map<String, Object> values) throws IllegalArgumentException {\n        if (StringUtils.isBlank(rule)) {\n            return true;\n        }\n        if (!rule.startsWith(\"${\") || !rule.endsWith(\"}\")) {\n            LOGGER.error(\"Invalid rule '\" +  rule + \"'\");   //  TODO: should this be an exception?\n            return false;\n        }\n        final String bareRule = ProctorUtils.removeElExpressionBraces(rule);\n        if (StringUtils.isBlank(bareRule) || \"true\".equalsIgnoreCase(bareRule)) {\n            return true;    //  always passes\n        }\n        if (\"false\".equalsIgnoreCase(bareRule)) {\n            return false;\n        }\n\n        final ELContext elContext = createElContext(values);\n        final ValueExpression ve = expressionFactory.createValueExpression(elContext, rule, boolean.class);\n        checkRuleIsBooleanType(rule, elContext, ve);\n\n        final Object result = ve.getValue(elContext);\n\n        if (result instanceof Boolean) {\n            return ((Boolean) result);\n        }\n        // this should never happen, evaluateRule throws ELException when it cannot coerce to Boolean\n        throw new IllegalArgumentException(\"Received non-boolean return value: \"\n                + (result == null ? \"null\" : result.getClass().getCanonicalName())\n                + \" from rule \" + rule);\n    }", "signature": "boolean evaluateBooleanRule(final String rule, @Nonnull final Map<String, Object> values)", "full_signature": "public boolean evaluateBooleanRule(final String rule, @Nonnull final Map<String, Object> values)", "class_method_signature": "RuleEvaluator.evaluateBooleanRule(final String rule, @Nonnull final Map<String, Object> values)", "testcase": false, "constructor": false, "invocations": ["isBlank", "startsWith", "endsWith", "error", "removeElExpressionBraces", "isBlank", "equalsIgnoreCase", "equalsIgnoreCase", "createElContext", "createValueExpression", "checkRuleIsBooleanType", "getValue", "getCanonicalName", "getClass"]}, "repository": {"repo_id": 13075200, "url": "https://github.com/indeedeng/proctor", "language": "Java", "is_fork": false, "fork_count": 88, "stargazer_count": 347, "size": 4699, "license": "licensed"}}