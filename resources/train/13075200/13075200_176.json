{"test_class": {"identifier": "LegacyTaglibFunctionsTest", "superclass": "", "interfaces": "", "fields": [], "file": "proctor-common/src/test/java/com/indeed/proctor/common/LegacyTaglibFunctionsTest.java"}, "test_case": {"identifier": "testLength", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testLength() {\n        assertThat(length(null)).isEqualTo(0);\n        assertThat(length(\"\")).isEqualTo(0);\n        assertThat(length(\"foo\")).isEqualTo(3);\n\n        assertThat(length(emptyList())).isEqualTo(0);\n        assertThat(length(ImmutableList.of(1, 2, 3))).isEqualTo(3);\n\n        assertThat(length(emptySet())).isEqualTo(0);\n        assertThat(length(ImmutableSet.of(1, 2, 3))).isEqualTo(3);\n\n        assertThat(length(emptyMap())).isEqualTo(0);\n        assertThat(length(ImmutableMap.of(1, 2))).isEqualTo(1);\n\n        assertThat(length(new String[0])).isEqualTo(0);\n        assertThat(length(new String[3])).isEqualTo(3);\n    }", "signature": "void testLength()", "full_signature": "@Test public void testLength()", "class_method_signature": "LegacyTaglibFunctionsTest.testLength()", "testcase": true, "constructor": false, "invocations": ["isEqualTo", "assertThat", "length", "isEqualTo", "assertThat", "length", "isEqualTo", "assertThat", "length", "isEqualTo", "assertThat", "length", "emptyList", "isEqualTo", "assertThat", "length", "of", "isEqualTo", "assertThat", "length", "emptySet", "isEqualTo", "assertThat", "length", "of", "isEqualTo", "assertThat", "length", "emptyMap", "isEqualTo", "assertThat", "length", "of", "isEqualTo", "assertThat", "length", "isEqualTo", "assertThat", "length"]}, "focal_class": {"identifier": "LegacyTaglibFunctions", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "toUpperCase", "parameters": "(@Nullable final String input)", "modifiers": "public static", "return": "String", "signature": "String toUpperCase(@Nullable final String input)", "full_signature": "public static String toUpperCase(@Nullable final String input)", "class_method_signature": "LegacyTaglibFunctions.toUpperCase(@Nullable final String input)", "testcase": false, "constructor": false}, {"identifier": "toLowerCase", "parameters": "(@Nullable final String input)", "modifiers": "public static", "return": "String", "signature": "String toLowerCase(@Nullable final String input)", "full_signature": "public static String toLowerCase(@Nullable final String input)", "class_method_signature": "LegacyTaglibFunctions.toLowerCase(@Nullable final String input)", "testcase": false, "constructor": false}, {"identifier": "indexOf", "parameters": "(@Nullable String input, @Nullable String substring)", "modifiers": "public static", "return": "int", "signature": "int indexOf(@Nullable String input, @Nullable String substring)", "full_signature": "public static int indexOf(@Nullable String input, @Nullable String substring)", "class_method_signature": "LegacyTaglibFunctions.indexOf(@Nullable String input, @Nullable String substring)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(@Nullable final String input, @Nullable final String substring)", "modifiers": "public static", "return": "boolean", "signature": "boolean contains(@Nullable final String input, @Nullable final String substring)", "full_signature": "public static boolean contains(@Nullable final String input, @Nullable final String substring)", "class_method_signature": "LegacyTaglibFunctions.contains(@Nullable final String input, @Nullable final String substring)", "testcase": false, "constructor": false}, {"identifier": "containsIgnoreCase", "parameters": "(@Nullable String input, @Nullable String substring)", "modifiers": "public static", "return": "boolean", "signature": "boolean containsIgnoreCase(@Nullable String input, @Nullable String substring)", "full_signature": "public static boolean containsIgnoreCase(@Nullable String input, @Nullable String substring)", "class_method_signature": "LegacyTaglibFunctions.containsIgnoreCase(@Nullable String input, @Nullable String substring)", "testcase": false, "constructor": false}, {"identifier": "startsWith", "parameters": "(@Nullable String input, @Nullable String substring)", "modifiers": "public static", "return": "boolean", "signature": "boolean startsWith(@Nullable String input, @Nullable String substring)", "full_signature": "public static boolean startsWith(@Nullable String input, @Nullable String substring)", "class_method_signature": "LegacyTaglibFunctions.startsWith(@Nullable String input, @Nullable String substring)", "testcase": false, "constructor": false}, {"identifier": "endsWith", "parameters": "(@Nullable String input, @Nullable String substring)", "modifiers": "public static", "return": "boolean", "signature": "boolean endsWith(@Nullable String input, @Nullable String substring)", "full_signature": "public static boolean endsWith(@Nullable String input, @Nullable String substring)", "class_method_signature": "LegacyTaglibFunctions.endsWith(@Nullable String input, @Nullable String substring)", "testcase": false, "constructor": false}, {"identifier": "substring", "parameters": "(@Nullable String input, int beginIndex, int endIndex)", "modifiers": "public static", "return": "String", "signature": "String substring(@Nullable String input, int beginIndex, int endIndex)", "full_signature": "public static String substring(@Nullable String input, int beginIndex, int endIndex)", "class_method_signature": "LegacyTaglibFunctions.substring(@Nullable String input, int beginIndex, int endIndex)", "testcase": false, "constructor": false}, {"identifier": "substringAfter", "parameters": "(@Nullable String input, @Nullable String substring)", "modifiers": "public static", "return": "String", "signature": "String substringAfter(@Nullable String input, @Nullable String substring)", "full_signature": "public static String substringAfter(@Nullable String input, @Nullable String substring)", "class_method_signature": "LegacyTaglibFunctions.substringAfter(@Nullable String input, @Nullable String substring)", "testcase": false, "constructor": false}, {"identifier": "substringBefore", "parameters": "(@Nullable String input, @Nullable String substring)", "modifiers": "public static", "return": "String", "signature": "String substringBefore(@Nullable String input, @Nullable String substring)", "full_signature": "public static String substringBefore(@Nullable String input, @Nullable String substring)", "class_method_signature": "LegacyTaglibFunctions.substringBefore(@Nullable String input, @Nullable String substring)", "testcase": false, "constructor": false}, {"identifier": "trim", "parameters": "(@Nullable final String input)", "modifiers": "public static", "return": "String", "signature": "String trim(@Nullable final String input)", "full_signature": "public static String trim(@Nullable final String input)", "class_method_signature": "LegacyTaglibFunctions.trim(@Nullable final String input)", "testcase": false, "constructor": false}, {"identifier": "replace", "parameters": "(\n            @Nullable String input,\n            @Nullable String substringBefore,\n            final String substringAfter)", "modifiers": "public static", "return": "String", "signature": "String replace(\n            @Nullable String input,\n            @Nullable String substringBefore,\n            final String substringAfter)", "full_signature": "public static String replace(\n            @Nullable String input,\n            @Nullable String substringBefore,\n            final String substringAfter)", "class_method_signature": "LegacyTaglibFunctions.replace(\n            @Nullable String input,\n            @Nullable String substringBefore,\n            final String substringAfter)", "testcase": false, "constructor": false}, {"identifier": "split", "parameters": "(\n            @Nullable String input,\n            @Nullable String delimiters)", "modifiers": "public static", "return": "String[]", "signature": "String[] split(\n            @Nullable String input,\n            @Nullable String delimiters)", "full_signature": "public static String[] split(\n            @Nullable String input,\n            @Nullable String delimiters)", "class_method_signature": "LegacyTaglibFunctions.split(\n            @Nullable String input,\n            @Nullable String delimiters)", "testcase": false, "constructor": false}, {"identifier": "length", "parameters": "(@Nullable final Object obj)", "modifiers": "public static", "return": "int", "signature": "int length(@Nullable final Object obj)", "full_signature": "public static int length(@Nullable final Object obj)", "class_method_signature": "LegacyTaglibFunctions.length(@Nullable final Object obj)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(@Nullable final String[] array, @Nullable String separator)", "modifiers": "public static", "return": "String", "signature": "String join(@Nullable final String[] array, @Nullable String separator)", "full_signature": "public static String join(@Nullable final String[] array, @Nullable String separator)", "class_method_signature": "LegacyTaglibFunctions.join(@Nullable final String[] array, @Nullable String separator)", "testcase": false, "constructor": false}], "file": "proctor-common/src/main/java/com/indeed/proctor/common/LegacyTaglibFunctions.java"}, "focal_method": {"identifier": "length", "parameters": "(@Nullable final Object obj)", "modifiers": "public static", "return": "int", "body": "public static int length(@Nullable final Object obj) {\n        if (obj == null) {\n            return 0;\n        }\n\n        if (obj instanceof String) {\n            return ((String) obj).length();\n        }\n        if (obj instanceof Collection) {\n            return ((Collection) obj).size();\n        }\n        if (obj instanceof Map) {\n            return ((Map) obj).size();\n        }\n\n        int count = 0;\n        if (obj instanceof Iterator) {\n            final Iterator iter = (Iterator)obj;\n            count = 0;\n            while (iter.hasNext()) {\n                count++;\n                iter.next();\n            }\n            return count;\n        }\n        if (obj instanceof Enumeration) {\n            final Enumeration inputEnum = (Enumeration)obj;\n            count = 0;\n            while (inputEnum.hasMoreElements()) {\n                count++;\n                inputEnum.nextElement();\n            }\n            return count;\n        }\n        try {\n            count = Array.getLength(obj);\n            return count;\n        } catch (final IllegalArgumentException ex) {\n            // ignore\n        }\n        throw new IllegalStateException(\"Don't know how to iterate over supplied \\\"items\\\" in &lt;forEach&gt;\");\n    }", "signature": "int length(@Nullable final Object obj)", "full_signature": "public static int length(@Nullable final Object obj)", "class_method_signature": "LegacyTaglibFunctions.length(@Nullable final Object obj)", "testcase": false, "constructor": false, "invocations": ["length", "size", "size", "hasNext", "next", "hasMoreElements", "nextElement", "getLength"]}, "repository": {"repo_id": 13075200, "url": "https://github.com/indeedeng/proctor", "language": "Java", "is_fork": false, "fork_count": 88, "stargazer_count": 347, "size": 4699, "license": "licensed"}}