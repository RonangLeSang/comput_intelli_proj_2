{"test_class": {"identifier": "SpecificationGeneratorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final SpecificationGenerator generator = new SpecificationGenerator();", "modifier": "private final", "type": "SpecificationGenerator", "declarator": "generator = new SpecificationGenerator()", "var_name": "generator"}], "file": "proctor-common/src/test/java/com/indeed/proctor/common/SpecificationGeneratorTest.java"}, "test_case": {"identifier": "testGenerateSpecificationWithBuckets", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGenerateSpecificationWithBuckets() {\n        final String description = \"this test has 3 buckets\";\n        final TestBucket control = new TestBucket(\"control\", 0, \"control bucket\");\n        final TestBucket inactiveBucket = new TestBucket(\"inactive\", -3, \"status quo\");\n        final TestBucket test = new TestBucket(\"test\", 1, \"test bucket\");\n        final TestDefinition empty = stubTestDefinition(description, Arrays.asList(control, inactiveBucket, test));\n        final TestSpecification specification = generator.generateSpecification(empty);\n        assertEquals(description, specification.getDescription());\n        assertEquals(3, specification.getBuckets().size());\n        assertEquals(inactiveBucket.getValue(), specification.getFallbackValue());\n        assertNull(specification.getPayload());\n        final Map<String, Integer> buckets = specification.getBuckets();\n        assertEquals(inactiveBucket.getValue(), (int) buckets.get(inactiveBucket.getName()));\n        assertEquals(control.getValue(), (int) buckets.get(control.getName()));\n        assertEquals(test.getValue(), (int) buckets.get(test.getName()));\n        // buckets should be ordered by value ascending\n        final List<Integer> values = new ArrayList<>(buckets.values());\n        assertEquals(inactiveBucket.getValue(), values.get(0).intValue());\n        assertEquals(control.getValue(), values.get(1).intValue());\n        assertEquals(test.getValue(), values.get(2).intValue());\n    }", "signature": "void testGenerateSpecificationWithBuckets()", "full_signature": "@Test public void testGenerateSpecificationWithBuckets()", "class_method_signature": "SpecificationGeneratorTest.testGenerateSpecificationWithBuckets()", "testcase": true, "constructor": false, "invocations": ["stubTestDefinition", "asList", "generateSpecification", "assertEquals", "getDescription", "assertEquals", "size", "getBuckets", "assertEquals", "getValue", "getFallbackValue", "assertNull", "getPayload", "getBuckets", "assertEquals", "getValue", "get", "getName", "assertEquals", "getValue", "get", "getName", "assertEquals", "getValue", "get", "getName", "values", "assertEquals", "getValue", "intValue", "get", "assertEquals", "getValue", "intValue", "get", "assertEquals", "getValue", "intValue", "get"]}, "focal_class": {"identifier": "SpecificationGenerator", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "generateSpecification", "parameters": "(@Nonnull final TestDefinition testDefinition)", "modifiers": "@Nonnull public", "return": "TestSpecification", "signature": "TestSpecification generateSpecification(@Nonnull final TestDefinition testDefinition)", "full_signature": "@Nonnull public TestSpecification generateSpecification(@Nonnull final TestDefinition testDefinition)", "class_method_signature": "SpecificationGenerator.generateSpecification(@Nonnull final TestDefinition testDefinition)", "testcase": false, "constructor": false}, {"identifier": "generatePayloadSpecification", "parameters": "(final List<Payload> payloads)", "modifiers": "@VisibleForTesting @Nonnull static", "return": "Optional<PayloadSpecification>", "signature": "Optional<PayloadSpecification> generatePayloadSpecification(final List<Payload> payloads)", "full_signature": "@VisibleForTesting @Nonnull static Optional<PayloadSpecification> generatePayloadSpecification(final List<Payload> payloads)", "class_method_signature": "SpecificationGenerator.generatePayloadSpecification(final List<Payload> payloads)", "testcase": false, "constructor": false}, {"identifier": "determinePayloadTypeFromPayloads", "parameters": "(@Nonnull final List<Payload> testDefinitionBuckets)", "modifiers": "@Nonnull private static", "return": "Optional<PayloadType>", "signature": "Optional<PayloadType> determinePayloadTypeFromPayloads(@Nonnull final List<Payload> testDefinitionBuckets)", "full_signature": "@Nonnull private static Optional<PayloadType> determinePayloadTypeFromPayloads(@Nonnull final List<Payload> testDefinitionBuckets)", "class_method_signature": "SpecificationGenerator.determinePayloadTypeFromPayloads(@Nonnull final List<Payload> testDefinitionBuckets)", "testcase": false, "constructor": false}, {"identifier": "generateMapPayloadSchema", "parameters": "(@Nonnull final List<Payload> payloads)", "modifiers": "@Nonnull private static", "return": "Optional<Map<String, PayloadType>>", "signature": "Optional<Map<String, PayloadType>> generateMapPayloadSchema(@Nonnull final List<Payload> payloads)", "full_signature": "@Nonnull private static Optional<Map<String, PayloadType>> generateMapPayloadSchema(@Nonnull final List<Payload> payloads)", "class_method_signature": "SpecificationGenerator.generateMapPayloadSchema(@Nonnull final List<Payload> payloads)", "testcase": false, "constructor": false}, {"identifier": "mergeSchemas", "parameters": "(@Nonnull final List<Map<String, PayloadType>> schemas)", "modifiers": "@Nonnull private static", "return": "Map<String, PayloadType>", "signature": "Map<String, PayloadType> mergeSchemas(@Nonnull final List<Map<String, PayloadType>> schemas)", "full_signature": "@Nonnull private static Map<String, PayloadType> mergeSchemas(@Nonnull final List<Map<String, PayloadType>> schemas)", "class_method_signature": "SpecificationGenerator.mergeSchemas(@Nonnull final List<Map<String, PayloadType>> schemas)", "testcase": false, "constructor": false}, {"identifier": "inferSchemaForPayload", "parameters": "(\n            @Nonnull final Payload payload,\n            @Nonnull final Set<String> emptyListValuePayloadKeys\n    )", "modifiers": "private static", "return": "Map<String, PayloadType>", "signature": "Map<String, PayloadType> inferSchemaForPayload(\n            @Nonnull final Payload payload,\n            @Nonnull final Set<String> emptyListValuePayloadKeys\n    )", "full_signature": "private static Map<String, PayloadType> inferSchemaForPayload(\n            @Nonnull final Payload payload,\n            @Nonnull final Set<String> emptyListValuePayloadKeys\n    )", "class_method_signature": "SpecificationGenerator.inferSchemaForPayload(\n            @Nonnull final Payload payload,\n            @Nonnull final Set<String> emptyListValuePayloadKeys\n    )", "testcase": false, "constructor": false}], "file": "proctor-common/src/main/java/com/indeed/proctor/common/SpecificationGenerator.java"}, "focal_method": {"identifier": "generateSpecification", "parameters": "(@Nonnull final TestDefinition testDefinition)", "modifiers": "@Nonnull public", "return": "TestSpecification", "body": "@Nonnull\n    public TestSpecification generateSpecification(@Nonnull final TestDefinition testDefinition) {\n        final TestSpecification testSpecification = new TestSpecification();\n        // Sort buckets by value ascending\n\n        final List<TestBucket> testDefinitionBuckets = Ordering.from(new Comparator<TestBucket>() {\n            @Override\n            public int compare(final TestBucket lhs, final TestBucket rhs) {\n                return Ints.compare(lhs.getValue(), rhs.getValue());\n            }\n        }).immutableSortedCopy(testDefinition.getBuckets());\n        int fallbackValue = -1;\n        if (!testDefinitionBuckets.isEmpty()) {\n            // buckets are sorted, choose smallest value as the fallback value\n            fallbackValue = testDefinitionBuckets.get(0).getValue();\n            final Optional<PayloadSpecification> specOpt = generatePayloadSpecification(testDefinitionBuckets.stream()\n                    .map(TestBucket::getPayload)\n                    .filter(Objects::nonNull)\n                    .collect(Collectors.toList()));\n            specOpt.ifPresent(testSpecification::setPayload);\n        }\n\n        final Map<String, Integer> buckets = Maps.newLinkedHashMap();\n        for (final TestBucket bucket : testDefinitionBuckets) {\n            buckets.put(bucket.getName(), bucket.getValue());\n        }\n        testSpecification.setBuckets(buckets);\n        testSpecification.setDescription(testDefinition.getDescription());\n        testSpecification.setFallbackValue(fallbackValue);\n        return testSpecification;\n    }", "signature": "TestSpecification generateSpecification(@Nonnull final TestDefinition testDefinition)", "full_signature": "@Nonnull public TestSpecification generateSpecification(@Nonnull final TestDefinition testDefinition)", "class_method_signature": "SpecificationGenerator.generateSpecification(@Nonnull final TestDefinition testDefinition)", "testcase": false, "constructor": false, "invocations": ["immutableSortedCopy", "from", "compare", "getValue", "getValue", "getBuckets", "isEmpty", "getValue", "get", "generatePayloadSpecification", "collect", "filter", "map", "stream", "toList", "ifPresent", "newLinkedHashMap", "put", "getName", "getValue", "setBuckets", "setDescription", "getDescription", "setFallbackValue"]}, "repository": {"repo_id": 13075200, "url": "https://github.com/indeedeng/proctor", "language": "Java", "is_fork": false, "fork_count": 88, "stargazer_count": 347, "size": 4699, "license": "licensed"}}