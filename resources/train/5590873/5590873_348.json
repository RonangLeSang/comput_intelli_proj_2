{"test_class": {"identifier": "ImportsTest", "superclass": "", "interfaces": "", "fields": [], "file": "modules/quality-immutable-object/src/test/java/net/sf/qualitycheck/immutableobject/domain/ImportsTest.java"}, "test_case": {"identifier": "find", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void find() {\n\t\tfinal List<Import> set = ImmutableList.of(Import.of(String.class), Import.of(Date.class), Import.of(Integer.class));\n\t\tfinal Imports imports = Imports.copyOf(set);\n\t\tassertEquals(Import.of(String.class), imports.find(\"String\"));\n\t\tassertEquals(Import.of(String.class), imports.find(\"java.lang.String\"));\n\t\tassertEquals(Import.of(Date.class), imports.find(\"Date\"));\n\t\tassertEquals(Import.of(Date.class), imports.find(\"java.util.Date\"));\n\t\tassertEquals(Import.of(Integer.class), imports.find(\"Integer\"));\n\t\tassertEquals(Import.of(Integer.class), imports.find(\"java.lang.Integer\"));\n\t}", "signature": "void find()", "full_signature": "@Test public void find()", "class_method_signature": "ImportsTest.find()", "testcase": true, "constructor": false, "invocations": ["of", "of", "of", "of", "copyOf", "assertEquals", "of", "find", "assertEquals", "of", "find", "assertEquals", "of", "find", "assertEquals", "of", "find", "assertEquals", "of", "find", "assertEquals", "of", "find"]}, "focal_class": {"identifier": "Imports", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Predicate<Import> IGNORE_JAVA_LANG = new Predicate<Import>() {\n\t\t@Override\n\t\tpublic boolean apply(@Nonnull final Import imp) { // NOSONAR\n\t\t\treturn !Package.JAVA_LANG.equals(imp.getType().getPackage());\n\t\t}\n\t};", "modifier": "private static final", "type": "Predicate<Import>", "declarator": "IGNORE_JAVA_LANG = new Predicate<Import>() {\n\t\t@Override\n\t\tpublic boolean apply(@Nonnull final Import imp) { // NOSONAR\n\t\t\treturn !Package.JAVA_LANG.equals(imp.getType().getPackage());\n\t\t}\n\t}", "var_name": "IGNORE_JAVA_LANG"}, {"original_string": "private static final Predicate<Import> IGNORE_UNDEFINED = new Predicate<Import>() {\n\t\t@Override\n\t\tpublic boolean apply(@Nonnull final Import imp) { // NOSONAR\n\t\t\treturn !Package.UNDEFINED.equals(imp.getType().getPackage());\n\t\t}\n\t};", "modifier": "private static final", "type": "Predicate<Import>", "declarator": "IGNORE_UNDEFINED = new Predicate<Import>() {\n\t\t@Override\n\t\tpublic boolean apply(@Nonnull final Import imp) { // NOSONAR\n\t\t\treturn !Package.UNDEFINED.equals(imp.getType().getPackage());\n\t\t}\n\t}", "var_name": "IGNORE_UNDEFINED"}, {"original_string": "private static final Ordering<Import> ORDER = new Ordering<Import>() {\n\t\t@Override\n\t\tpublic int compare(@Nonnull final Import left, @Nonnull final Import right) { // NOSONAR\n\t\t\treturn left.getType().toString().compareTo(right.getType().toString());\n\t\t}\n\t};", "modifier": "private static final", "type": "Ordering<Import>", "declarator": "ORDER = new Ordering<Import>() {\n\t\t@Override\n\t\tpublic int compare(@Nonnull final Import left, @Nonnull final Import right) { // NOSONAR\n\t\t\treturn left.getType().toString().compareTo(right.getType().toString());\n\t\t}\n\t}", "var_name": "ORDER"}, {"original_string": "@Nonnull\n\tprivate final List<Import> imports;", "modifier": "@Nonnull\n\tprivate final", "type": "List<Import>", "declarator": "imports", "var_name": "imports"}], "methods": [{"identifier": "allOf", "parameters": "(@Nonnull final Clazz clazz)", "modifiers": "public static", "return": "Imports", "signature": "Imports allOf(@Nonnull final Clazz clazz)", "full_signature": "public static Imports allOf(@Nonnull final Clazz clazz)", "class_method_signature": "Imports.allOf(@Nonnull final Clazz clazz)", "testcase": false, "constructor": false}, {"identifier": "allOf", "parameters": "(@Nonnull final Field field)", "modifiers": "public static", "return": "Imports", "signature": "Imports allOf(@Nonnull final Field field)", "full_signature": "public static Imports allOf(@Nonnull final Field field)", "class_method_signature": "Imports.allOf(@Nonnull final Field field)", "testcase": false, "constructor": false}, {"identifier": "allOf", "parameters": "(@Nonnull final Method method)", "modifiers": "public static", "return": "Imports", "signature": "Imports allOf(@Nonnull final Method method)", "full_signature": "public static Imports allOf(@Nonnull final Method method)", "class_method_signature": "Imports.allOf(@Nonnull final Method method)", "testcase": false, "constructor": false}, {"identifier": "copyOf", "parameters": "(final Iterable<Import> imports)", "modifiers": "public static", "return": "Imports", "signature": "Imports copyOf(final Iterable<Import> imports)", "full_signature": "public static Imports copyOf(final Iterable<Import> imports)", "class_method_signature": "Imports.copyOf(final Iterable<Import> imports)", "testcase": false, "constructor": false}, {"identifier": "of", "parameters": "(final Import... imports)", "modifiers": "public static", "return": "Imports", "signature": "Imports of(final Import... imports)", "full_signature": "public static Imports of(final Import... imports)", "class_method_signature": "Imports.of(final Import... imports)", "testcase": false, "constructor": false}, {"identifier": "of", "parameters": "(final Iterable<Import> imports)", "modifiers": "public static", "return": "Imports", "signature": "Imports of(final Iterable<Import> imports)", "full_signature": "public static Imports of(final Iterable<Import> imports)", "class_method_signature": "Imports.of(final Iterable<Import> imports)", "testcase": false, "constructor": false}, {"identifier": "ofAnnotations", "parameters": "(@Nonnull final Iterable<Annotation> annotations)", "modifiers": "private static", "return": "Imports", "signature": "Imports ofAnnotations(@Nonnull final Iterable<Annotation> annotations)", "full_signature": "private static Imports ofAnnotations(@Nonnull final Iterable<Annotation> annotations)", "class_method_signature": "Imports.ofAnnotations(@Nonnull final Iterable<Annotation> annotations)", "testcase": false, "constructor": false}, {"identifier": "ofAttributes", "parameters": "(@Nonnull final Iterable<Attribute> attributes)", "modifiers": "private static", "return": "Imports", "signature": "Imports ofAttributes(@Nonnull final Iterable<Attribute> attributes)", "full_signature": "private static Imports ofAttributes(@Nonnull final Iterable<Attribute> attributes)", "class_method_signature": "Imports.ofAttributes(@Nonnull final Iterable<Attribute> attributes)", "testcase": false, "constructor": false}, {"identifier": "ofConstructors", "parameters": "(@Nonnull final Iterable<Constructor> constructors)", "modifiers": "private static", "return": "Imports", "signature": "Imports ofConstructors(@Nonnull final Iterable<Constructor> constructors)", "full_signature": "private static Imports ofConstructors(@Nonnull final Iterable<Constructor> constructors)", "class_method_signature": "Imports.ofConstructors(@Nonnull final Iterable<Constructor> constructors)", "testcase": false, "constructor": false}, {"identifier": "ofFields", "parameters": "(@Nonnull final Iterable<Field> fields)", "modifiers": "private static", "return": "Imports", "signature": "Imports ofFields(@Nonnull final Iterable<Field> fields)", "full_signature": "private static Imports ofFields(@Nonnull final Iterable<Field> fields)", "class_method_signature": "Imports.ofFields(@Nonnull final Iterable<Field> fields)", "testcase": false, "constructor": false}, {"identifier": "ofInterfaces", "parameters": "(@Nonnull final Iterable<Interface> interfaces)", "modifiers": "private static", "return": "Imports", "signature": "Imports ofInterfaces(@Nonnull final Iterable<Interface> interfaces)", "full_signature": "private static Imports ofInterfaces(@Nonnull final Iterable<Interface> interfaces)", "class_method_signature": "Imports.ofInterfaces(@Nonnull final Iterable<Interface> interfaces)", "testcase": false, "constructor": false}, {"identifier": "ofMethods", "parameters": "(@Nonnull final Iterable<Method> methods)", "modifiers": "private static", "return": "Imports", "signature": "Imports ofMethods(@Nonnull final Iterable<Method> methods)", "full_signature": "private static Imports ofMethods(@Nonnull final Iterable<Method> methods)", "class_method_signature": "Imports.ofMethods(@Nonnull final Iterable<Method> methods)", "testcase": false, "constructor": false}, {"identifier": "Imports", "parameters": "(final Iterable<Import> imports)", "modifiers": "private", "return": "", "signature": " Imports(final Iterable<Import> imports)", "full_signature": "private  Imports(final Iterable<Import> imports)", "class_method_signature": "Imports.Imports(final Iterable<Import> imports)", "testcase": false, "constructor": true}, {"identifier": "asList", "parameters": "()", "modifiers": "@Nonnull public", "return": "List<Import>", "signature": "List<Import> asList()", "full_signature": "@Nonnull public List<Import> asList()", "class_method_signature": "Imports.asList()", "testcase": false, "constructor": false}, {"identifier": "copyAndAdd", "parameters": "(final Collection<Import> imports)", "modifiers": "@Nonnull public", "return": "Imports", "signature": "Imports copyAndAdd(final Collection<Import> imports)", "full_signature": "@Nonnull public Imports copyAndAdd(final Collection<Import> imports)", "class_method_signature": "Imports.copyAndAdd(final Collection<Import> imports)", "testcase": false, "constructor": false}, {"identifier": "copyAndAdd", "parameters": "(final Imports imports)", "modifiers": "@Nonnull public", "return": "Imports", "signature": "Imports copyAndAdd(final Imports imports)", "full_signature": "@Nonnull public Imports copyAndAdd(final Imports imports)", "class_method_signature": "Imports.copyAndAdd(final Imports imports)", "testcase": false, "constructor": false}, {"identifier": "filter", "parameters": "()", "modifiers": "@Nonnull public", "return": "Imports", "signature": "Imports filter()", "full_signature": "@Nonnull public Imports filter()", "class_method_signature": "Imports.filter()", "testcase": false, "constructor": false}, {"identifier": "find", "parameters": "(@Nonnull final String typeName)", "modifiers": "@Nullable public", "return": "Import", "signature": "Import find(@Nonnull final String typeName)", "full_signature": "@Nullable public Import find(@Nonnull final String typeName)", "class_method_signature": "Imports.find(@Nonnull final String typeName)", "testcase": false, "constructor": false}, {"identifier": "sortByName", "parameters": "()", "modifiers": "@Nonnull public", "return": "Imports", "signature": "Imports sortByName()", "full_signature": "@Nonnull public Imports sortByName()", "class_method_signature": "Imports.sortByName()", "testcase": false, "constructor": false}], "file": "modules/quality-immutable-object/src/main/java/net/sf/qualitycheck/immutableobject/domain/Imports.java"}, "focal_method": {"identifier": "find", "parameters": "(@Nonnull final String typeName)", "modifiers": "@Nullable public", "return": "Import", "body": "@Nullable\n\tpublic Import find(@Nonnull final String typeName) {\n\t\tCheck.notEmpty(typeName, \"typeName\");\n\t\tImport ret = null;\n\t\tfinal Type type = new Type(typeName);\n\t\tfor (final Import imp : imports) {\n\t\t\tif (imp.getType().getName().equals(type.getName())) {\n\t\t\t\tret = imp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == null) {\n\t\t\tfinal Type javaLangType = Type.evaluateJavaLangType(typeName);\n\t\t\tif (javaLangType != null) {\n\t\t\t\tret = Import.of(javaLangType);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}", "signature": "Import find(@Nonnull final String typeName)", "full_signature": "@Nullable public Import find(@Nonnull final String typeName)", "class_method_signature": "Imports.find(@Nonnull final String typeName)", "testcase": false, "constructor": false, "invocations": ["notEmpty", "equals", "getName", "getType", "getName", "evaluateJavaLangType", "of"]}, "repository": {"repo_id": 5590873, "url": "https://github.com/arouel/quality-check", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 7, "size": 1671, "license": "licensed"}}