{"test_class": {"identifier": "MigrationTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Inject\n    ObjectMapper mapper;", "modifier": "@Inject", "type": "ObjectMapper", "declarator": "mapper", "var_name": "mapper"}], "file": "giulius-mongodb-async-init/src/test/java/com/mastfrog/mongodb/migration/MigrationTest.java"}, "test_case": {"identifier": "testRollback", "parameters": "(@Named(\"stuff\") Provider<MongoCollection<Document>> stuff, @Named(\"migrations\") Provider<MongoCollection<Document>> migrations, Provider<MongoDatabase> db, Provider<MongoClient> client, Provider<Dependencies> deps)", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRollback(@Named(\"stuff\") Provider<MongoCollection<Document>> stuff, @Named(\"migrations\") Provider<MongoCollection<Document>> migrations, Provider<MongoDatabase> db, Provider<MongoClient> client, Provider<Dependencies> deps) throws InterruptedException, Throwable {\n        Function<Class<? extends MigrationWorker>, MigrationWorker> convert = deps.get()::getInstance;\n\n        Migration[] m = new Migration[1];\n        new MigrationBuilder(\"stuff-new\", 12, (mig) -> {\n            m[0] = (Migration) mig;\n            return null;\n        }).backup(\"stuff\", new Document(\"index\", new Document(\"$lte\", 150)))\n                .migrateCollection(\"stuff\", Failer.class).build();\n        assertNotNull(m[0]);\n        CompletableFuture<Document> cf = new CompletableFuture<>();\n        CompletableFuture<Document> res = m[0].migrate(cf, client.get(), db.get(), convert);\n        Document[] ds = new Document[1];\n        Throwable[] thr = new Throwable[1];\n        CountDownLatch latch = new CountDownLatch(1);\n        res.whenCompleteAsync((doc, thrown) -> {\n            thr[0] = thrown;\n            ds[0] = doc;\n            latch.countDown();\n        });\n        cf.complete(new Document());\n        latch.await(20, TimeUnit.SECONDS);\n        assertNotNull(thr[0]);\n        assertTrue(thr[0] instanceof CompletionException);\n        if (!(thr[0].getCause() instanceof FooException)) {\n            throw thr[0];\n        }\n        assertEquals(\"Failed\", thr[0].getCause().getMessage());\n        assertNull(ds[0]);\n        Thread.sleep(750);\n        TestSupport.await(ts -> {\n            stuff.get().find().forEach(d -> {\n                assertFalse(d.toString(), d.containsKey(\"author\"));\n                assertTrue(d.toString(), d.containsKey(\"created\"));\n                assertFalse(d.toString(), d.containsKey(\"ix\"));\n                assertTrue(d.toString(), d.containsKey(\"index\"));\n            }, ts.doneCallback());\n        });\n    }", "signature": "void testRollback(@Named(\"stuff\") Provider<MongoCollection<Document>> stuff, @Named(\"migrations\") Provider<MongoCollection<Document>> migrations, Provider<MongoDatabase> db, Provider<MongoClient> client, Provider<Dependencies> deps)", "full_signature": "@Test public void testRollback(@Named(\"stuff\") Provider<MongoCollection<Document>> stuff, @Named(\"migrations\") Provider<MongoCollection<Document>> migrations, Provider<MongoDatabase> db, Provider<MongoClient> client, Provider<Dependencies> deps)", "class_method_signature": "MigrationTest.testRollback(@Named(\"stuff\") Provider<MongoCollection<Document>> stuff, @Named(\"migrations\") Provider<MongoCollection<Document>> migrations, Provider<MongoDatabase> db, Provider<MongoClient> client, Provider<Dependencies> deps)", "testcase": true, "constructor": false, "invocations": ["get", "build", "migrateCollection", "backup", "assertNotNull", "migrate", "get", "get", "whenCompleteAsync", "countDown", "complete", "await", "assertNotNull", "assertTrue", "getCause", "assertEquals", "getMessage", "getCause", "assertNull", "sleep", "await", "forEach", "find", "get", "assertFalse", "toString", "containsKey", "assertTrue", "toString", "containsKey", "assertFalse", "toString", "containsKey", "assertTrue", "toString", "containsKey", "doneCallback"]}, "focal_class": {"identifier": "Migration", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final String name;", "modifier": "private final", "type": "String", "declarator": "name", "var_name": "name"}, {"original_string": "private final int newVersion;", "modifier": "private final", "type": "int", "declarator": "newVersion", "var_name": "newVersion"}, {"original_string": "private final Map<String, OneOf<MigrationWorker, Class<? extends MigrationWorker>>> migrations;", "modifier": "private final", "type": "Map<String, OneOf<MigrationWorker, Class<? extends MigrationWorker>>>", "declarator": "migrations", "var_name": "migrations"}, {"original_string": "private final Map<String, Document> backupQueryForCollection;", "modifier": "private final", "type": "Map<String, Document>", "declarator": "backupQueryForCollection", "var_name": "backupQueryForCollection"}, {"original_string": "private static final boolean LOG = Boolean.getBoolean(\"migration.log\");", "modifier": "private static final", "type": "boolean", "declarator": "LOG = Boolean.getBoolean(\"migration.log\")", "var_name": "LOG"}], "methods": [{"identifier": "Migration", "parameters": "(String name, int newVersion, Map<String, OneOf<MigrationWorker, Class<? extends MigrationWorker>>> migrations, Map<String, Document> backupQueryForCollection)", "modifiers": "public", "return": "", "signature": " Migration(String name, int newVersion, Map<String, OneOf<MigrationWorker, Class<? extends MigrationWorker>>> migrations, Map<String, Document> backupQueryForCollection)", "full_signature": "public  Migration(String name, int newVersion, Map<String, OneOf<MigrationWorker, Class<? extends MigrationWorker>>> migrations, Map<String, Document> backupQueryForCollection)", "class_method_signature": "Migration.Migration(String name, int newVersion, Map<String, OneOf<MigrationWorker, Class<? extends MigrationWorker>>> migrations, Map<String, Document> backupQueryForCollection)", "testcase": false, "constructor": true}, {"identifier": "isEmpty", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isEmpty()", "full_signature": "public boolean isEmpty()", "class_method_signature": "Migration.isEmpty()", "testcase": false, "constructor": false}, {"identifier": "future", "parameters": "(String name)", "modifiers": "public static", "return": "CompletableFuture<T>", "signature": "CompletableFuture<T> future(String name)", "full_signature": "public static CompletableFuture<T> future(String name)", "class_method_signature": "Migration.future(String name)", "testcase": false, "constructor": false}, {"identifier": "migrate", "parameters": "(CompletableFuture<Document> f, MongoClient client, MongoDatabase db, Function<Class<? extends MigrationWorker>, MigrationWorker> converter)", "modifiers": "public", "return": "CompletableFuture<Document>", "signature": "CompletableFuture<Document> migrate(CompletableFuture<Document> f, MongoClient client, MongoDatabase db, Function<Class<? extends MigrationWorker>, MigrationWorker> converter)", "full_signature": "public CompletableFuture<Document> migrate(CompletableFuture<Document> f, MongoClient client, MongoDatabase db, Function<Class<? extends MigrationWorker>, MigrationWorker> converter)", "class_method_signature": "Migration.migrate(CompletableFuture<Document> f, MongoClient client, MongoDatabase db, Function<Class<? extends MigrationWorker>, MigrationWorker> converter)", "testcase": false, "constructor": false}, {"identifier": "appendThrowable", "parameters": "(Throwable thrown)", "modifiers": "private", "return": "Document", "signature": "Document appendThrowable(Throwable thrown)", "full_signature": "private Document appendThrowable(Throwable thrown)", "class_method_signature": "Migration.appendThrowable(Throwable thrown)", "testcase": false, "constructor": false}, {"identifier": "rollback", "parameters": "(MongoDatabase db, Document agg)", "modifiers": "private", "return": "void", "signature": "void rollback(MongoDatabase db, Document agg)", "full_signature": "private void rollback(MongoDatabase db, Document agg)", "class_method_signature": "Migration.rollback(MongoDatabase db, Document agg)", "testcase": false, "constructor": false}, {"identifier": "backupCollectionName", "parameters": "(String collectionName)", "modifiers": "private", "return": "String", "signature": "String backupCollectionName(String collectionName)", "full_signature": "private String backupCollectionName(String collectionName)", "class_method_signature": "Migration.backupCollectionName(String collectionName)", "testcase": false, "constructor": false}, {"identifier": "backup", "parameters": "(String collectionName, Document queryDoc)", "modifiers": "private", "return": "ThrowingTriConsumer<CompletableFuture<Document>, MongoDatabase, MongoCollection<Document>>", "signature": "ThrowingTriConsumer<CompletableFuture<Document>, MongoDatabase, MongoCollection<Document>> backup(String collectionName, Document queryDoc)", "full_signature": "private ThrowingTriConsumer<CompletableFuture<Document>, MongoDatabase, MongoCollection<Document>> backup(String collectionName, Document queryDoc)", "class_method_signature": "Migration.backup(String collectionName, Document queryDoc)", "testcase": false, "constructor": false}], "file": "giulius-mongodb-async-init/src/main/java/com/mastfrog/mongodb/migration/Migration.java"}, "focal_method": {"identifier": "rollback", "parameters": "(MongoDatabase db, Document agg)", "modifiers": "private", "return": "void", "body": "private void rollback(MongoDatabase db, Document agg) {\n        CountDownLatch latch = new CountDownLatch(backupQueryForCollection.size() - 1);\n        Document rollbacks = new Document();\n        agg.append(\"rollback\", rollbacks);\n        for (String s : backupQueryForCollection.keySet()) {\n            MongoCollection<Document> from = db.getCollection(backupCollectionName(s));\n            MongoCollection<Document> to = db.getCollection(s);\n            Document thisCollection = new Document();\n            rollbacks.append(s, thisCollection);\n            AtomicInteger batchCount = new AtomicInteger();\n            from.find().batchCursor((cursor, thrown) -> {\n                if (thrown != null) {\n                    latch.countDown();\n                    return;\n                }\n                cursor.setBatchSize(50);\n                cursor.next((List<Document> l, Throwable t2) -> {\n                    List<ReplaceOneModel<Document>> replacements = new ArrayList<>();\n                    if (l == null) {\n                        latch.countDown();\n                    } else {\n                        int ct = batchCount.incrementAndGet();\n                        thisCollection.append(\"batch-\" + ct, l.size());\n                        for (Document d : l) {\n                            replacements.add(new ReplaceOneModel<>(new Document(\"_id\", d.getObjectId(\"_id\")), d));\n                        }\n                        to.bulkWrite(replacements, (bwr, th2) -> {\n                            if (th2 != null) {\n                                thisCollection.append(\"batch-\" + ct + \"-failed\", true);\n                                thisCollection.append(\"batch-\" + ct + \"-succeeded\", appendThrowable(th2));\n                            } else {\n                                thisCollection.append(\"batch-\" + ct + \"-succeeded\", l.size());\n                            }\n                        });\n                    }\n                });\n            });\n        }\n        try {\n            latch.await();\n        } catch (InterruptedException ex) {\n            Exceptions.chuck(ex);\n        }\n    }", "signature": "void rollback(MongoDatabase db, Document agg)", "full_signature": "private void rollback(MongoDatabase db, Document agg)", "class_method_signature": "Migration.rollback(MongoDatabase db, Document agg)", "testcase": false, "constructor": false, "invocations": ["size", "append", "keySet", "getCollection", "backupCollectionName", "getCollection", "append", "batchCursor", "find", "countDown", "setBatchSize", "next", "countDown", "incrementAndGet", "append", "size", "add", "getObjectId", "bulkWrite", "append", "append", "appendThrowable", "append", "size", "await", "chuck"]}, "repository": {"repo_id": 9272724, "url": "https://github.com/timboudreau/giulius", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 18, "size": 765, "license": "licensed"}}