{"test_class": {"identifier": "StringOptionUtilTest", "superclass": "", "interfaces": "", "fields": [], "file": "core-project/asakusa-runtime/src/test/java/com/asakusafw/runtime/value/StringOptionUtilTest.java"}, "test_case": {"identifier": "parseLong", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void parseLong() {\n        Function<Object, Long> parser = s -> StringOptionUtil.parseLong(new StringOption(String.valueOf(s)));\n        assertThat(parser.apply(\"0\"), is(0L));\n        assertThat(parser.apply(\"1\"), is(1L));\n        assertThat(parser.apply(\"+100\"), is(+100L));\n        assertThat(parser.apply(\"-100\"), is(-100L));\n        assertThat(parser.apply(Integer.MAX_VALUE), is((long) Integer.MAX_VALUE));\n        assertThat(parser.apply(Integer.MIN_VALUE), is((long) Integer.MIN_VALUE));\n        assertThat(parser.apply(Long.MAX_VALUE), is(Long.MAX_VALUE));\n        assertThat(parser.apply(Long.MIN_VALUE), is(Long.MIN_VALUE));\n\n        raise(() -> parser.apply(\"\"));\n        raise(() -> parser.apply(\"Hello, world!\"));\n        raise(() -> parser.apply(BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE)));\n        raise(() -> parser.apply(BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.ONE)));\n    }", "signature": "void parseLong()", "full_signature": "@Test public void parseLong()", "class_method_signature": "StringOptionUtilTest.parseLong()", "testcase": true, "constructor": false, "invocations": ["parseLong", "valueOf", "assertThat", "apply", "is", "assertThat", "apply", "is", "assertThat", "apply", "is", "assertThat", "apply", "is", "assertThat", "apply", "is", "assertThat", "apply", "is", "assertThat", "apply", "is", "assertThat", "apply", "is", "raise", "apply", "raise", "apply", "raise", "apply", "add", "valueOf", "raise", "apply", "subtract", "valueOf"]}, "focal_class": {"identifier": "StringOptionUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Charset ENCODING = StandardCharsets.UTF_8;", "modifier": "public static final", "type": "Charset", "declarator": "ENCODING = StandardCharsets.UTF_8", "var_name": "ENCODING"}, {"original_string": "static final ThreadLocal<DecoderBuffer> DECODER_POOL = ThreadLocal.withInitial(DecoderBuffer::new);", "modifier": "static final", "type": "ThreadLocal<DecoderBuffer>", "declarator": "DECODER_POOL = ThreadLocal.withInitial(DecoderBuffer::new)", "var_name": "DECODER_POOL"}, {"original_string": "private static final ThreadLocal<char[]> CHAR_ARRAY_BUFFERS = ThreadLocal.withInitial(() -> new char[512]);", "modifier": "private static final", "type": "ThreadLocal<char[]>", "declarator": "CHAR_ARRAY_BUFFERS = ThreadLocal.withInitial(() -> new char[512])", "var_name": "CHAR_ARRAY_BUFFERS"}, {"original_string": "private static final int CHAR_ARRAY_PADDING = 16;", "modifier": "private static final", "type": "int", "declarator": "CHAR_ARRAY_PADDING = 16", "var_name": "CHAR_ARRAY_PADDING"}], "methods": [{"identifier": "StringOptionUtil", "parameters": "()", "modifiers": "private", "return": "", "signature": " StringOptionUtil()", "full_signature": "private  StringOptionUtil()", "class_method_signature": "StringOptionUtil.StringOptionUtil()", "testcase": false, "constructor": true}, {"identifier": "countCodePoints", "parameters": "(StringOption option)", "modifiers": "public static", "return": "int", "signature": "int countCodePoints(StringOption option)", "full_signature": "public static int countCodePoints(StringOption option)", "class_method_signature": "StringOptionUtil.countCodePoints(StringOption option)", "testcase": false, "constructor": false}, {"identifier": "asReader", "parameters": "(StringOption option)", "modifiers": "public static", "return": "Reader", "signature": "Reader asReader(StringOption option)", "full_signature": "public static Reader asReader(StringOption option)", "class_method_signature": "StringOptionUtil.asReader(StringOption option)", "testcase": false, "constructor": false}, {"identifier": "trim", "parameters": "(StringOption option)", "modifiers": "public static", "return": "void", "signature": "void trim(StringOption option)", "full_signature": "public static void trim(StringOption option)", "class_method_signature": "StringOptionUtil.trim(StringOption option)", "testcase": false, "constructor": false}, {"identifier": "isTrimTarget", "parameters": "(byte b)", "modifiers": "private static", "return": "boolean", "signature": "boolean isTrimTarget(byte b)", "full_signature": "private static boolean isTrimTarget(byte b)", "class_method_signature": "StringOptionUtil.isTrimTarget(byte b)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(StringOption target, StringOption contents)", "modifiers": "public static", "return": "void", "signature": "void append(StringOption target, StringOption contents)", "full_signature": "public static void append(StringOption target, StringOption contents)", "class_method_signature": "StringOptionUtil.append(StringOption target, StringOption contents)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(StringOption target, String contents)", "modifiers": "public static", "return": "void", "signature": "void append(StringOption target, String contents)", "full_signature": "public static void append(StringOption target, String contents)", "class_method_signature": "StringOptionUtil.append(StringOption target, String contents)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(StringOption target, Text text)", "modifiers": "private static", "return": "void", "signature": "void append(StringOption target, Text text)", "full_signature": "private static void append(StringOption target, Text text)", "class_method_signature": "StringOptionUtil.append(StringOption target, Text text)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(StringBuilder target, StringOption contents)", "modifiers": "public static", "return": "void", "signature": "void append(StringBuilder target, StringOption contents)", "full_signature": "public static void append(StringBuilder target, StringOption contents)", "class_method_signature": "StringOptionUtil.append(StringBuilder target, StringOption contents)", "testcase": false, "constructor": false}, {"identifier": "parseInt", "parameters": "(StringOption contents)", "modifiers": "public static", "return": "int", "signature": "int parseInt(StringOption contents)", "full_signature": "public static int parseInt(StringOption contents)", "class_method_signature": "StringOptionUtil.parseInt(StringOption contents)", "testcase": false, "constructor": false}, {"identifier": "parseLong", "parameters": "(StringOption contents)", "modifiers": "public static", "return": "long", "signature": "long parseLong(StringOption contents)", "full_signature": "public static long parseLong(StringOption contents)", "class_method_signature": "StringOptionUtil.parseLong(StringOption contents)", "testcase": false, "constructor": false}, {"identifier": "parseDecimal", "parameters": "(StringOption contents)", "modifiers": "public static", "return": "BigDecimal", "signature": "BigDecimal parseDecimal(StringOption contents)", "full_signature": "public static BigDecimal parseDecimal(StringOption contents)", "class_method_signature": "StringOptionUtil.parseDecimal(StringOption contents)", "testcase": false, "constructor": false}, {"identifier": "invalidNumber", "parameters": "(StringOption contents)", "modifiers": "private static", "return": "NumberFormatException", "signature": "NumberFormatException invalidNumber(StringOption contents)", "full_signature": "private static NumberFormatException invalidNumber(StringOption contents)", "class_method_signature": "StringOptionUtil.invalidNumber(StringOption contents)", "testcase": false, "constructor": false}, {"identifier": "borrowCharArrayBuf", "parameters": "(int length)", "modifiers": "private static", "return": "char[]", "signature": "char[] borrowCharArrayBuf(int length)", "full_signature": "private static char[] borrowCharArrayBuf(int length)", "class_method_signature": "StringOptionUtil.borrowCharArrayBuf(int length)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(\n            CharBuffer source, StringOption destination,\n            CharsetEncoder encoder, ByteBuffer buffer)", "modifiers": "public static", "return": "void", "signature": "void append(\n            CharBuffer source, StringOption destination,\n            CharsetEncoder encoder, ByteBuffer buffer)", "full_signature": "public static void append(\n            CharBuffer source, StringOption destination,\n            CharsetEncoder encoder, ByteBuffer buffer)", "class_method_signature": "StringOptionUtil.append(\n            CharBuffer source, StringOption destination,\n            CharsetEncoder encoder, ByteBuffer buffer)", "testcase": false, "constructor": false}, {"identifier": "append0", "parameters": "(ByteBuffer buffer, Text text)", "modifiers": "private static", "return": "void", "signature": "void append0(ByteBuffer buffer, Text text)", "full_signature": "private static void append0(ByteBuffer buffer, Text text)", "class_method_signature": "StringOptionUtil.append0(ByteBuffer buffer, Text text)", "testcase": false, "constructor": false}], "file": "core-project/asakusa-runtime/src/main/java/com/asakusafw/runtime/value/StringOptionUtil.java"}, "focal_method": {"identifier": "parseLong", "parameters": "(StringOption contents)", "modifiers": "public static", "return": "long", "body": "public static long parseLong(StringOption contents) {\n        CharBuffer buffer = DECODER_POOL.get().decode(contents.get());\n        if (buffer.hasRemaining() == false) {\n            throw invalidNumber(contents);\n        }\n        boolean negative = false;\n        char first = buffer.get(0);\n        if (first < '0') {\n            if (first == '+') {\n                buffer.get();\n            } else if (first == '-') {\n                buffer.get();\n                negative = true;\n            }\n        }\n        long negativeResult = 0;\n        while (buffer.hasRemaining()) {\n            char c = buffer.get();\n            int column = Character.digit(c, 10);\n            if (column < 0) {\n                throw invalidNumber(contents);\n            }\n            // check overflow\n            if (negativeResult < (Long.MIN_VALUE / 10)) {\n                throw invalidNumber(contents);\n            }\n            negativeResult *= 10;\n            // check overflow\n            if (negativeResult < (Long.MIN_VALUE | column)) {\n                throw invalidNumber(contents);\n            }\n            negativeResult -= column;\n        }\n        if (negative) {\n            return negativeResult;\n        } else {\n            if (negativeResult == Long.MIN_VALUE) {\n                throw invalidNumber(contents);\n            }\n            return -negativeResult;\n        }\n    }", "signature": "long parseLong(StringOption contents)", "full_signature": "public static long parseLong(StringOption contents)", "class_method_signature": "StringOptionUtil.parseLong(StringOption contents)", "testcase": false, "constructor": false, "invocations": ["decode", "get", "get", "hasRemaining", "invalidNumber", "get", "get", "get", "hasRemaining", "get", "digit", "invalidNumber", "invalidNumber", "invalidNumber", "invalidNumber"]}, "repository": {"repo_id": 1545929, "url": "https://github.com/asakusafw/asakusafw", "language": "Java", "is_fork": false, "fork_count": 13, "stargazer_count": 113, "size": 35236, "license": "licensed"}}