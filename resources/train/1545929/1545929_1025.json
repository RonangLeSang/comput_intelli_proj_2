{"test_class": {"identifier": "ConcurrentBatchFileCacheRepositoryTest", "superclass": "extends FileCacheRepositoryTestRoot", "interfaces": "", "fields": [], "file": "core-project/asakusa-runtime/src/test/java/com/asakusafw/runtime/util/cache/ConcurrentBatchFileCacheRepositoryTest.java"}, "test_case": {"identifier": "multiple", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void multiple() throws Exception {\n        List<File> sources = new ArrayList<>();\n        List<Path> paths = new ArrayList<>();\n        for (int i = 0; i < 100; i++) {\n            File source = put(newFile(), String.format(\"hello%02d\", i));\n            sources.add(source);\n            paths.add(path(source));\n        }\n        Map<File, File> results;\n        ExecutorService executor = Executors.newFixedThreadPool(\n                Math.min(4, Runtime.getRuntime().availableProcessors()));\n        try {\n            BatchFileCacheRepository batch = new ConcurrentBatchFileCacheRepository(\n                    new MockFileCacheRepository(folder.newFolder()), executor);\n            results = files(batch.resolve(paths));\n        } finally {\n            executor.shutdown();\n        }\n        assertThat(results.size(), is(sources.size()));\n        for (File source : sources) {\n            File target = results.get(source);\n            assertThat(target, is(notNullValue()));\n            assertThat(get(target), is(get(source)));\n            assertThat(target, is(not(source)));\n        }\n    }", "signature": "void multiple()", "full_signature": "@Test public void multiple()", "class_method_signature": "ConcurrentBatchFileCacheRepositoryTest.multiple()", "testcase": true, "constructor": false, "invocations": ["put", "newFile", "format", "add", "add", "path", "newFixedThreadPool", "min", "availableProcessors", "getRuntime", "newFolder", "files", "resolve", "shutdown", "assertThat", "size", "is", "size", "get", "assertThat", "is", "notNullValue", "assertThat", "get", "is", "get", "assertThat", "is", "not"]}, "focal_class": {"identifier": "ConcurrentBatchFileCacheRepository", "superclass": "", "interfaces": "implements BatchFileCacheRepository", "fields": [{"original_string": "static final Log LOG = LogFactory.getLog(ConcurrentBatchFileCacheRepository.class);", "modifier": "static final", "type": "Log", "declarator": "LOG = LogFactory.getLog(ConcurrentBatchFileCacheRepository.class)", "var_name": "LOG"}, {"original_string": "private static final int CHECK_TIMEOUT = 100;", "modifier": "private static final", "type": "int", "declarator": "CHECK_TIMEOUT = 100", "var_name": "CHECK_TIMEOUT"}, {"original_string": "private final FileCacheRepository repository;", "modifier": "private final", "type": "FileCacheRepository", "declarator": "repository", "var_name": "repository"}, {"original_string": "private final ExecutorService executor;", "modifier": "private final", "type": "ExecutorService", "declarator": "executor", "var_name": "executor"}, {"original_string": "private final ExceptionHandler exceptionHandler;", "modifier": "private final", "type": "ExceptionHandler", "declarator": "exceptionHandler", "var_name": "exceptionHandler"}], "methods": [{"identifier": "ConcurrentBatchFileCacheRepository", "parameters": "(FileCacheRepository repository, ExecutorService executor)", "modifiers": "public", "return": "", "signature": " ConcurrentBatchFileCacheRepository(FileCacheRepository repository, ExecutorService executor)", "full_signature": "public  ConcurrentBatchFileCacheRepository(FileCacheRepository repository, ExecutorService executor)", "class_method_signature": "ConcurrentBatchFileCacheRepository.ConcurrentBatchFileCacheRepository(FileCacheRepository repository, ExecutorService executor)", "testcase": false, "constructor": true}, {"identifier": "ConcurrentBatchFileCacheRepository", "parameters": "(\n            FileCacheRepository repository,\n            ExecutorService executor,\n            ExceptionHandler exceptionHandler)", "modifiers": "public", "return": "", "signature": " ConcurrentBatchFileCacheRepository(\n            FileCacheRepository repository,\n            ExecutorService executor,\n            ExceptionHandler exceptionHandler)", "full_signature": "public  ConcurrentBatchFileCacheRepository(\n            FileCacheRepository repository,\n            ExecutorService executor,\n            ExceptionHandler exceptionHandler)", "class_method_signature": "ConcurrentBatchFileCacheRepository.ConcurrentBatchFileCacheRepository(\n            FileCacheRepository repository,\n            ExecutorService executor,\n            ExceptionHandler exceptionHandler)", "testcase": false, "constructor": true}, {"identifier": "resolve", "parameters": "(List<? extends Path> files)", "modifiers": "@Override public", "return": "Map<Path, Path>", "signature": "Map<Path, Path> resolve(List<? extends Path> files)", "full_signature": "@Override public Map<Path, Path> resolve(List<? extends Path> files)", "class_method_signature": "ConcurrentBatchFileCacheRepository.resolve(List<? extends Path> files)", "testcase": false, "constructor": false}, {"identifier": "handleException", "parameters": "(Path file, ExecutionException e)", "modifiers": "private", "return": "Path", "signature": "Path handleException(Path file, ExecutionException e)", "full_signature": "private Path handleException(Path file, ExecutionException e)", "class_method_signature": "ConcurrentBatchFileCacheRepository.handleException(Path file, ExecutionException e)", "testcase": false, "constructor": false}], "file": "core-project/asakusa-runtime/src/main/java/com/asakusafw/runtime/util/cache/ConcurrentBatchFileCacheRepository.java"}, "focal_method": {"identifier": "resolve", "parameters": "(List<? extends Path> files)", "modifiers": "@Override public", "return": "Map<Path, Path>", "body": "@Override\n    public Map<Path, Path> resolve(List<? extends Path> files) throws IOException, InterruptedException {\n        Map<Path, Future<Path>> futures = new LinkedHashMap<>();\n        Map<Path, Path> results = new HashMap<>();\n        for (Path file : files) {\n            if (futures.containsKey(file)) {\n                // skip same file\n                continue;\n            }\n            Future<Path> future = executor.submit(new Task(repository, file));\n            futures.put(file, future);\n            results.put(file, null);\n        }\n        try {\n            while (futures.isEmpty() == false) {\n                for (Path file : files) {\n                    Future<Path> future = futures.get(file);\n                    if (future == null) {\n                        continue;\n                    }\n                    try {\n                        Path result = future.get(CHECK_TIMEOUT, TimeUnit.MILLISECONDS);\n\n                        futures.remove(file);\n                        if (result != null) {\n                            results.put(file, result);\n                        }\n                    } catch (CancellationException e) {\n                        futures.remove(file);\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(MessageFormat.format(\n                                    \"Processing cache is cancelled: {0}\", //$NON-NLS-1$\n                                    file), e);\n                        }\n                    } catch (ExecutionException e) {\n                        futures.remove(file);\n                        Path result = handleException(file, e);\n                        if (result != null) {\n                            results.put(file, result);\n                        }\n                    } catch (TimeoutException e) {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(MessageFormat.format(\n                                    \"Trying to wait for next task complete: {0}\", //$NON-NLS-1$\n                                    file), e);\n                        }\n                    }\n                }\n            }\n        } finally {\n            for (Map.Entry<Path, Future<Path>> entry : futures.entrySet()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(MessageFormat.format(\n                            \"Request cancel for processing cache: {0}\", //$NON-NLS-1$\n                            entry.getKey()));\n                }\n                entry.getValue().cancel(true);\n            }\n        }\n        return results;\n    }", "signature": "Map<Path, Path> resolve(List<? extends Path> files)", "full_signature": "@Override public Map<Path, Path> resolve(List<? extends Path> files)", "class_method_signature": "ConcurrentBatchFileCacheRepository.resolve(List<? extends Path> files)", "testcase": false, "constructor": false, "invocations": ["containsKey", "submit", "put", "put", "isEmpty", "get", "get", "remove", "put", "remove", "isDebugEnabled", "debug", "format", "remove", "handleException", "put", "isTraceEnabled", "trace", "format", "entrySet", "isDebugEnabled", "debug", "format", "getKey", "cancel", "getValue"]}, "repository": {"repo_id": 1545929, "url": "https://github.com/asakusafw/asakusafw", "language": "Java", "is_fork": false, "fork_count": 13, "stargazer_count": 113, "size": 35236, "license": "licensed"}}