{"test_class": {"identifier": "JspellTagInterpreterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Map<String, Class> classTable = new HashMap<String, Class>();", "modifier": "private static", "type": "Map<String, Class>", "declarator": "classTable = new HashMap<String, Class>()", "var_name": "classTable"}, {"original_string": "private static Map<String, Number> numTable = new HashMap<String, Number>();", "modifier": "private static", "type": "Map<String, Number>", "declarator": "numTable = new HashMap<String, Number>()", "var_name": "numTable"}, {"original_string": "private static Map<String, Gender> genTable = new HashMap<String, Gender>();", "modifier": "private static", "type": "Map<String, Gender>", "declarator": "genTable = new HashMap<String, Gender>()", "var_name": "genTable"}, {"original_string": "private static Map<String, Person> persTable = new HashMap<String, Person>();", "modifier": "private static", "type": "Map<String, Person>", "declarator": "persTable = new HashMap<String, Person>()", "var_name": "persTable"}, {"original_string": "private static Map<String, Tense> tenseTable = new HashMap<String, Tense>();", "modifier": "private static", "type": "Map<String, Tense>", "declarator": "tenseTable = new HashMap<String, Tense>()", "var_name": "tenseTable"}, {"original_string": "private static Map<String, Case> caseTable = new HashMap<String, Case>();", "modifier": "private static", "type": "Map<String, Case>", "declarator": "caseTable = new HashMap<String, Case>()", "var_name": "caseTable"}, {"original_string": "private static Map<String, Mood> moodTable = new HashMap<String, Mood>();", "modifier": "private static", "type": "Map<String, Mood>", "declarator": "moodTable = new HashMap<String, Mood>()", "var_name": "moodTable"}, {"original_string": "private JspellTagInterpreter ti = new JspellTagInterpreter();", "modifier": "private", "type": "JspellTagInterpreter", "declarator": "ti = new JspellTagInterpreter()", "var_name": "ti"}], "file": "cogroo-gc/src/test/java/org/cogroo/interpreters/JspellTagInterpreterTest.java"}, "test_case": {"identifier": "testParseNumberTag", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testParseNumberTag() {\n\n    for (String tag : numTable.keySet()) {\n      assertEquals(\"Failed to parse num tag: \" + tag, numTable.get(tag), ti\n          .parseMorphologicalTag(tag).getNumberE());\n    }\n\n  }", "signature": "void testParseNumberTag()", "full_signature": "@Test public void testParseNumberTag()", "class_method_signature": "JspellTagInterpreterTest.testParseNumberTag()", "testcase": true, "constructor": false, "invocations": ["keySet", "assertEquals", "get", "getNumberE", "parseMorphologicalTag"]}, "focal_class": {"identifier": "JspellTagInterpreter", "superclass": "", "interfaces": "implements TagInterpreter", "fields": [{"original_string": "private static final Map<Enum<?>, String> ENUM_MTAG_PARTS;", "modifier": "private static final", "type": "Map<Enum<?>, String>", "declarator": "ENUM_MTAG_PARTS", "var_name": "ENUM_MTAG_PARTS"}, {"original_string": "private static final Map<String, List<Enum<?>>> MTAG_PARTS_ENUM;", "modifier": "private static final", "type": "Map<String, List<Enum<?>>>", "declarator": "MTAG_PARTS_ENUM", "var_name": "MTAG_PARTS_ENUM"}, {"original_string": "protected static final Logger LOGGER = Logger\n      .getLogger(JspellTagInterpreter.class);", "modifier": "protected static final", "type": "Logger", "declarator": "LOGGER = Logger\n      .getLogger(JspellTagInterpreter.class)", "var_name": "LOGGER"}, {"original_string": "private static final String SEP = \"\\\\|\";", "modifier": "private static final", "type": "String", "declarator": "SEP = \"\\\\|\"", "var_name": "SEP"}, {"original_string": "private static final List<String> MOOD_INDICATIVE;", "modifier": "private static final", "type": "List<String>", "declarator": "MOOD_INDICATIVE", "var_name": "MOOD_INDICATIVE"}, {"original_string": "private final Cache cache = new Cache(200);", "modifier": "private final", "type": "Cache", "declarator": "cache = new Cache(200)", "var_name": "cache"}], "methods": [{"identifier": "JspellTagInterpreter", "parameters": "()", "modifiers": "public", "return": "", "signature": " JspellTagInterpreter()", "full_signature": "public  JspellTagInterpreter()", "class_method_signature": "JspellTagInterpreter.JspellTagInterpreter()", "testcase": false, "constructor": true}, {"identifier": "parseMorphologicalTag", "parameters": "(String tagString)", "modifiers": "public", "return": "MorphologicalTag", "signature": "MorphologicalTag parseMorphologicalTag(String tagString)", "full_signature": "public MorphologicalTag parseMorphologicalTag(String tagString)", "class_method_signature": "JspellTagInterpreter.parseMorphologicalTag(String tagString)", "testcase": false, "constructor": false}, {"identifier": "removeInvalidFeatures", "parameters": "(MorphologicalTag m)", "modifiers": "private", "return": "void", "signature": "void removeInvalidFeatures(MorphologicalTag m)", "full_signature": "private void removeInvalidFeatures(MorphologicalTag m)", "class_method_signature": "JspellTagInterpreter.removeInvalidFeatures(MorphologicalTag m)", "testcase": false, "constructor": false}, {"identifier": "parseChunkTag", "parameters": "(String tagString)", "modifiers": "public", "return": "ChunkTag", "signature": "ChunkTag parseChunkTag(String tagString)", "full_signature": "public ChunkTag parseChunkTag(String tagString)", "class_method_signature": "JspellTagInterpreter.parseChunkTag(String tagString)", "testcase": false, "constructor": false}, {"identifier": "parseSyntacticTag", "parameters": "(String tagString)", "modifiers": "public", "return": "SyntacticTag", "signature": "SyntacticTag parseSyntacticTag(String tagString)", "full_signature": "public SyntacticTag parseSyntacticTag(String tagString)", "class_method_signature": "JspellTagInterpreter.parseSyntacticTag(String tagString)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(MorphologicalTag tag)", "modifiers": "public", "return": "String", "signature": "String serialize(MorphologicalTag tag)", "full_signature": "public String serialize(MorphologicalTag tag)", "class_method_signature": "JspellTagInterpreter.serialize(MorphologicalTag tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(ChunkTag tag)", "modifiers": "public", "return": "String", "signature": "String serialize(ChunkTag tag)", "full_signature": "public String serialize(ChunkTag tag)", "class_method_signature": "JspellTagInterpreter.serialize(ChunkTag tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(SyntacticTag tag)", "modifiers": "public", "return": "String", "signature": "String serialize(SyntacticTag tag)", "full_signature": "public String serialize(SyntacticTag tag)", "class_method_signature": "JspellTagInterpreter.serialize(SyntacticTag tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(SyntacticFunction tag)", "modifiers": "public", "return": "String", "signature": "String serialize(SyntacticFunction tag)", "full_signature": "public String serialize(SyntacticFunction tag)", "class_method_signature": "JspellTagInterpreter.serialize(SyntacticFunction tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(ChunkFunction tag)", "modifiers": "public", "return": "String", "signature": "String serialize(ChunkFunction tag)", "full_signature": "public String serialize(ChunkFunction tag)", "class_method_signature": "JspellTagInterpreter.serialize(ChunkFunction tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(Class tag)", "modifiers": "public", "return": "String", "signature": "String serialize(Class tag)", "full_signature": "public String serialize(Class tag)", "class_method_signature": "JspellTagInterpreter.serialize(Class tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(Gender tag)", "modifiers": "public", "return": "String", "signature": "String serialize(Gender tag)", "full_signature": "public String serialize(Gender tag)", "class_method_signature": "JspellTagInterpreter.serialize(Gender tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(Number tag)", "modifiers": "public", "return": "String", "signature": "String serialize(Number tag)", "full_signature": "public String serialize(Number tag)", "class_method_signature": "JspellTagInterpreter.serialize(Number tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(Case tag)", "modifiers": "public", "return": "String", "signature": "String serialize(Case tag)", "full_signature": "public String serialize(Case tag)", "class_method_signature": "JspellTagInterpreter.serialize(Case tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(Person tag)", "modifiers": "public", "return": "String", "signature": "String serialize(Person tag)", "full_signature": "public String serialize(Person tag)", "class_method_signature": "JspellTagInterpreter.serialize(Person tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(Tense tag)", "modifiers": "public", "return": "String", "signature": "String serialize(Tense tag)", "full_signature": "public String serialize(Tense tag)", "class_method_signature": "JspellTagInterpreter.serialize(Tense tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(Mood tag)", "modifiers": "public", "return": "String", "signature": "String serialize(Mood tag)", "full_signature": "public String serialize(Mood tag)", "class_method_signature": "JspellTagInterpreter.serialize(Mood tag)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "(Punctuation tag)", "modifiers": "public", "return": "String", "signature": "String serialize(Punctuation tag)", "full_signature": "public String serialize(Punctuation tag)", "class_method_signature": "JspellTagInterpreter.serialize(Punctuation tag)", "testcase": false, "constructor": false}, {"identifier": "serializer", "parameters": "(Enum<?> value)", "modifiers": "private", "return": "String", "signature": "String serializer(Enum<?> value)", "full_signature": "private String serializer(Enum<?> value)", "class_method_signature": "JspellTagInterpreter.serializer(Enum<?> value)", "testcase": false, "constructor": false}], "file": "cogroo-gc/src/main/java/org/cogroo/interpreters/JspellTagInterpreter.java"}, "focal_method": {"identifier": "parseMorphologicalTag", "parameters": "(String tagString)", "modifiers": "public", "return": "MorphologicalTag", "body": "public MorphologicalTag parseMorphologicalTag(String tagString) {\n\n    if (tagString == null) {\n      return null;\n    }\n\n    synchronized (cache) {\n      if (cache.containsKey(tagString)) {\n        return ((MorphologicalTag) cache.get(tagString)).clone();\n      }\n    }\n\n    MorphologicalTag m = new MorphologicalTag();\n\n    String[] tags = tagString.split(SEP);\n    for (String tag : tags) {\n      if (MTAG_PARTS_ENUM.containsKey(tag)) {\n        List<Enum<?>> tagE = MTAG_PARTS_ENUM.get(tag);\n        for (Enum<?> t : tagE) {\n          if (t instanceof Class) {\n            m.setClazz((Class) t);\n          } else if (t instanceof Gender) {\n            m.setGender((Gender) t);\n          } else if (t instanceof Number) {\n            m.setNumber((Number) t);\n          } else if (t instanceof Case) {\n            m.setCase((Case) t);\n          } else if (t instanceof Person) {\n            m.setPerson((Person) t);\n          } else if (t instanceof Tense) {\n            if (MOOD_INDICATIVE.contains(tag)) {\n              m.setMood(Mood.INDICATIVE);\n            }\n            m.setTense((Tense) t);\n          } else if (t instanceof Mood) {\n            m.setMood((Mood) t);\n          } else if (t instanceof Punctuation) {\n            m.setPunctuation((Punctuation) t);\n          }\n        }\n      } else {\n        if (tag.startsWith(\"CAT:\")) {\n          if (tag.startsWith(\"CAT:punct\")) {\n            m.setClazz(Class.PUNCTUATION_MARK);\n          } else if (\"CAT:v\".equals(tag) && m.getClazzE() == null) {\n            m.setClazz(Class.FINITIVE_VERB);\n          } else if (\"CAT:ppos\".equals(tag) || \"CAT:pind\".equals(tag)\n              || \"CAT:pdem\".equals(tag) || \"CAT:pint\".equals(tag)\n              || \"CAT:prel\".equals(tag)) {\n            m.setClazz(Class.PRONOUN);\n          } else if (\"CAT:card\".equals(tag) || \"CAT:nord\".equals(tag)) {\n            m.setClazz(Class.NUMERAL);\n          } else if (tag.startsWith(\"CAT:adj\")) {\n            m.setClazz(Class.ADJECTIVE);\n          } else if (\"CAT:cp\".equals(tag) || \"CAT:pass\".equals(tag)) {\n            return null; // ignore this tag\n          }\n        } else if (tag.startsWith(\"T:\")) {\n          if (MOOD_INDICATIVE.contains(tag)) {\n            m.setMood(Mood.INDICATIVE);\n          }\n          if ((Class.FINITIVE_VERB.equals(m.getClazzE()) || m.getClazzE() == null)) {\n            if (\"T:inf\".equals(tag) || \"T:ip\".equals(tag)) {\n              m.setClazz(Class.INFINITIVE_VERB);\n            } else if (\"T:ppa\".equals(tag)) {\n              m.setClazz(Class.PARTICIPLE_VERB);\n            } else if (\"T:g\".equals(tag)) {\n              m.setClazz(Class.GERUND_VERB);\n            }\n          }\n        }\n\n        else if (tag.length() == 1 || \"--\".equals(tag) || \"...\".equals(tag)) {\n          m.setClazz(Class.PUNCTUATION_MARK);\n        } else if (\"n:\".equals(tag)) {\n          m.setClazz(Class.NOUN);\n        } else if (\"intj\".equals(tag)) {\n          m.setClazz(Class.INTERJECTION);\n        } else if (\"pp\".equals(tag)) {\n          m.setClazz(Class.PREPOSITION);\n        } else if (\"np\".equals(tag)) {\n          m.setClazz(Class.NOUN);\n        } else {\n          System.out.println(tag);\n        }\n      }\n\n    }\n\n    if (m.toString() == null || m.toString().length() == 0) {\n      LOGGER.error(\"Invalid MorphologicalTag: \" + tagString);\n    }\n\n    // post process\n    if (m.getGenderE() == null && m.getNumberE() != null) {\n      if (Class.NOUN.equals(m.getClazzE())\n          || Class.NOUN_ADJECTIVE.equals(m.getClazzE())\n          || Class.NUMERAL.equals(m.getClazzE())) {\n        m.setGender(Gender.NEUTRAL);\n      } else if (Class.PROPER_NOUN.equals(m.getClazzE())) {\n        m.setGender(Gender.MALE);\n      }\n    }\n\n    if (m.getNumberE() == null && m.getGenderE() != null) {\n      if (Class.NOUN.equals(m.getClazzE())\n          || Class.NOUN_ADJECTIVE.equals(m.getClazzE())\n          || Class.NUMERAL.equals(m.getClazzE())) {\n        m.setNumber(Number.NEUTRAL);\n      } else if (Class.PROPER_NOUN.equals(m.getClazzE())) {\n        m.setNumber(Number.SINGULAR);\n      }\n    }\n\n    if (m.getTense() != null && Class.NOUN.equals(m.getClazzE())) {\n      m.setClazz(Class.INFINITIVE_VERB);\n    }\n    \n    if(m == null || m.getClazzE() == null) {\n      LOGGER.warn(\"something wrong with tag: \" + tagString);\n    }\n    removeInvalidFeatures(m);\n\n    synchronized (cache) {\n      if (!cache.containsKey(tagString)) {\n        cache.put(tagString, m.clone());\n      }\n    }\n\n    return m;\n  }", "signature": "MorphologicalTag parseMorphologicalTag(String tagString)", "full_signature": "public MorphologicalTag parseMorphologicalTag(String tagString)", "class_method_signature": "JspellTagInterpreter.parseMorphologicalTag(String tagString)", "testcase": false, "constructor": false, "invocations": ["containsKey", "clone", "get", "split", "containsKey", "get", "setClazz", "setGender", "setNumber", "setCase", "setPerson", "contains", "setMood", "setTense", "setMood", "setPunctuation", "startsWith", "startsWith", "setClazz", "equals", "getClazzE", "setClazz", "equals", "equals", "equals", "equals", "equals", "setClazz", "equals", "equals", "setClazz", "startsWith", "setClazz", "equals", "equals", "startsWith", "contains", "setMood", "equals", "getClazzE", "getClazzE", "equals", "equals", "setClazz", "equals", "setClazz", "equals", "setClazz", "length", "equals", "equals", "setClazz", "equals", "setClazz", "equals", "setClazz", "equals", "setClazz", "equals", "setClazz", "println", "toString", "length", "toString", "error", "getGenderE", "getNumberE", "equals", "getClazzE", "equals", "getClazzE", "equals", "getClazzE", "setGender", "equals", "getClazzE", "setGender", "getNumberE", "getGenderE", "equals", "getClazzE", "equals", "getClazzE", "equals", "getClazzE", "setNumber", "equals", "getClazzE", "setNumber", "getTense", "equals", "getClazzE", "setClazz", "getClazzE", "warn", "removeInvalidFeatures", "containsKey", "put", "clone"]}, "repository": {"repo_id": 4713292, "url": "https://github.com/cogroo/cogroo4", "language": "Java", "is_fork": false, "fork_count": 21, "stargazer_count": 46, "size": 37274, "license": "licensed"}}