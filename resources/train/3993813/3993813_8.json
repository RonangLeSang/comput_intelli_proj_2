{"test_class": {"identifier": "NioJournalFileRecordTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final UUID expectedDelimiter = UUID.randomUUID(), otherDelimiter = UUID.randomUUID();", "modifier": "static final", "type": "UUID", "declarator": "expectedDelimiter = UUID.randomUUID()", "var_name": "expectedDelimiter"}, {"original_string": "static Random random = new Random();", "modifier": "static", "type": "Random", "declarator": "random = new Random()", "var_name": "random"}, {"original_string": "NioJournalRecord payload = new NioJournalRecord(Status.STATUS_ACTIVE, generateUid(), new HashSet<String>(asList(\"a name\")));", "modifier": "", "type": "NioJournalRecord", "declarator": "payload = new NioJournalRecord(Status.STATUS_ACTIVE, generateUid(), new HashSet<String>(asList(\"a name\")))", "var_name": "payload"}, {"original_string": "byte[] payloadBytes;", "modifier": "", "type": "byte[]", "declarator": "payloadBytes", "var_name": "payloadBytes"}, {"original_string": "NioJournalFileRecord fileRecord;", "modifier": "", "type": "NioJournalFileRecord", "declarator": "fileRecord", "var_name": "fileRecord"}], "file": "btm-nio-journal/src/test/java/bitronix/tm/journal/nio/NioJournalFileRecordTest.java"}, "test_case": {"identifier": "testCannotCreateNegativeSizedPayload", "parameters": "()", "modifiers": "@Test(expected = IllegalArgumentException.class) public", "return": "void", "body": "@Test(expected = IllegalArgumentException.class)\n    public void testCannotCreateNegativeSizedPayload() throws Exception {\n        fileRecord.createEmptyPayload(-1);\n    }", "signature": "void testCannotCreateNegativeSizedPayload()", "full_signature": "@Test(expected = IllegalArgumentException.class) public void testCannotCreateNegativeSizedPayload()", "class_method_signature": "NioJournalFileRecordTest.testCannotCreateNegativeSizedPayload()", "testcase": true, "constructor": false, "invocations": ["createEmptyPayload"]}, "focal_class": {"identifier": "NioJournalFileRecord", "superclass": "", "interfaces": "implements NioJournalConstants", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(NioJournalFileRecord.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(NioJournalFileRecord.class)", "var_name": "log"}, {"original_string": "private static final byte[] RECORD_DELIMITER_PREFIX = nameBytes(\"\\r\\nLR[\");", "modifier": "private static final", "type": "byte[]", "declarator": "RECORD_DELIMITER_PREFIX = nameBytes(\"\\r\\nLR[\")", "var_name": "RECORD_DELIMITER_PREFIX"}, {"original_string": "private static final byte[] RECORD_DELIMITER_SUFFIX = nameBytes(\"][\");", "modifier": "private static final", "type": "byte[]", "declarator": "RECORD_DELIMITER_SUFFIX = nameBytes(\"][\")", "var_name": "RECORD_DELIMITER_SUFFIX"}, {"original_string": "private static final byte[] RECORD_DELIMITER_TRAILER = nameBytes(\"]-\");", "modifier": "private static final", "type": "byte[]", "declarator": "RECORD_DELIMITER_TRAILER = nameBytes(\"]-\")", "var_name": "RECORD_DELIMITER_TRAILER"}, {"original_string": "public static final int RECORD_LENGTH_OFFSET = RECORD_DELIMITER_PREFIX.length + 16;", "modifier": "public static final", "type": "int", "declarator": "RECORD_LENGTH_OFFSET = RECORD_DELIMITER_PREFIX.length + 16", "var_name": "RECORD_LENGTH_OFFSET"}, {"original_string": "public static final int RECORD_CRC32_OFFSET = RECORD_LENGTH_OFFSET + 4;", "modifier": "public static final", "type": "int", "declarator": "RECORD_CRC32_OFFSET = RECORD_LENGTH_OFFSET + 4", "var_name": "RECORD_CRC32_OFFSET"}, {"original_string": "public static final int RECORD_HEADER_SIZE =\n            /*                   prefix */ RECORD_DELIMITER_PREFIX.length +\n            /* opening delimiter (uuid) */ 16 +\n            /*                   length */ 4 +\n            /*                    crc32 */ 4 +\n            /*                   suffix */ RECORD_DELIMITER_SUFFIX.length;", "modifier": "public static final", "type": "int", "declarator": "RECORD_HEADER_SIZE =\n            /*                   prefix */ RECORD_DELIMITER_PREFIX.length +\n            /* opening delimiter (uuid) */ 16 +\n            /*                   length */ 4 +\n            /*                    crc32 */ 4 +\n            /*                   suffix */ RECORD_DELIMITER_SUFFIX.length", "var_name": "RECORD_HEADER_SIZE"}, {"original_string": "public static final int RECORD_TRAILER_SIZE =\n            /* closing delimiter (uuid) */ 16 +\n            /*           record trailer */ RECORD_DELIMITER_TRAILER.length;", "modifier": "public static final", "type": "int", "declarator": "RECORD_TRAILER_SIZE =\n            /* closing delimiter (uuid) */ 16 +\n            /*           record trailer */ RECORD_DELIMITER_TRAILER.length", "var_name": "RECORD_TRAILER_SIZE"}, {"original_string": "public static final int REVERSE_RECORD_CRC32_OFFSET = RECORD_CRC32_OFFSET - RECORD_HEADER_SIZE;", "modifier": "public static final", "type": "int", "declarator": "REVERSE_RECORD_CRC32_OFFSET = RECORD_CRC32_OFFSET - RECORD_HEADER_SIZE", "var_name": "REVERSE_RECORD_CRC32_OFFSET"}, {"original_string": "private static final boolean trace = log.isTraceEnabled();", "modifier": "private static final", "type": "boolean", "declarator": "trace = log.isTraceEnabled()", "var_name": "trace"}, {"original_string": "private UUID delimiter;", "modifier": "private", "type": "UUID", "declarator": "delimiter", "var_name": "delimiter"}, {"original_string": "private ByteBuffer payload, recordBuffer;", "modifier": "private", "type": "ByteBuffer", "declarator": "payload", "var_name": "payload"}, {"original_string": "private boolean valid = true;", "modifier": "private", "type": "boolean", "declarator": "valid = true", "var_name": "valid"}], "methods": [{"identifier": "bufferToString", "parameters": "(ByteBuffer buffer)", "modifiers": "public static", "return": "String", "signature": "String bufferToString(ByteBuffer buffer)", "full_signature": "public static String bufferToString(ByteBuffer buffer)", "class_method_signature": "NioJournalFileRecord.bufferToString(ByteBuffer buffer)", "testcase": false, "constructor": false}, {"identifier": "findNextRecord", "parameters": "(UUID delimiter, ByteBuffer source)", "modifiers": "public static", "return": "FindResult", "signature": "FindResult findNextRecord(UUID delimiter, ByteBuffer source)", "full_signature": "public static FindResult findNextRecord(UUID delimiter, ByteBuffer source)", "class_method_signature": "NioJournalFileRecord.findNextRecord(UUID delimiter, ByteBuffer source)", "testcase": false, "constructor": false}, {"identifier": "readRecord", "parameters": "(UUID delimiter, ByteBuffer source)", "modifiers": "public static", "return": "NioJournalFileRecord", "signature": "NioJournalFileRecord readRecord(UUID delimiter, ByteBuffer source)", "full_signature": "public static NioJournalFileRecord readRecord(UUID delimiter, ByteBuffer source)", "class_method_signature": "NioJournalFileRecord.readRecord(UUID delimiter, ByteBuffer source)", "testcase": false, "constructor": false}, {"identifier": "readRecords", "parameters": "(UUID delimiter, FileChannel channel, boolean includeInvalid)", "modifiers": "public static", "return": "Iterable<NioJournalFileRecord>", "signature": "Iterable<NioJournalFileRecord> readRecords(UUID delimiter, FileChannel channel, boolean includeInvalid)", "full_signature": "public static Iterable<NioJournalFileRecord> readRecords(UUID delimiter, FileChannel channel, boolean includeInvalid)", "class_method_signature": "NioJournalFileRecord.readRecords(UUID delimiter, FileChannel channel, boolean includeInvalid)", "testcase": false, "constructor": false}, {"identifier": "calculateRequiredBytes", "parameters": "(Collection<NioJournalFileRecord> records)", "modifiers": "public static", "return": "int", "signature": "int calculateRequiredBytes(Collection<NioJournalFileRecord> records)", "full_signature": "public static int calculateRequiredBytes(Collection<NioJournalFileRecord> records)", "class_method_signature": "NioJournalFileRecord.calculateRequiredBytes(Collection<NioJournalFileRecord> records)", "testcase": false, "constructor": false}, {"identifier": "disposeAll", "parameters": "(Collection<NioJournalFileRecord> records)", "modifiers": "public static", "return": "void", "signature": "void disposeAll(Collection<NioJournalFileRecord> records)", "full_signature": "public static void disposeAll(Collection<NioJournalFileRecord> records)", "class_method_signature": "NioJournalFileRecord.disposeAll(Collection<NioJournalFileRecord> records)", "testcase": false, "constructor": false}, {"identifier": "NioJournalFileRecord", "parameters": "(UUID delimiter)", "modifiers": "public", "return": "", "signature": " NioJournalFileRecord(UUID delimiter)", "full_signature": "public  NioJournalFileRecord(UUID delimiter)", "class_method_signature": "NioJournalFileRecord.NioJournalFileRecord(UUID delimiter)", "testcase": false, "constructor": true}, {"identifier": "NioJournalFileRecord", "parameters": "(UUID delimiter, ByteBuffer payload, int payloadCrc32)", "modifiers": "", "return": "", "signature": " NioJournalFileRecord(UUID delimiter, ByteBuffer payload, int payloadCrc32)", "full_signature": "  NioJournalFileRecord(UUID delimiter, ByteBuffer payload, int payloadCrc32)", "class_method_signature": "NioJournalFileRecord.NioJournalFileRecord(UUID delimiter, ByteBuffer payload, int payloadCrc32)", "testcase": false, "constructor": true}, {"identifier": "dispose", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void dispose()", "full_signature": "public void dispose()", "class_method_signature": "NioJournalFileRecord.dispose()", "testcase": false, "constructor": false}, {"identifier": "dispose", "parameters": "(final boolean recycle)", "modifiers": "", "return": "void", "signature": "void dispose(final boolean recycle)", "full_signature": " void dispose(final boolean recycle)", "class_method_signature": "NioJournalFileRecord.dispose(final boolean recycle)", "testcase": false, "constructor": false}, {"identifier": "createEmptyPayload", "parameters": "(int payloadSize)", "modifiers": "public", "return": "ByteBuffer", "signature": "ByteBuffer createEmptyPayload(int payloadSize)", "full_signature": "public ByteBuffer createEmptyPayload(int payloadSize)", "class_method_signature": "NioJournalFileRecord.createEmptyPayload(int payloadSize)", "testcase": false, "constructor": false}, {"identifier": "writeRecord", "parameters": "(UUID targetDelimiter, ByteBuffer target)", "modifiers": "public", "return": "void", "signature": "void writeRecord(UUID targetDelimiter, ByteBuffer target)", "full_signature": "public void writeRecord(UUID targetDelimiter, ByteBuffer target)", "class_method_signature": "NioJournalFileRecord.writeRecord(UUID targetDelimiter, ByteBuffer target)", "testcase": false, "constructor": false}, {"identifier": "calculateCrc32", "parameters": "()", "modifiers": "", "return": "int", "signature": "int calculateCrc32()", "full_signature": " int calculateCrc32()", "class_method_signature": "NioJournalFileRecord.calculateCrc32()", "testcase": false, "constructor": false}, {"identifier": "getRecordSize", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getRecordSize()", "full_signature": "public int getRecordSize()", "class_method_signature": "NioJournalFileRecord.getRecordSize()", "testcase": false, "constructor": false}, {"identifier": "getPayload", "parameters": "()", "modifiers": "public", "return": "ByteBuffer", "signature": "ByteBuffer getPayload()", "full_signature": "public ByteBuffer getPayload()", "class_method_signature": "NioJournalFileRecord.getPayload()", "testcase": false, "constructor": false}, {"identifier": "getDelimiter", "parameters": "()", "modifiers": "public", "return": "UUID", "signature": "UUID getDelimiter()", "full_signature": "public UUID getDelimiter()", "class_method_signature": "NioJournalFileRecord.getDelimiter()", "testcase": false, "constructor": false}, {"identifier": "isValid", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isValid()", "full_signature": "public boolean isValid()", "class_method_signature": "NioJournalFileRecord.isValid()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "NioJournalFileRecord.toString()", "testcase": false, "constructor": false}, {"identifier": "writeUUID", "parameters": "(UUID source, ByteBuffer target)", "modifiers": "static", "return": "void", "signature": "void writeUUID(UUID source, ByteBuffer target)", "full_signature": "static void writeUUID(UUID source, ByteBuffer target)", "class_method_signature": "NioJournalFileRecord.writeUUID(UUID source, ByteBuffer target)", "testcase": false, "constructor": false}, {"identifier": "readUUID", "parameters": "(ByteBuffer buffer)", "modifiers": "static", "return": "UUID", "signature": "UUID readUUID(ByteBuffer buffer)", "full_signature": "static UUID readUUID(ByteBuffer buffer)", "class_method_signature": "NioJournalFileRecord.readUUID(ByteBuffer buffer)", "testcase": false, "constructor": false}, {"identifier": "writeRecordHeaderFor", "parameters": "(int payloadSize, UUID delimiter, ByteBuffer target)", "modifiers": "private static", "return": "void", "signature": "void writeRecordHeaderFor(int payloadSize, UUID delimiter, ByteBuffer target)", "full_signature": "private static void writeRecordHeaderFor(int payloadSize, UUID delimiter, ByteBuffer target)", "class_method_signature": "NioJournalFileRecord.writeRecordHeaderFor(int payloadSize, UUID delimiter, ByteBuffer target)", "testcase": false, "constructor": false}, {"identifier": "writeRecordTrailerFor", "parameters": "(UUID delimiter, ByteBuffer target)", "modifiers": "private static", "return": "void", "signature": "void writeRecordTrailerFor(UUID delimiter, ByteBuffer target)", "full_signature": "private static void writeRecordTrailerFor(UUID delimiter, ByteBuffer target)", "class_method_signature": "NioJournalFileRecord.writeRecordTrailerFor(UUID delimiter, ByteBuffer target)", "testcase": false, "constructor": false}, {"identifier": "readRecordHeader", "parameters": "(ByteBuffer source, UUID delimiter)", "modifiers": "private static", "return": "int", "signature": "int readRecordHeader(ByteBuffer source, UUID delimiter)", "full_signature": "private static int readRecordHeader(ByteBuffer source, UUID delimiter)", "class_method_signature": "NioJournalFileRecord.readRecordHeader(ByteBuffer source, UUID delimiter)", "testcase": false, "constructor": false}, {"identifier": "extractCrc32FromRecord", "parameters": "(ByteBuffer sourceAtPayloadPosition)", "modifiers": "private static", "return": "int", "signature": "int extractCrc32FromRecord(ByteBuffer sourceAtPayloadPosition)", "full_signature": "private static int extractCrc32FromRecord(ByteBuffer sourceAtPayloadPosition)", "class_method_signature": "NioJournalFileRecord.extractCrc32FromRecord(ByteBuffer sourceAtPayloadPosition)", "testcase": false, "constructor": false}, {"identifier": "bufferContainsSequence", "parameters": "(final ByteBuffer source, final byte[] sequence)", "modifiers": "private static", "return": "int", "signature": "int bufferContainsSequence(final ByteBuffer source, final byte[] sequence)", "full_signature": "private static int bufferContainsSequence(final ByteBuffer source, final byte[] sequence)", "class_method_signature": "NioJournalFileRecord.bufferContainsSequence(final ByteBuffer source, final byte[] sequence)", "testcase": false, "constructor": false}], "file": "btm-nio-journal/src/main/java/bitronix/tm/journal/nio/NioJournalFileRecord.java"}, "focal_method": {"identifier": "createEmptyPayload", "parameters": "(int payloadSize)", "modifiers": "public", "return": "ByteBuffer", "body": "public ByteBuffer createEmptyPayload(int payloadSize) {\n        if (payloadSize < 0)\n            throw new IllegalArgumentException(\"Cannot specify a negative capacity when creating the payload.\");\n\n        final int requiredCapacity = payloadSize + RECORD_HEADER_SIZE + RECORD_TRAILER_SIZE;\n\n        if (requiredCapacity > JOURNAL_MAX_RECORD_SIZE) {\n            throw new IllegalArgumentException(\"Exceeding the maximum allowed record size of \" +\n                    JOURNAL_MAX_RECORD_SIZE + \" bytes. Requested a size of \" + requiredCapacity);\n        }\n\n        recordBuffer = NioBufferPool.getInstance().poll(requiredCapacity);\n\n        writeRecordHeaderFor(payloadSize, delimiter, recordBuffer);\n        payload = (ByteBuffer) recordBuffer.slice().limit(payloadSize);\n        writeRecordTrailerFor(delimiter, (ByteBuffer) recordBuffer.position(recordBuffer.position() + payloadSize));\n\n        recordBuffer.flip();\n\n        return payload.duplicate();\n    }", "signature": "ByteBuffer createEmptyPayload(int payloadSize)", "full_signature": "public ByteBuffer createEmptyPayload(int payloadSize)", "class_method_signature": "NioJournalFileRecord.createEmptyPayload(int payloadSize)", "testcase": false, "constructor": false, "invocations": ["poll", "getInstance", "writeRecordHeaderFor", "limit", "slice", "writeRecordTrailerFor", "position", "position", "flip", "duplicate"]}, "repository": {"repo_id": 3993813, "url": "https://github.com/brettwooldridge/bitronix-hp", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 14, "size": 6272, "license": "licensed"}}