{"test_class": {"identifier": "SuperficialValidationTest", "superclass": "", "interfaces": "", "fields": [], "file": "common/src/test/java/com/google/auto/common/SuperficialValidationTest.java"}, "test_case": {"identifier": "handlesRecursiveType", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void handlesRecursiveType() {\n    JavaFileObject javaFileObject = JavaFileObjects.forSourceLines(\n        \"test.TestClass\",\n        \"package test;\",\n        \"\",\n        \"abstract class TestClass {\",\n        \"  abstract TestClass foo(TestClass x);\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(javaFileObject)\n        .processedWith(new AssertingProcessor() {\n          @Override void runAssertions() {\n            TypeElement testClassElement =\n                processingEnv.getElementUtils().getTypeElement(\"test.TestClass\");\n            assertThat(SuperficialValidation.validateElement(testClassElement)).isTrue();\n          }\n        })\n        .compilesWithoutError();\n  }", "signature": "void handlesRecursiveType()", "full_signature": "@Test public void handlesRecursiveType()", "class_method_signature": "SuperficialValidationTest.handlesRecursiveType()", "testcase": true, "constructor": false, "invocations": ["forSourceLines", "compilesWithoutError", "processedWith", "that", "assertAbout", "javaSource", "getTypeElement", "getElementUtils", "isTrue", "assertThat", "validateElement"]}, "focal_class": {"identifier": "SuperficialValidation", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final ElementVisitor<Boolean, Void> ELEMENT_VALIDATING_VISITOR =\n      new AbstractElementVisitor8<Boolean, Void>() {\n        @Override public Boolean visitPackage(PackageElement e, Void p) {\n          // don't validate enclosed elements because it will return types in the package\n          return validateAnnotations(e.getAnnotationMirrors());\n        }\n\n        @Override public Boolean visitType(TypeElement e, Void p) {\n          return isValidBaseElement(e)\n              && validateElements(e.getTypeParameters())\n              && validateTypes(e.getInterfaces())\n              && validateType(e.getSuperclass());\n        }\n\n        @Override public Boolean visitVariable(VariableElement e, Void p) {\n          return isValidBaseElement(e);\n        }\n\n        @Override public Boolean visitExecutable(ExecutableElement e, Void p) {\n          AnnotationValue defaultValue = e.getDefaultValue();\n          return isValidBaseElement(e)\n              && (defaultValue == null || validateAnnotationValue(defaultValue, e.getReturnType()))\n              && validateType(e.getReturnType())\n              && validateTypes(e.getThrownTypes())\n              && validateElements(e.getTypeParameters())\n              && validateElements(e.getParameters());\n        }\n\n        @Override public Boolean visitTypeParameter(TypeParameterElement e, Void p) {\n          return isValidBaseElement(e)\n              && validateTypes(e.getBounds());\n        }\n\n        @Override public Boolean visitUnknown(Element e, Void p) {\n          // just assume that unknown elements are OK\n          return true;\n        }\n      };", "modifier": "private static final", "type": "ElementVisitor<Boolean, Void>", "declarator": "ELEMENT_VALIDATING_VISITOR =\n      new AbstractElementVisitor8<Boolean, Void>() {\n        @Override public Boolean visitPackage(PackageElement e, Void p) {\n          // don't validate enclosed elements because it will return types in the package\n          return validateAnnotations(e.getAnnotationMirrors());\n        }\n\n        @Override public Boolean visitType(TypeElement e, Void p) {\n          return isValidBaseElement(e)\n              && validateElements(e.getTypeParameters())\n              && validateTypes(e.getInterfaces())\n              && validateType(e.getSuperclass());\n        }\n\n        @Override public Boolean visitVariable(VariableElement e, Void p) {\n          return isValidBaseElement(e);\n        }\n\n        @Override public Boolean visitExecutable(ExecutableElement e, Void p) {\n          AnnotationValue defaultValue = e.getDefaultValue();\n          return isValidBaseElement(e)\n              && (defaultValue == null || validateAnnotationValue(defaultValue, e.getReturnType()))\n              && validateType(e.getReturnType())\n              && validateTypes(e.getThrownTypes())\n              && validateElements(e.getTypeParameters())\n              && validateElements(e.getParameters());\n        }\n\n        @Override public Boolean visitTypeParameter(TypeParameterElement e, Void p) {\n          return isValidBaseElement(e)\n              && validateTypes(e.getBounds());\n        }\n\n        @Override public Boolean visitUnknown(Element e, Void p) {\n          // just assume that unknown elements are OK\n          return true;\n        }\n      }", "var_name": "ELEMENT_VALIDATING_VISITOR"}, {"original_string": "private static final TypeVisitor<Boolean, Void> TYPE_VALIDATING_VISITOR =\n      new SimpleTypeVisitor8<Boolean, Void>() {\n        @Override\n        protected Boolean defaultAction(TypeMirror t, Void p) {\n          return true;\n        }\n\n        @Override\n        public Boolean visitArray(ArrayType t, Void p) {\n          return validateType(t.getComponentType());\n        }\n\n        @Override\n        public Boolean visitDeclared(DeclaredType t, Void p) {\n          return validateTypes(t.getTypeArguments());\n        }\n\n        @Override\n        public Boolean visitError(ErrorType t, Void p) {\n          return false;\n        }\n\n        @Override\n        public Boolean visitUnknown(TypeMirror t, Void p) {\n          // just make the default choice for unknown types\n          return defaultAction(t, p);\n        }\n\n        @Override\n        public Boolean visitWildcard(WildcardType t, Void p) {\n          TypeMirror extendsBound = t.getExtendsBound();\n          TypeMirror superBound = t.getSuperBound();\n          return (extendsBound == null || validateType(extendsBound))\n              && (superBound == null || validateType(superBound));\n        }\n\n        @Override\n        public Boolean visitExecutable(ExecutableType t, Void p) {\n          return validateTypes(t.getParameterTypes())\n              && validateType(t.getReturnType())\n              && validateTypes(t.getThrownTypes())\n              && validateTypes(t.getTypeVariables());\n        }\n      };", "modifier": "private static final", "type": "TypeVisitor<Boolean, Void>", "declarator": "TYPE_VALIDATING_VISITOR =\n      new SimpleTypeVisitor8<Boolean, Void>() {\n        @Override\n        protected Boolean defaultAction(TypeMirror t, Void p) {\n          return true;\n        }\n\n        @Override\n        public Boolean visitArray(ArrayType t, Void p) {\n          return validateType(t.getComponentType());\n        }\n\n        @Override\n        public Boolean visitDeclared(DeclaredType t, Void p) {\n          return validateTypes(t.getTypeArguments());\n        }\n\n        @Override\n        public Boolean visitError(ErrorType t, Void p) {\n          return false;\n        }\n\n        @Override\n        public Boolean visitUnknown(TypeMirror t, Void p) {\n          // just make the default choice for unknown types\n          return defaultAction(t, p);\n        }\n\n        @Override\n        public Boolean visitWildcard(WildcardType t, Void p) {\n          TypeMirror extendsBound = t.getExtendsBound();\n          TypeMirror superBound = t.getSuperBound();\n          return (extendsBound == null || validateType(extendsBound))\n              && (superBound == null || validateType(superBound));\n        }\n\n        @Override\n        public Boolean visitExecutable(ExecutableType t, Void p) {\n          return validateTypes(t.getParameterTypes())\n              && validateType(t.getReturnType())\n              && validateTypes(t.getThrownTypes())\n              && validateTypes(t.getTypeVariables());\n        }\n      }", "var_name": "TYPE_VALIDATING_VISITOR"}, {"original_string": "private static final AnnotationValueVisitor<Boolean, TypeMirror> VALUE_VALIDATING_VISITOR =\n      new SimpleAnnotationValueVisitor8<Boolean, TypeMirror>() {\n        @Override protected Boolean defaultAction(Object o, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(o.getClass(), expectedType);\n        }\n\n        @Override public Boolean visitUnknown(AnnotationValue av, TypeMirror expectedType) {\n          // just take the default action for the unknown\n          return defaultAction(av, expectedType);\n        }\n\n        @Override public Boolean visitAnnotation(AnnotationMirror a, TypeMirror expectedType) {\n          return MoreTypes.equivalence().equivalent(a.getAnnotationType(), expectedType)\n              && validateAnnotation(a);\n        }\n\n        @Override\n        public Boolean visitArray(List<? extends AnnotationValue> values, TypeMirror expectedType) {\n          if (!expectedType.getKind().equals(TypeKind.ARRAY)) {\n            return false;\n          }\n          TypeMirror componentType = MoreTypes.asArray(expectedType).getComponentType();\n          return values.stream().allMatch(value -> value.accept(this, componentType));\n        }\n\n        @Override\n        public Boolean visitEnumConstant(VariableElement enumConstant, TypeMirror expectedType) {\n          return MoreTypes.equivalence().equivalent(enumConstant.asType(), expectedType)\n              && validateElement(enumConstant);\n        }\n\n        @Override public Boolean visitType(TypeMirror type, TypeMirror ignored) {\n          // We could check assignability here, but would require a Types instance. Since this\n          // isn't really the sort of thing that shows up in a bad AST from upstream compilation\n          // we ignore the expected type and just validate the type.  It might be wrong, but\n          // it's valid.\n          return validateType(type);\n        }\n\n        @Override public Boolean visitBoolean(boolean b, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Boolean.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitByte(byte b, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Byte.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitChar(char c, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Character.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitDouble(double d, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Double.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitFloat(float f, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Float.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitInt(int i, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Integer.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitLong(long l, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Long.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitShort(short s, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Short.TYPE, expectedType);\n        }\n      };", "modifier": "private static final", "type": "AnnotationValueVisitor<Boolean, TypeMirror>", "declarator": "VALUE_VALIDATING_VISITOR =\n      new SimpleAnnotationValueVisitor8<Boolean, TypeMirror>() {\n        @Override protected Boolean defaultAction(Object o, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(o.getClass(), expectedType);\n        }\n\n        @Override public Boolean visitUnknown(AnnotationValue av, TypeMirror expectedType) {\n          // just take the default action for the unknown\n          return defaultAction(av, expectedType);\n        }\n\n        @Override public Boolean visitAnnotation(AnnotationMirror a, TypeMirror expectedType) {\n          return MoreTypes.equivalence().equivalent(a.getAnnotationType(), expectedType)\n              && validateAnnotation(a);\n        }\n\n        @Override\n        public Boolean visitArray(List<? extends AnnotationValue> values, TypeMirror expectedType) {\n          if (!expectedType.getKind().equals(TypeKind.ARRAY)) {\n            return false;\n          }\n          TypeMirror componentType = MoreTypes.asArray(expectedType).getComponentType();\n          return values.stream().allMatch(value -> value.accept(this, componentType));\n        }\n\n        @Override\n        public Boolean visitEnumConstant(VariableElement enumConstant, TypeMirror expectedType) {\n          return MoreTypes.equivalence().equivalent(enumConstant.asType(), expectedType)\n              && validateElement(enumConstant);\n        }\n\n        @Override public Boolean visitType(TypeMirror type, TypeMirror ignored) {\n          // We could check assignability here, but would require a Types instance. Since this\n          // isn't really the sort of thing that shows up in a bad AST from upstream compilation\n          // we ignore the expected type and just validate the type.  It might be wrong, but\n          // it's valid.\n          return validateType(type);\n        }\n\n        @Override public Boolean visitBoolean(boolean b, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Boolean.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitByte(byte b, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Byte.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitChar(char c, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Character.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitDouble(double d, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Double.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitFloat(float f, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Float.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitInt(int i, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Integer.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitLong(long l, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Long.TYPE, expectedType);\n        }\n\n        @Override public Boolean visitShort(short s, TypeMirror expectedType) {\n          return MoreTypes.isTypeOf(Short.TYPE, expectedType);\n        }\n      }", "var_name": "VALUE_VALIDATING_VISITOR"}], "methods": [{"identifier": "validateElements", "parameters": "(Iterable<? extends Element> elements)", "modifiers": "public static", "return": "boolean", "signature": "boolean validateElements(Iterable<? extends Element> elements)", "full_signature": "public static boolean validateElements(Iterable<? extends Element> elements)", "class_method_signature": "SuperficialValidation.validateElements(Iterable<? extends Element> elements)", "testcase": false, "constructor": false}, {"identifier": "validateElement", "parameters": "(Element element)", "modifiers": "public static", "return": "boolean", "signature": "boolean validateElement(Element element)", "full_signature": "public static boolean validateElement(Element element)", "class_method_signature": "SuperficialValidation.validateElement(Element element)", "testcase": false, "constructor": false}, {"identifier": "isValidBaseElement", "parameters": "(Element e)", "modifiers": "private static", "return": "boolean", "signature": "boolean isValidBaseElement(Element e)", "full_signature": "private static boolean isValidBaseElement(Element e)", "class_method_signature": "SuperficialValidation.isValidBaseElement(Element e)", "testcase": false, "constructor": false}, {"identifier": "validateTypes", "parameters": "(Iterable<? extends TypeMirror> types)", "modifiers": "private static", "return": "boolean", "signature": "boolean validateTypes(Iterable<? extends TypeMirror> types)", "full_signature": "private static boolean validateTypes(Iterable<? extends TypeMirror> types)", "class_method_signature": "SuperficialValidation.validateTypes(Iterable<? extends TypeMirror> types)", "testcase": false, "constructor": false}, {"identifier": "validateType", "parameters": "(TypeMirror type)", "modifiers": "public static", "return": "boolean", "signature": "boolean validateType(TypeMirror type)", "full_signature": "public static boolean validateType(TypeMirror type)", "class_method_signature": "SuperficialValidation.validateType(TypeMirror type)", "testcase": false, "constructor": false}, {"identifier": "validateAnnotations", "parameters": "(\n      Iterable<? extends AnnotationMirror> annotationMirrors)", "modifiers": "private static", "return": "boolean", "signature": "boolean validateAnnotations(\n      Iterable<? extends AnnotationMirror> annotationMirrors)", "full_signature": "private static boolean validateAnnotations(\n      Iterable<? extends AnnotationMirror> annotationMirrors)", "class_method_signature": "SuperficialValidation.validateAnnotations(\n      Iterable<? extends AnnotationMirror> annotationMirrors)", "testcase": false, "constructor": false}, {"identifier": "validateAnnotation", "parameters": "(AnnotationMirror annotationMirror)", "modifiers": "private static", "return": "boolean", "signature": "boolean validateAnnotation(AnnotationMirror annotationMirror)", "full_signature": "private static boolean validateAnnotation(AnnotationMirror annotationMirror)", "class_method_signature": "SuperficialValidation.validateAnnotation(AnnotationMirror annotationMirror)", "testcase": false, "constructor": false}, {"identifier": "validateAnnotationValues", "parameters": "(\n      Map<? extends ExecutableElement, ? extends AnnotationValue> valueMap)", "modifiers": "private static", "return": "boolean", "signature": "boolean validateAnnotationValues(\n      Map<? extends ExecutableElement, ? extends AnnotationValue> valueMap)", "full_signature": "private static boolean validateAnnotationValues(\n      Map<? extends ExecutableElement, ? extends AnnotationValue> valueMap)", "class_method_signature": "SuperficialValidation.validateAnnotationValues(\n      Map<? extends ExecutableElement, ? extends AnnotationValue> valueMap)", "testcase": false, "constructor": false}, {"identifier": "validateAnnotationValue", "parameters": "(\n      AnnotationValue annotationValue, TypeMirror expectedType)", "modifiers": "private static", "return": "boolean", "signature": "boolean validateAnnotationValue(\n      AnnotationValue annotationValue, TypeMirror expectedType)", "full_signature": "private static boolean validateAnnotationValue(\n      AnnotationValue annotationValue, TypeMirror expectedType)", "class_method_signature": "SuperficialValidation.validateAnnotationValue(\n      AnnotationValue annotationValue, TypeMirror expectedType)", "testcase": false, "constructor": false}, {"identifier": "SuperficialValidation", "parameters": "()", "modifiers": "private", "return": "", "signature": " SuperficialValidation()", "full_signature": "private  SuperficialValidation()", "class_method_signature": "SuperficialValidation.SuperficialValidation()", "testcase": false, "constructor": true}], "file": "common/src/main/java/com/google/auto/common/SuperficialValidation.java"}, "focal_method": {"identifier": "validateElement", "parameters": "(Element element)", "modifiers": "public static", "return": "boolean", "body": "public static boolean validateElement(Element element) {\n    return element.accept(ELEMENT_VALIDATING_VISITOR, null);\n  }", "signature": "boolean validateElement(Element element)", "full_signature": "public static boolean validateElement(Element element)", "class_method_signature": "SuperficialValidation.validateElement(Element element)", "testcase": false, "constructor": false, "invocations": ["accept"]}, "repository": {"repo_id": 10230369, "url": "https://github.com/google/auto", "stars": 8408, "created": "5/22/2013 9:41:56 PM +00:00", "updates": "2020-01-27T16:25:00+00:00", "fork": "False", "license": "licensed"}}