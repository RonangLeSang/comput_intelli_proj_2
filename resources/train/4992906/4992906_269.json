{"test_class": {"identifier": "SaxonXPathRuleQueryTest", "superclass": "", "interfaces": "", "fields": [], "file": "pmd-core/src/test/java/net/sourceforge/pmd/lang/rule/xpath/SaxonXPathRuleQueryTest.java"}, "test_case": {"identifier": "ruleChainVisitsUnboundedPathExpressions", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void ruleChainVisitsUnboundedPathExpressions() {\n        SaxonXPathRuleQuery query = createQuery(\"//dummyNode[//ClassOrInterfaceType]\");\n        List<String> ruleChainVisits = query.getRuleChainVisits();\n        Assert.assertEquals(0, ruleChainVisits.size());\n        Assert.assertEquals(1, query.nodeNameToXPaths.size());\n        assertExpression(\"LetExpression(LazyExpression(((/)/descendant::element(ClassOrInterfaceType, xs:anyType))), (((/)/descendant::element(dummyNode, xs:anyType))[$zz:zz771775563]))\", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));\n\n        // second sample, more complex\n        query = createQuery(\"//dummyNode[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType]]\");\n        ruleChainVisits = query.getRuleChainVisits();\n        Assert.assertEquals(0, ruleChainVisits.size());\n        Assert.assertEquals(1, query.nodeNameToXPaths.size());\n        assertExpression(\"LetExpression(LazyExpression(((/)/descendant::element(ClassOrInterfaceType, xs:anyType))), (((/)/descendant::element(dummyNode, xs:anyType))[(ancestor::element(ClassOrInterfaceDeclaration, xs:anyType)[$zz:zz106374177])]))\", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));\n\n        // third example, with boolean expr\n        query = createQuery(\"//dummyNode[//ClassOrInterfaceType or //OtherNode]\");\n        ruleChainVisits = query.getRuleChainVisits();\n        Assert.assertEquals(0, ruleChainVisits.size());\n        Assert.assertEquals(1, query.nodeNameToXPaths.size());\n        assertExpression(\"LetExpression(LazyExpression((((/)/descendant::element(ClassOrInterfaceType, xs:anyType)) or ((/)/descendant::element(OtherNode, xs:anyType)))), (((/)/descendant::element(dummyNode, xs:anyType))[$zz:zz1364913072]))\", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));\n    }", "signature": "void ruleChainVisitsUnboundedPathExpressions()", "full_signature": "@Test public void ruleChainVisitsUnboundedPathExpressions()", "class_method_signature": "SaxonXPathRuleQueryTest.ruleChainVisitsUnboundedPathExpressions()", "testcase": true, "constructor": false, "invocations": ["createQuery", "getRuleChainVisits", "assertEquals", "size", "assertEquals", "size", "assertExpression", "get", "get", "createQuery", "getRuleChainVisits", "assertEquals", "size", "assertEquals", "size", "assertExpression", "get", "get", "createQuery", "getRuleChainVisits", "assertEquals", "size", "assertEquals", "size", "assertExpression", "get", "get"]}, "focal_class": {"identifier": "SaxonXPathRuleQuery", "superclass": "extends AbstractXPathRuleQuery", "interfaces": "", "fields": [{"original_string": "static final String AST_ROOT = \"_AST_ROOT_\";", "modifier": "static final", "type": "String", "declarator": "AST_ROOT = \"_AST_ROOT_\"", "var_name": "AST_ROOT"}, {"original_string": "private static final Logger LOG = Logger.getLogger(SaxonXPathRuleQuery.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(SaxonXPathRuleQuery.class.getName())", "var_name": "LOG"}, {"original_string": "private static final NamePool NAME_POOL = new NamePool();", "modifier": "private static final", "type": "NamePool", "declarator": "NAME_POOL = new NamePool()", "var_name": "NAME_POOL"}, {"original_string": "private static final SimpleDataKey<DocumentNode> SAXON_TREE_CACHE_KEY = DataMap.simpleDataKey(\"saxon.tree\");", "modifier": "private static final", "type": "SimpleDataKey<DocumentNode>", "declarator": "SAXON_TREE_CACHE_KEY = DataMap.simpleDataKey(\"saxon.tree\")", "var_name": "SAXON_TREE_CACHE_KEY"}, {"original_string": "Map<String, List<Expression>> nodeNameToXPaths = new HashMap<>();", "modifier": "", "type": "Map<String, List<Expression>>", "declarator": "nodeNameToXPaths = new HashMap<>()", "var_name": "nodeNameToXPaths"}, {"original_string": "XPathExpression xpathExpression;", "modifier": "", "type": "XPathExpression", "declarator": "xpathExpression", "var_name": "xpathExpression"}, {"original_string": "private List<XPathVariable> xpathVariables;", "modifier": "private", "type": "List<XPathVariable>", "declarator": "xpathVariables", "var_name": "xpathVariables"}, {"original_string": "private final DeprecatedAttrLogger attrCtx;", "modifier": "private final", "type": "DeprecatedAttrLogger", "declarator": "attrCtx", "var_name": "attrCtx"}], "methods": [{"identifier": "SaxonXPathRuleQuery", "parameters": "()", "modifiers": "@Deprecated public", "return": "", "signature": " SaxonXPathRuleQuery()", "full_signature": "@Deprecated public  SaxonXPathRuleQuery()", "class_method_signature": "SaxonXPathRuleQuery.SaxonXPathRuleQuery()", "testcase": false, "constructor": true}, {"identifier": "SaxonXPathRuleQuery", "parameters": "(DeprecatedAttrLogger attrCtx)", "modifiers": "public", "return": "", "signature": " SaxonXPathRuleQuery(DeprecatedAttrLogger attrCtx)", "full_signature": "public  SaxonXPathRuleQuery(DeprecatedAttrLogger attrCtx)", "class_method_signature": "SaxonXPathRuleQuery.SaxonXPathRuleQuery(DeprecatedAttrLogger attrCtx)", "testcase": false, "constructor": true}, {"identifier": "isSupportedVersion", "parameters": "(String version)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isSupportedVersion(String version)", "full_signature": "@Override public boolean isSupportedVersion(String version)", "class_method_signature": "SaxonXPathRuleQuery.isSupportedVersion(String version)", "testcase": false, "constructor": false}, {"identifier": "evaluate", "parameters": "(final Node node, final RuleContext data)", "modifiers": "@Override public", "return": "List<Node>", "signature": "List<Node> evaluate(final Node node, final RuleContext data)", "full_signature": "@Override public List<Node> evaluate(final Node node, final RuleContext data)", "class_method_signature": "SaxonXPathRuleQuery.evaluate(final Node node, final RuleContext data)", "testcase": false, "constructor": false}, {"identifier": "getXPathExpressionForNodeOrDefault", "parameters": "(String nodeName)", "modifiers": "private", "return": "List<Expression>", "signature": "List<Expression> getXPathExpressionForNodeOrDefault(String nodeName)", "full_signature": "private List<Expression> getXPathExpressionForNodeOrDefault(String nodeName)", "class_method_signature": "SaxonXPathRuleQuery.getXPathExpressionForNodeOrDefault(String nodeName)", "testcase": false, "constructor": false}, {"identifier": "createDynamicContext", "parameters": "(final ElementNode elementNode)", "modifiers": "private", "return": "XPathDynamicContext", "signature": "XPathDynamicContext createDynamicContext(final ElementNode elementNode)", "full_signature": "private XPathDynamicContext createDynamicContext(final ElementNode elementNode)", "class_method_signature": "SaxonXPathRuleQuery.createDynamicContext(final ElementNode elementNode)", "testcase": false, "constructor": false}, {"identifier": "getRepresentation", "parameters": "(final PropertyDescriptor<?> descriptor, final Object value)", "modifiers": "private", "return": "ValueRepresentation", "signature": "ValueRepresentation getRepresentation(final PropertyDescriptor<?> descriptor, final Object value)", "full_signature": "private ValueRepresentation getRepresentation(final PropertyDescriptor<?> descriptor, final Object value)", "class_method_signature": "SaxonXPathRuleQuery.getRepresentation(final PropertyDescriptor<?> descriptor, final Object value)", "testcase": false, "constructor": false}, {"identifier": "getDocumentNodeForRootNode", "parameters": "(final Node node)", "modifiers": "private", "return": "DocumentNode", "signature": "DocumentNode getDocumentNodeForRootNode(final Node node)", "full_signature": "private DocumentNode getDocumentNodeForRootNode(final Node node)", "class_method_signature": "SaxonXPathRuleQuery.getDocumentNodeForRootNode(final Node node)", "testcase": false, "constructor": false}, {"identifier": "getRootNode", "parameters": "(final Node node)", "modifiers": "private", "return": "Node", "signature": "Node getRootNode(final Node node)", "full_signature": "private Node getRootNode(final Node node)", "class_method_signature": "SaxonXPathRuleQuery.getRootNode(final Node node)", "testcase": false, "constructor": false}, {"identifier": "addExpressionForNode", "parameters": "(String nodeName, Expression expression)", "modifiers": "private", "return": "void", "signature": "void addExpressionForNode(String nodeName, Expression expression)", "full_signature": "private void addExpressionForNode(String nodeName, Expression expression)", "class_method_signature": "SaxonXPathRuleQuery.addExpressionForNode(String nodeName, Expression expression)", "testcase": false, "constructor": false}, {"identifier": "initializeXPathExpression", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void initializeXPathExpression()", "full_signature": "private void initializeXPathExpression()", "class_method_signature": "SaxonXPathRuleQuery.initializeXPathExpression()", "testcase": false, "constructor": false}, {"identifier": "analyzeXPathForRuleChain", "parameters": "(final XPathEvaluator xpathEvaluator)", "modifiers": "private", "return": "void", "signature": "void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator)", "full_signature": "private void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator)", "class_method_signature": "SaxonXPathRuleQuery.analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator)", "testcase": false, "constructor": false}, {"identifier": "getAtomicRepresentation", "parameters": "(final Object value)", "modifiers": "public static", "return": "AtomicValue", "signature": "AtomicValue getAtomicRepresentation(final Object value)", "full_signature": "public static AtomicValue getAtomicRepresentation(final Object value)", "class_method_signature": "SaxonXPathRuleQuery.getAtomicRepresentation(final Object value)", "testcase": false, "constructor": false}, {"identifier": "getSequenceRepresentation", "parameters": "(List<?> list)", "modifiers": "public static", "return": "Value", "signature": "Value getSequenceRepresentation(List<?> list)", "full_signature": "public static Value getSequenceRepresentation(List<?> list)", "class_method_signature": "SaxonXPathRuleQuery.getSequenceRepresentation(List<?> list)", "testcase": false, "constructor": false}, {"identifier": "getRuleChainVisits", "parameters": "()", "modifiers": "@Override public", "return": "List<String>", "signature": "List<String> getRuleChainVisits()", "full_signature": "@Override public List<String> getRuleChainVisits()", "class_method_signature": "SaxonXPathRuleQuery.getRuleChainVisits()", "testcase": false, "constructor": false}, {"identifier": "getNamePool", "parameters": "()", "modifiers": "public static", "return": "NamePool", "signature": "NamePool getNamePool()", "full_signature": "public static NamePool getNamePool()", "class_method_signature": "SaxonXPathRuleQuery.getNamePool()", "testcase": false, "constructor": false}], "file": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/SaxonXPathRuleQuery.java"}, "focal_method": {"identifier": "getRuleChainVisits", "parameters": "()", "modifiers": "@Override public", "return": "List<String>", "body": "@Override\n    public List<String> getRuleChainVisits() {\n        initializeXPathExpression();\n        return super.getRuleChainVisits();\n    }", "signature": "List<String> getRuleChainVisits()", "full_signature": "@Override public List<String> getRuleChainVisits()", "class_method_signature": "SaxonXPathRuleQuery.getRuleChainVisits()", "testcase": false, "constructor": false, "invocations": ["initializeXPathExpression", "getRuleChainVisits"]}, "repository": {"repo_id": 4992906, "url": "https://github.com/pmd/pmd", "stars": 2677, "created": "7/11/2012 6:03:00 PM +00:00", "updates": "2020-01-27T18:49:43+00:00", "fork": "False", "license": "licensed"}}