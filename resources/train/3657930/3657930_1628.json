{"test_class": {"identifier": "PropertyIndexLookupTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final List<String> PROP_NAMES = Lists.newArrayList(\"jcr:primaryType\", \"jcr:mixinTypes\");", "modifier": "private static final", "type": "List<String>", "declarator": "PROP_NAMES = Lists.newArrayList(\"jcr:primaryType\", \"jcr:mixinTypes\")", "var_name": "PROP_NAMES"}, {"original_string": "private static final List<String> DECL_NODE_TYPES = Lists.newArrayList(\"nt:unstructured\", \"mix:versionable\");", "modifier": "private static final", "type": "List<String>", "declarator": "DECL_NODE_TYPES = Lists.newArrayList(\"nt:unstructured\", \"mix:versionable\")", "var_name": "DECL_NODE_TYPES"}, {"original_string": "private NodeState root;", "modifier": "private", "type": "NodeState", "declarator": "root", "var_name": "root"}, {"original_string": "private NodeBuilder rootBuilder;", "modifier": "private", "type": "NodeBuilder", "declarator": "rootBuilder", "var_name": "rootBuilder"}, {"original_string": "private static final EditorHook HOOK = new EditorHook(\n            new IndexUpdateProvider(new PropertyIndexEditorProvider()));", "modifier": "private static final", "type": "EditorHook", "declarator": "HOOK = new EditorHook(\n            new IndexUpdateProvider(new PropertyIndexEditorProvider()))", "var_name": "HOOK"}], "file": "oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookupTest.java"}, "test_case": {"identifier": "getIndexNodeForStringPropertyNames", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void getIndexNodeForStringPropertyNames() throws Exception {\n        rootBuilder.child(INDEX_DEFINITIONS_NAME).child(\"nodetype\")\n                .removeProperty(PROPERTY_NAMES)\n                .setProperty(PropertyStates.createProperty(PROPERTY_NAMES, PROP_NAMES, STRINGS));\n        commit();\n\n        Filter f = createFilter(root, \"nt:unstructured\");\n        assertNotNull(\"propertyNames with String[] should also find index node\",\n                new PropertyIndexLookup(root).getIndexNode(root, JCR_PRIMARYTYPE, f));\n    }", "signature": "void getIndexNodeForStringPropertyNames()", "full_signature": "@Test public void getIndexNodeForStringPropertyNames()", "class_method_signature": "PropertyIndexLookupTest.getIndexNodeForStringPropertyNames()", "testcase": true, "constructor": false, "invocations": ["setProperty", "removeProperty", "child", "child", "createProperty", "commit", "createFilter", "assertNotNull", "getIndexNode"]}, "focal_class": {"identifier": "PropertyIndexLookup", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final Logger LOG = LoggerFactory.getLogger(PropertyIndexLookup.class);", "modifier": "static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(PropertyIndexLookup.class)", "var_name": "LOG"}, {"original_string": "public static final double COST_OVERHEAD = 2;", "modifier": "public static final", "type": "double", "declarator": "COST_OVERHEAD = 2", "var_name": "COST_OVERHEAD"}, {"original_string": "static final int MAX_COST = 100;", "modifier": "static final", "type": "int", "declarator": "MAX_COST = 100", "var_name": "MAX_COST"}, {"original_string": "private final NodeState root;", "modifier": "private final", "type": "NodeState", "declarator": "root", "var_name": "root"}, {"original_string": "private final MountInfoProvider mountInfoProvider;", "modifier": "private final", "type": "MountInfoProvider", "declarator": "mountInfoProvider", "var_name": "mountInfoProvider"}], "methods": [{"identifier": "PropertyIndexLookup", "parameters": "(NodeState root)", "modifiers": "public", "return": "", "signature": " PropertyIndexLookup(NodeState root)", "full_signature": "public  PropertyIndexLookup(NodeState root)", "class_method_signature": "PropertyIndexLookup.PropertyIndexLookup(NodeState root)", "testcase": false, "constructor": true}, {"identifier": "PropertyIndexLookup", "parameters": "(NodeState root, MountInfoProvider mountInfoProvider)", "modifiers": "public", "return": "", "signature": " PropertyIndexLookup(NodeState root, MountInfoProvider mountInfoProvider)", "full_signature": "public  PropertyIndexLookup(NodeState root, MountInfoProvider mountInfoProvider)", "class_method_signature": "PropertyIndexLookup.PropertyIndexLookup(NodeState root, MountInfoProvider mountInfoProvider)", "testcase": false, "constructor": true}, {"identifier": "isIndexed", "parameters": "(String propertyName, String path, Filter filter)", "modifiers": "public", "return": "boolean", "signature": "boolean isIndexed(String propertyName, String path, Filter filter)", "full_signature": "public boolean isIndexed(String propertyName, String path, Filter filter)", "class_method_signature": "PropertyIndexLookup.isIndexed(String propertyName, String path, Filter filter)", "testcase": false, "constructor": false}, {"identifier": "query", "parameters": "(Filter filter, String propertyName,\n            PropertyValue value)", "modifiers": "public", "return": "Iterable<String>", "signature": "Iterable<String> query(Filter filter, String propertyName,\n            PropertyValue value)", "full_signature": "public Iterable<String> query(Filter filter, String propertyName,\n            PropertyValue value)", "class_method_signature": "PropertyIndexLookup.query(Filter filter, String propertyName,\n            PropertyValue value)", "testcase": false, "constructor": false}, {"identifier": "getStrategies", "parameters": "(NodeState definition)", "modifiers": "", "return": "Set<IndexStoreStrategy>", "signature": "Set<IndexStoreStrategy> getStrategies(NodeState definition)", "full_signature": " Set<IndexStoreStrategy> getStrategies(NodeState definition)", "class_method_signature": "PropertyIndexLookup.getStrategies(NodeState definition)", "testcase": false, "constructor": false}, {"identifier": "getCost", "parameters": "(Filter filter, String propertyName, PropertyValue value)", "modifiers": "public", "return": "double", "signature": "double getCost(Filter filter, String propertyName, PropertyValue value)", "full_signature": "public double getCost(Filter filter, String propertyName, PropertyValue value)", "class_method_signature": "PropertyIndexLookup.getCost(Filter filter, String propertyName, PropertyValue value)", "testcase": false, "constructor": false}, {"identifier": "getIndexNode", "parameters": "(NodeState node, String propertyName, Filter filter)", "modifiers": "@Nullable", "return": "NodeState", "signature": "NodeState getIndexNode(NodeState node, String propertyName, Filter filter)", "full_signature": "@Nullable NodeState getIndexNode(NodeState node, String propertyName, Filter filter)", "class_method_signature": "PropertyIndexLookup.getIndexNode(NodeState node, String propertyName, Filter filter)", "testcase": false, "constructor": false}, {"identifier": "getType", "parameters": "()", "modifiers": "", "return": "String", "signature": "String getType()", "full_signature": " String getType()", "class_method_signature": "PropertyIndexLookup.getType()", "testcase": false, "constructor": false}, {"identifier": "getSuperTypes", "parameters": "(Filter filter)", "modifiers": "@Nullable private static", "return": "Set<String>", "signature": "Set<String> getSuperTypes(Filter filter)", "full_signature": "@Nullable private static Set<String> getSuperTypes(Filter filter)", "class_method_signature": "PropertyIndexLookup.getSuperTypes(Filter filter)", "testcase": false, "constructor": false}, {"identifier": "getNames", "parameters": "(@NotNull NodeState state, @NotNull String propertyName)", "modifiers": "@NotNull private static", "return": "Iterable<String>", "signature": "Iterable<String> getNames(@NotNull NodeState state, @NotNull String propertyName)", "full_signature": "@NotNull private static Iterable<String> getNames(@NotNull NodeState state, @NotNull String propertyName)", "class_method_signature": "PropertyIndexLookup.getNames(@NotNull NodeState state, @NotNull String propertyName)", "testcase": false, "constructor": false}], "file": "oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java"}, "focal_method": {"identifier": "getIndexNode", "parameters": "(NodeState node, String propertyName, Filter filter)", "modifiers": "@Nullable", "return": "NodeState", "body": "@Nullable\n    NodeState getIndexNode(NodeState node, String propertyName, Filter filter) {\n        // keep a fallback to a matching index def that has *no* node type constraints\n        // (initially, there is no fallback)\n        NodeState fallback = null;\n\n        NodeState state = node.getChildNode(INDEX_DEFINITIONS_NAME);\n        for (ChildNodeEntry entry : state.getChildNodeEntries()) {\n            NodeState index = entry.getNodeState();\n            PropertyState type = index.getProperty(TYPE_PROPERTY_NAME);\n            if (type == null || type.isArray() || !getType().equals(type.getValue(Type.STRING))) {\n                continue;\n            }\n            if (contains(getNames(index, PROPERTY_NAMES), propertyName)) {\n                NodeState indexContent = index.getChildNode(INDEX_CONTENT_NODE_NAME);\n                if (!indexContent.exists()) {\n                    continue;\n                }\n                Set<String> supertypes = getSuperTypes(filter);\n                if (index.hasProperty(DECLARING_NODE_TYPES)) {\n                    if (supertypes != null) {\n                        for (String typeName : getNames(index, DECLARING_NODE_TYPES)) {\n                            if (supertypes.contains(typeName)) {\n                                // TODO: prefer the most specific type restriction\n                                return index;\n                            }\n                        }\n                    }\n                } else if (supertypes == null) {\n                    return index;\n                } else if (fallback == null) {\n                    // update the fallback\n                    fallback = index;\n                }\n            }\n        }\n        return fallback;\n    }", "signature": "NodeState getIndexNode(NodeState node, String propertyName, Filter filter)", "full_signature": "@Nullable NodeState getIndexNode(NodeState node, String propertyName, Filter filter)", "class_method_signature": "PropertyIndexLookup.getIndexNode(NodeState node, String propertyName, Filter filter)", "testcase": false, "constructor": false, "invocations": ["getChildNode", "getChildNodeEntries", "getNodeState", "getProperty", "isArray", "equals", "getType", "getValue", "contains", "getNames", "getChildNode", "exists", "getSuperTypes", "hasProperty", "getNames", "contains"]}, "repository": {"repo_id": 3657930, "url": "https://github.com/apache/jackrabbit-oak", "stars": 291, "created": "3/8/2012 8:00:14 AM +00:00", "updates": "2020-01-27T10:53:13+00:00", "fork": "False", "license": "licensed"}}