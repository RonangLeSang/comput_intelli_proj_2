{"test_class": {"identifier": "AggregateTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final TestCollector col = new TestCollector();", "modifier": "private final", "type": "TestCollector", "declarator": "col = new TestCollector()", "var_name": "col"}, {"original_string": "private final SimpleMapper mapper = new SimpleMapper();", "modifier": "private final", "type": "SimpleMapper", "declarator": "mapper = new SimpleMapper()", "var_name": "mapper"}, {"original_string": "private final NodeState root = INITIAL_CONTENT;", "modifier": "private final", "type": "NodeState", "declarator": "root = INITIAL_CONTENT", "var_name": "root"}, {"original_string": "private final NodeBuilder builder = root.builder();", "modifier": "private final", "type": "NodeBuilder", "declarator": "builder = root.builder()", "var_name": "builder"}], "file": "oak-search/src/test/java/org/apache/jackrabbit/oak/plugins/index/search/AggregateTest.java"}, "test_case": {"identifier": "propOneLevelNamed", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void propOneLevelNamed() throws Exception{\n        NodeBuilder rules = builder.child(INDEX_RULES);\n        rules.child(\"nt:folder\");\n        child(rules, \"nt:folder/properties/p1\")\n                .setProperty(FulltextIndexConstants.PROP_NAME, \"a/p1\");\n\n        IndexDefinition defn = new IndexDefinition(root, builder.getNodeState(), \"/foo\");\n        Aggregate ag = defn.getApplicableIndexingRule(\"nt:folder\").getAggregate();\n\n        NodeBuilder nb = newNode(\"nt:folder\");\n        nb.child(\"a\").setProperty(\"p1\", \"foo\");\n        nb.child(\"a\").setProperty(\"p2\", \"foo\");\n        nb.child(\"b\").setProperty(\"p2\", \"foo\");\n\n        ag.collectAggregates(nb.getNodeState(), col);\n        assertEquals(1, col.getPropPaths().size());\n        assertThat(col.getPropPaths(), hasItems(\"a/p1\"));\n    }", "signature": "void propOneLevelNamed()", "full_signature": "@Test public void propOneLevelNamed()", "class_method_signature": "AggregateTest.propOneLevelNamed()", "testcase": true, "constructor": false, "invocations": ["child", "child", "setProperty", "child", "getNodeState", "getAggregate", "getApplicableIndexingRule", "newNode", "setProperty", "child", "setProperty", "child", "setProperty", "child", "collectAggregates", "getNodeState", "assertEquals", "size", "getPropPaths", "assertThat", "getPropPaths", "hasItems"]}, "focal_class": {"identifier": "Aggregate", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String MATCH_ALL = \"*\";", "modifier": "public static final", "type": "String", "declarator": "MATCH_ALL = \"*\"", "var_name": "MATCH_ALL"}, {"original_string": "public static final int RECURSIVE_AGGREGATION_LIMIT_DEFAULT = 5;", "modifier": "public static final", "type": "int", "declarator": "RECURSIVE_AGGREGATION_LIMIT_DEFAULT = 5", "var_name": "RECURSIVE_AGGREGATION_LIMIT_DEFAULT"}, {"original_string": "private final String nodeTypeName;", "modifier": "private final", "type": "String", "declarator": "nodeTypeName", "var_name": "nodeTypeName"}, {"original_string": "private final List<? extends Include> includes;", "modifier": "private final", "type": "List<? extends Include>", "declarator": "includes", "var_name": "includes"}, {"original_string": "public final int reAggregationLimit;", "modifier": "public final", "type": "int", "declarator": "reAggregationLimit", "var_name": "reAggregationLimit"}, {"original_string": "private final List<NodeInclude> relativeNodeIncludes;", "modifier": "private final", "type": "List<NodeInclude>", "declarator": "relativeNodeIncludes", "var_name": "relativeNodeIncludes"}, {"original_string": "private final boolean nodeAggregates;", "modifier": "private final", "type": "boolean", "declarator": "nodeAggregates", "var_name": "nodeAggregates"}], "methods": [{"identifier": "Aggregate", "parameters": "(String nodeTypeName)", "modifiers": "", "return": "", "signature": " Aggregate(String nodeTypeName)", "full_signature": "  Aggregate(String nodeTypeName)", "class_method_signature": "Aggregate.Aggregate(String nodeTypeName)", "testcase": false, "constructor": true}, {"identifier": "Aggregate", "parameters": "(String nodeTypeName, List<? extends Include> includes)", "modifiers": "public", "return": "", "signature": " Aggregate(String nodeTypeName, List<? extends Include> includes)", "full_signature": "public  Aggregate(String nodeTypeName, List<? extends Include> includes)", "class_method_signature": "Aggregate.Aggregate(String nodeTypeName, List<? extends Include> includes)", "testcase": false, "constructor": true}, {"identifier": "Aggregate", "parameters": "(String nodeTypeName, List<? extends Include> includes,\n              int recursionLimit)", "modifiers": "", "return": "", "signature": " Aggregate(String nodeTypeName, List<? extends Include> includes,\n              int recursionLimit)", "full_signature": "  Aggregate(String nodeTypeName, List<? extends Include> includes,\n              int recursionLimit)", "class_method_signature": "Aggregate.Aggregate(String nodeTypeName, List<? extends Include> includes,\n              int recursionLimit)", "testcase": false, "constructor": true}, {"identifier": "getIncludes", "parameters": "()", "modifiers": "public", "return": "List<? extends Include>", "signature": "List<? extends Include> getIncludes()", "full_signature": "public List<? extends Include> getIncludes()", "class_method_signature": "Aggregate.getIncludes()", "testcase": false, "constructor": false}, {"identifier": "collectAggregates", "parameters": "(NodeState root, ResultCollector collector)", "modifiers": "public", "return": "void", "signature": "void collectAggregates(NodeState root, ResultCollector collector)", "full_signature": "public void collectAggregates(NodeState root, ResultCollector collector)", "class_method_signature": "Aggregate.collectAggregates(NodeState root, ResultCollector collector)", "testcase": false, "constructor": false}, {"identifier": "createMatchers", "parameters": "(AggregateRoot root)", "modifiers": "public", "return": "List<Matcher>", "signature": "List<Matcher> createMatchers(AggregateRoot root)", "full_signature": "public List<Matcher> createMatchers(AggregateRoot root)", "class_method_signature": "Aggregate.createMatchers(AggregateRoot root)", "testcase": false, "constructor": false}, {"identifier": "hasRelativeNodeInclude", "parameters": "(String nodePath)", "modifiers": "public", "return": "boolean", "signature": "boolean hasRelativeNodeInclude(String nodePath)", "full_signature": "public boolean hasRelativeNodeInclude(String nodePath)", "class_method_signature": "Aggregate.hasRelativeNodeInclude(String nodePath)", "testcase": false, "constructor": false}, {"identifier": "hasNodeAggregates", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean hasNodeAggregates()", "full_signature": "public boolean hasNodeAggregates()", "class_method_signature": "Aggregate.hasNodeAggregates()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "Aggregate.toString()", "testcase": false, "constructor": false}, {"identifier": "matchingType", "parameters": "(String nodeTypeName, NodeState nodeState)", "modifiers": "private static", "return": "boolean", "signature": "boolean matchingType(String nodeTypeName, NodeState nodeState)", "full_signature": "private static boolean matchingType(String nodeTypeName, NodeState nodeState)", "class_method_signature": "Aggregate.matchingType(String nodeTypeName, NodeState nodeState)", "testcase": false, "constructor": false}, {"identifier": "collectAggregates", "parameters": "(NodeState nodeState, List<Matcher> matchers,\n                                          ResultCollector collector)", "modifiers": "private static", "return": "void", "signature": "void collectAggregates(NodeState nodeState, List<Matcher> matchers,\n                                          ResultCollector collector)", "full_signature": "private static void collectAggregates(NodeState nodeState, List<Matcher> matchers,\n                                          ResultCollector collector)", "class_method_signature": "Aggregate.collectAggregates(NodeState nodeState, List<Matcher> matchers,\n                                          ResultCollector collector)", "testcase": false, "constructor": false}, {"identifier": "collectAggregatesForDirectMatchers", "parameters": "(NodeState nodeState, List<Matcher> matchers,\n                                                           ResultCollector collector)", "modifiers": "private static", "return": "void", "signature": "void collectAggregatesForDirectMatchers(NodeState nodeState, List<Matcher> matchers,\n                                                           ResultCollector collector)", "full_signature": "private static void collectAggregatesForDirectMatchers(NodeState nodeState, List<Matcher> matchers,\n                                                           ResultCollector collector)", "class_method_signature": "Aggregate.collectAggregatesForDirectMatchers(NodeState nodeState, List<Matcher> matchers,\n                                                           ResultCollector collector)", "testcase": false, "constructor": false}, {"identifier": "collectAggregatesForPatternMatchers", "parameters": "(NodeState nodeState, List<Matcher> matchers,\n                                                            ResultCollector collector)", "modifiers": "private static", "return": "void", "signature": "void collectAggregatesForPatternMatchers(NodeState nodeState, List<Matcher> matchers,\n                                                            ResultCollector collector)", "full_signature": "private static void collectAggregatesForPatternMatchers(NodeState nodeState, List<Matcher> matchers,\n                                                            ResultCollector collector)", "class_method_signature": "Aggregate.collectAggregatesForPatternMatchers(NodeState nodeState, List<Matcher> matchers,\n                                                            ResultCollector collector)", "testcase": false, "constructor": false}, {"identifier": "matchChildren", "parameters": "(List<Matcher> matchers, ResultCollector collector,\n                                      Iterable<? extends ChildNodeEntry> children)", "modifiers": "private static", "return": "void", "signature": "void matchChildren(List<Matcher> matchers, ResultCollector collector,\n                                      Iterable<? extends ChildNodeEntry> children)", "full_signature": "private static void matchChildren(List<Matcher> matchers, ResultCollector collector,\n                                      Iterable<? extends ChildNodeEntry> children)", "class_method_signature": "Aggregate.matchChildren(List<Matcher> matchers, ResultCollector collector,\n                                      Iterable<? extends ChildNodeEntry> children)", "testcase": false, "constructor": false}, {"identifier": "hasPatternMatcher", "parameters": "(List<Matcher> matchers)", "modifiers": "private static", "return": "boolean", "signature": "boolean hasPatternMatcher(List<Matcher> matchers)", "full_signature": "private static boolean hasPatternMatcher(List<Matcher> matchers)", "class_method_signature": "Aggregate.hasPatternMatcher(List<Matcher> matchers)", "testcase": false, "constructor": false}, {"identifier": "createMatchers", "parameters": "()", "modifiers": "private", "return": "List<Matcher>", "signature": "List<Matcher> createMatchers()", "full_signature": "private List<Matcher> createMatchers()", "class_method_signature": "Aggregate.createMatchers()", "testcase": false, "constructor": false}, {"identifier": "findRelativeNodeIncludes", "parameters": "(List<? extends Include> includes)", "modifiers": "private static", "return": "List<NodeInclude>", "signature": "List<NodeInclude> findRelativeNodeIncludes(List<? extends Include> includes)", "full_signature": "private static List<NodeInclude> findRelativeNodeIncludes(List<? extends Include> includes)", "class_method_signature": "Aggregate.findRelativeNodeIncludes(List<? extends Include> includes)", "testcase": false, "constructor": false}, {"identifier": "hasNodeIncludes", "parameters": "(List<? extends Include> includes)", "modifiers": "private static", "return": "boolean", "signature": "boolean hasNodeIncludes(List<? extends Include> includes)", "full_signature": "private static boolean hasNodeIncludes(List<? extends Include> includes)", "class_method_signature": "Aggregate.hasNodeIncludes(List<? extends Include> includes)", "testcase": false, "constructor": false}, {"identifier": "computeElements", "parameters": "(String path)", "modifiers": "private static", "return": "String[]", "signature": "String[] computeElements(String path)", "full_signature": "private static String[] computeElements(String path)", "class_method_signature": "Aggregate.computeElements(String path)", "testcase": false, "constructor": false}], "file": "oak-search/src/main/java/org/apache/jackrabbit/oak/plugins/index/search/Aggregate.java"}, "focal_method": {"identifier": "collectAggregates", "parameters": "(NodeState root, ResultCollector collector)", "modifiers": "public", "return": "void", "body": "public void collectAggregates(NodeState root, ResultCollector collector) {\n        if (matchingType(nodeTypeName, root)) {\n            List<Matcher> matchers = createMatchers();\n            collectAggregates(root, matchers, collector);\n        }\n    }", "signature": "void collectAggregates(NodeState root, ResultCollector collector)", "full_signature": "public void collectAggregates(NodeState root, ResultCollector collector)", "class_method_signature": "Aggregate.collectAggregates(NodeState root, ResultCollector collector)", "testcase": false, "constructor": false, "invocations": ["matchingType", "createMatchers", "collectAggregates"]}, "repository": {"repo_id": 3657930, "url": "https://github.com/apache/jackrabbit-oak", "stars": 291, "created": "3/8/2012 8:00:14 AM +00:00", "updates": "2020-01-27T10:53:13+00:00", "fork": "False", "license": "licensed"}}