{"test_class": {"identifier": "DocumentNodeStoreBranchTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n    public DocumentMKBuilderProvider builderProvider = new DocumentMKBuilderProvider();", "modifier": "@Rule\n    public", "type": "DocumentMKBuilderProvider", "declarator": "builderProvider = new DocumentMKBuilderProvider()", "var_name": "builderProvider"}], "file": "oak-store-document/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranchTest.java"}, "test_case": {"identifier": "branchedBranch", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void branchedBranch() throws Exception {\n        DocumentNodeStore ns = builderProvider.newBuilder().getNodeStore();\n        NodeBuilder b1 = ns.getRoot().builder();\n        b1.child(\"a\");\n        persistToBranch(b1);\n        NodeBuilder b2 = b1.getNodeState().builder();\n        b1.child(\"b\");\n        persistToBranch(b1);\n\n        b2.child(\"c\");\n        persistToBranch(b2);\n        assertTrue(b2.hasChildNode(\"a\"));\n        assertFalse(b2.hasChildNode(\"b\"));\n        assertTrue(b2.hasChildNode(\"c\"));\n\n        // b1 must still see 'a' and 'b', but not 'c'\n        assertTrue(b1.hasChildNode(\"a\"));\n        assertTrue(b1.hasChildNode(\"b\"));\n        assertFalse(b1.hasChildNode(\"c\"));\n\n        merge(ns, b1);\n\n        assertTrue(ns.getRoot().getChildNode(\"a\").exists());\n        assertTrue(ns.getRoot().getChildNode(\"b\").exists());\n        assertFalse(ns.getRoot().getChildNode(\"c\").exists());\n\n        // b2 must not be able to merge\n        try {\n            merge(ns, b2);\n            fail(\"Merge must fail with IllegalStateException\");\n        } catch (IllegalStateException e) {\n            // expected\n        }\n    }", "signature": "void branchedBranch()", "full_signature": "@Test public void branchedBranch()", "class_method_signature": "DocumentNodeStoreBranchTest.branchedBranch()", "testcase": true, "constructor": false, "invocations": ["getNodeStore", "newBuilder", "builder", "getRoot", "child", "persistToBranch", "builder", "getNodeState", "child", "persistToBranch", "child", "persistToBranch", "assertTrue", "hasChildNode", "assertFalse", "hasChildNode", "assertTrue", "hasChildNode", "assertTrue", "hasChildNode", "assertTrue", "hasChildNode", "assertFalse", "hasChildNode", "merge", "assertTrue", "exists", "getChildNode", "getRoot", "assertTrue", "exists", "getChildNode", "getRoot", "assertFalse", "exists", "getChildNode", "getRoot", "merge", "fail"]}, "focal_class": {"identifier": "DocumentNodeStoreBranch", "superclass": "", "interfaces": "implements NodeStoreBranch", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(DocumentNodeStoreBranch.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(DocumentNodeStoreBranch.class)", "var_name": "LOG"}, {"original_string": "private static final PerfLogger perfLogger = new PerfLogger(\n            LoggerFactory.getLogger(DocumentNodeStoreBranch.class.getName()\n                    + \".perf\"));", "modifier": "private static final", "type": "PerfLogger", "declarator": "perfLogger = new PerfLogger(\n            LoggerFactory.getLogger(DocumentNodeStoreBranch.class.getName()\n                    + \".perf\"))", "var_name": "perfLogger"}, {"original_string": "private static final int MAX_LOCK_TRY_TIME_MULTIPLIER = Integer.getInteger(\"oak.maxLockTryTimeMultiplier\", 30);", "modifier": "private static final", "type": "int", "declarator": "MAX_LOCK_TRY_TIME_MULTIPLIER = Integer.getInteger(\"oak.maxLockTryTimeMultiplier\", 30)", "var_name": "MAX_LOCK_TRY_TIME_MULTIPLIER"}, {"original_string": "private static final Random RANDOM = new Random();", "modifier": "private static final", "type": "Random", "declarator": "RANDOM = new Random()", "var_name": "RANDOM"}, {"original_string": "private static final long MIN_BACKOFF = 50;", "modifier": "private static final", "type": "long", "declarator": "MIN_BACKOFF = 50", "var_name": "MIN_BACKOFF"}, {"original_string": "protected final DocumentNodeStore store;", "modifier": "protected final", "type": "DocumentNodeStore", "declarator": "store", "var_name": "store"}, {"original_string": "protected final long maximumBackoff;", "modifier": "protected final", "type": "long", "declarator": "maximumBackoff", "var_name": "maximumBackoff"}, {"original_string": "protected final long maxLockTryTimeMS;", "modifier": "protected final", "type": "long", "declarator": "maxLockTryTimeMS", "var_name": "maxLockTryTimeMS"}, {"original_string": "private final ReadWriteLock mergeLock;", "modifier": "private final", "type": "ReadWriteLock", "declarator": "mergeLock", "var_name": "mergeLock"}, {"original_string": "private final int updateLimit;", "modifier": "private final", "type": "int", "declarator": "updateLimit", "var_name": "updateLimit"}, {"original_string": "private BranchState branchState;", "modifier": "private", "type": "BranchState", "declarator": "branchState", "var_name": "branchState"}], "methods": [{"identifier": "DocumentNodeStoreBranch", "parameters": "(DocumentNodeStore store,\n                            DocumentNodeState base,\n                            ReadWriteLock mergeLock)", "modifiers": "", "return": "", "signature": " DocumentNodeStoreBranch(DocumentNodeStore store,\n                            DocumentNodeState base,\n                            ReadWriteLock mergeLock)", "full_signature": "  DocumentNodeStoreBranch(DocumentNodeStore store,\n                            DocumentNodeState base,\n                            ReadWriteLock mergeLock)", "class_method_signature": "DocumentNodeStoreBranch.DocumentNodeStoreBranch(DocumentNodeStore store,\n                            DocumentNodeState base,\n                            ReadWriteLock mergeLock)", "testcase": false, "constructor": true}, {"identifier": "getBase", "parameters": "()", "modifiers": "@NotNull @Override public", "return": "NodeState", "signature": "NodeState getBase()", "full_signature": "@NotNull @Override public NodeState getBase()", "class_method_signature": "DocumentNodeStoreBranch.getBase()", "testcase": false, "constructor": false}, {"identifier": "getHead", "parameters": "()", "modifiers": "@NotNull @Override public", "return": "NodeState", "signature": "NodeState getHead()", "full_signature": "@NotNull @Override public NodeState getHead()", "class_method_signature": "DocumentNodeStoreBranch.getHead()", "testcase": false, "constructor": false}, {"identifier": "setRoot", "parameters": "(NodeState newRoot)", "modifiers": "@Override public", "return": "void", "signature": "void setRoot(NodeState newRoot)", "full_signature": "@Override public void setRoot(NodeState newRoot)", "class_method_signature": "DocumentNodeStoreBranch.setRoot(NodeState newRoot)", "testcase": false, "constructor": false}, {"identifier": "merge", "parameters": "(@NotNull CommitHook hook, @NotNull CommitInfo info)", "modifiers": "@NotNull @Override public", "return": "NodeState", "signature": "NodeState merge(@NotNull CommitHook hook, @NotNull CommitInfo info)", "full_signature": "@NotNull @Override public NodeState merge(@NotNull CommitHook hook, @NotNull CommitInfo info)", "class_method_signature": "DocumentNodeStoreBranch.merge(@NotNull CommitHook hook, @NotNull CommitInfo info)", "testcase": false, "constructor": false}, {"identifier": "rebase", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void rebase()", "full_signature": "@Override public void rebase()", "class_method_signature": "DocumentNodeStoreBranch.rebase()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "DocumentNodeStoreBranch.toString()", "testcase": false, "constructor": false}, {"identifier": "getMergeLock", "parameters": "()", "modifiers": "@NotNull", "return": "ReadWriteLock", "signature": "ReadWriteLock getMergeLock()", "full_signature": "@NotNull ReadWriteLock getMergeLock()", "class_method_signature": "DocumentNodeStoreBranch.getMergeLock()", "testcase": false, "constructor": false}, {"identifier": "persist", "parameters": "()", "modifiers": "", "return": "void", "signature": "void persist()", "full_signature": " void persist()", "class_method_signature": "DocumentNodeStoreBranch.persist()", "testcase": false, "constructor": false}, {"identifier": "merge0", "parameters": "(@NotNull CommitHook hook,\n                             @NotNull CommitInfo info,\n                             boolean exclusive)", "modifiers": "@NotNull private", "return": "NodeState", "signature": "NodeState merge0(@NotNull CommitHook hook,\n                             @NotNull CommitInfo info,\n                             boolean exclusive)", "full_signature": "@NotNull private NodeState merge0(@NotNull CommitHook hook,\n                             @NotNull CommitInfo info,\n                             boolean exclusive)", "class_method_signature": "DocumentNodeStoreBranch.merge0(@NotNull CommitHook hook,\n                             @NotNull CommitInfo info,\n                             boolean exclusive)", "testcase": false, "constructor": false}, {"identifier": "acquireMergeLock", "parameters": "(boolean exclusive)", "modifiers": "@Nullable private", "return": "Lock", "signature": "Lock acquireMergeLock(boolean exclusive)", "full_signature": "@Nullable private Lock acquireMergeLock(boolean exclusive)", "class_method_signature": "DocumentNodeStoreBranch.acquireMergeLock(boolean exclusive)", "testcase": false, "constructor": false}, {"identifier": "persist", "parameters": "(final @NotNull NodeState toPersist,\n                                      final @NotNull DocumentNodeState base,\n                                      final @NotNull CommitInfo info,\n                                      final @NotNull MergeStats stats)", "modifiers": "private", "return": "DocumentNodeState", "signature": "DocumentNodeState persist(final @NotNull NodeState toPersist,\n                                      final @NotNull DocumentNodeState base,\n                                      final @NotNull CommitInfo info,\n                                      final @NotNull MergeStats stats)", "full_signature": "private DocumentNodeState persist(final @NotNull NodeState toPersist,\n                                      final @NotNull DocumentNodeState base,\n                                      final @NotNull CommitInfo info,\n                                      final @NotNull MergeStats stats)", "class_method_signature": "DocumentNodeStoreBranch.persist(final @NotNull NodeState toPersist,\n                                      final @NotNull DocumentNodeState base,\n                                      final @NotNull CommitInfo info,\n                                      final @NotNull MergeStats stats)", "testcase": false, "constructor": false}, {"identifier": "persist", "parameters": "(@NotNull Changes op,\n                                      @NotNull DocumentNodeState base,\n                                      @NotNull CommitInfo info)", "modifiers": "private", "return": "DocumentNodeState", "signature": "DocumentNodeState persist(@NotNull Changes op,\n                                      @NotNull DocumentNodeState base,\n                                      @NotNull CommitInfo info)", "full_signature": "private DocumentNodeState persist(@NotNull Changes op,\n                                      @NotNull DocumentNodeState base,\n                                      @NotNull CommitInfo info)", "class_method_signature": "DocumentNodeStoreBranch.persist(@NotNull Changes op,\n                                      @NotNull DocumentNodeState base,\n                                      @NotNull CommitInfo info)", "testcase": false, "constructor": false}, {"identifier": "mergeFailed", "parameters": "(Throwable t)", "modifiers": "private static", "return": "CommitFailedException", "signature": "CommitFailedException mergeFailed(Throwable t)", "full_signature": "private static CommitFailedException mergeFailed(Throwable t)", "class_method_signature": "DocumentNodeStoreBranch.mergeFailed(Throwable t)", "testcase": false, "constructor": false}], "file": "oak-store-document/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java"}, "focal_method": {"identifier": "merge", "parameters": "(@NotNull CommitHook hook, @NotNull CommitInfo info)", "modifiers": "@NotNull @Override public", "return": "NodeState", "body": "@NotNull\n    @Override\n    public NodeState merge(@NotNull CommitHook hook, @NotNull CommitInfo info)\n            throws CommitFailedException {\n        try {\n            return merge0(hook, info, false);\n        } catch (CommitFailedException e) {\n            if (!e.isOfType(MERGE)) {\n                throw e;\n            }\n        }\n        // retry with exclusive lock, blocking other\n        // concurrent writes\n        return merge0(hook, info, true);\n    }", "signature": "NodeState merge(@NotNull CommitHook hook, @NotNull CommitInfo info)", "full_signature": "@NotNull @Override public NodeState merge(@NotNull CommitHook hook, @NotNull CommitInfo info)", "class_method_signature": "DocumentNodeStoreBranch.merge(@NotNull CommitHook hook, @NotNull CommitInfo info)", "testcase": false, "constructor": false, "invocations": ["merge0", "isOfType", "merge0"]}, "repository": {"repo_id": 3657930, "url": "https://github.com/apache/jackrabbit-oak", "stars": 291, "created": "3/8/2012 8:00:14 AM +00:00", "updates": "2020-01-27T10:53:13+00:00", "fork": "False", "license": "licensed"}}