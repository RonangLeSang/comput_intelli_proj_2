{"test_class": {"identifier": "RDBDocumentSerializerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private DocumentStoreFixture fixture = DocumentStoreFixture.RDB_H2;", "modifier": "private", "type": "DocumentStoreFixture", "declarator": "fixture = DocumentStoreFixture.RDB_H2", "var_name": "fixture"}, {"original_string": "private DocumentStore store;", "modifier": "private", "type": "DocumentStore", "declarator": "store", "var_name": "store"}, {"original_string": "private RDBDocumentSerializer ser;", "modifier": "private", "type": "RDBDocumentSerializer", "declarator": "ser", "var_name": "ser"}], "file": "oak-store-document/src/test/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentSerializerTest.java"}, "test_case": {"identifier": "testNoSysprops", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testNoSysprops() {\n        RDBRow row = new RDBRow(\"_foo\", null, null, 1l, 2l, 3l, 0L, 0L, 0L, \"{}\", null);\n        NodeDocument doc = this.ser.fromRow(Collection.NODES, row);\n        assertEquals(\"_foo\", doc.getId());\n        assertEquals(false, doc.hasBinary());\n        assertNull(null, doc.get(NodeDocument.HAS_BINARY_FLAG));\n        assertEquals(false, doc.wasDeletedOnce());\n        assertNull(null, doc.get(NodeDocument.DELETED_ONCE));\n        assertEquals(2L, doc.getModCount().longValue());\n    }", "signature": "void testNoSysprops()", "full_signature": "@Test public void testNoSysprops()", "class_method_signature": "RDBDocumentSerializerTest.testNoSysprops()", "testcase": true, "constructor": false, "invocations": ["fromRow", "assertEquals", "getId", "assertEquals", "hasBinary", "assertNull", "get", "assertEquals", "wasDeletedOnce", "assertNull", "get", "assertEquals", "longValue", "getModCount"]}, "focal_class": {"identifier": "RDBDocumentSerializer", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final DocumentStore store;", "modifier": "private final", "type": "DocumentStore", "declarator": "store", "var_name": "store"}, {"original_string": "private static final String MODIFIED = NodeDocument.MODIFIED_IN_SECS;", "modifier": "private static final", "type": "String", "declarator": "MODIFIED = NodeDocument.MODIFIED_IN_SECS", "var_name": "MODIFIED"}, {"original_string": "private static final String MODCOUNT = NodeDocument.MOD_COUNT;", "modifier": "private static final", "type": "String", "declarator": "MODCOUNT = NodeDocument.MOD_COUNT", "var_name": "MODCOUNT"}, {"original_string": "private static final String CMODCOUNT = \"_collisionsModCount\";", "modifier": "private static final", "type": "String", "declarator": "CMODCOUNT = \"_collisionsModCount\"", "var_name": "CMODCOUNT"}, {"original_string": "private static final String SDTYPE = NodeDocument.SD_TYPE;", "modifier": "private static final", "type": "String", "declarator": "SDTYPE = NodeDocument.SD_TYPE", "var_name": "SDTYPE"}, {"original_string": "private static final String SDMAXREVTIME = NodeDocument.SD_MAX_REV_TIME_IN_SECS;", "modifier": "private static final", "type": "String", "declarator": "SDMAXREVTIME = NodeDocument.SD_MAX_REV_TIME_IN_SECS", "var_name": "SDMAXREVTIME"}, {"original_string": "private static final String ID = \"_id\";", "modifier": "private static final", "type": "String", "declarator": "ID = \"_id\"", "var_name": "ID"}, {"original_string": "private static final String HASBINARY = NodeDocument.HAS_BINARY_FLAG;", "modifier": "private static final", "type": "String", "declarator": "HASBINARY = NodeDocument.HAS_BINARY_FLAG", "var_name": "HASBINARY"}, {"original_string": "private static final String DELETEDONCE = NodeDocument.DELETED_ONCE;", "modifier": "private static final", "type": "String", "declarator": "DELETEDONCE = NodeDocument.DELETED_ONCE", "var_name": "DELETEDONCE"}, {"original_string": "private final Comparator<Revision> comparator = StableRevisionComparator.REVERSE;", "modifier": "private final", "type": "Comparator<Revision>", "declarator": "comparator = StableRevisionComparator.REVERSE", "var_name": "comparator"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(RDBDocumentSerializer.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(RDBDocumentSerializer.class)", "var_name": "LOG"}, {"original_string": "private static final RDBJSONSupport JSON = new RDBJSONSupport(true);", "modifier": "private static final", "type": "RDBJSONSupport", "declarator": "JSON = new RDBJSONSupport(true)", "var_name": "JSON"}, {"original_string": "private static byte[] GZIPSIG = { 31, -117 };", "modifier": "private static", "type": "byte[]", "declarator": "GZIPSIG = { 31, -117 }", "var_name": "GZIPSIG"}], "methods": [{"identifier": "RDBDocumentSerializer", "parameters": "(DocumentStore store)", "modifiers": "public", "return": "", "signature": " RDBDocumentSerializer(DocumentStore store)", "full_signature": "public  RDBDocumentSerializer(DocumentStore store)", "class_method_signature": "RDBDocumentSerializer.RDBDocumentSerializer(DocumentStore store)", "testcase": false, "constructor": true}, {"identifier": "asString", "parameters": "(@NotNull Document doc, Set<String> columnProperties)", "modifiers": "public", "return": "String", "signature": "String asString(@NotNull Document doc, Set<String> columnProperties)", "full_signature": "public String asString(@NotNull Document doc, Set<String> columnProperties)", "class_method_signature": "RDBDocumentSerializer.asString(@NotNull Document doc, Set<String> columnProperties)", "testcase": false, "constructor": false}, {"identifier": "asString", "parameters": "(UpdateOp update, Set<String> columnProperties)", "modifiers": "public", "return": "String", "signature": "String asString(UpdateOp update, Set<String> columnProperties)", "full_signature": "public String asString(UpdateOp update, Set<String> columnProperties)", "class_method_signature": "RDBDocumentSerializer.asString(UpdateOp update, Set<String> columnProperties)", "testcase": false, "constructor": false}, {"identifier": "fromRow", "parameters": "(@NotNull Collection<T> collection, @NotNull RDBRow row)", "modifiers": "@NotNull public", "return": "T", "signature": "T fromRow(@NotNull Collection<T> collection, @NotNull RDBRow row)", "full_signature": "@NotNull public T fromRow(@NotNull Collection<T> collection, @NotNull RDBRow row)", "class_method_signature": "RDBDocumentSerializer.fromRow(@NotNull Collection<T> collection, @NotNull RDBRow row)", "testcase": false, "constructor": false}, {"identifier": "applyUpdate", "parameters": "(T doc, List updateString, List<Object> op)", "modifiers": "private", "return": "void", "signature": "void applyUpdate(T doc, List updateString, List<Object> op)", "full_signature": "private void applyUpdate(T doc, List updateString, List<Object> op)", "class_method_signature": "RDBDocumentSerializer.applyUpdate(T doc, List updateString, List<Object> op)", "testcase": false, "constructor": false}, {"identifier": "readDocumentFromJson", "parameters": "(@NotNull JsopTokenizer json, @NotNull T doc)", "modifiers": "private static", "return": "void", "signature": "void readDocumentFromJson(@NotNull JsopTokenizer json, @NotNull T doc)", "full_signature": "private static void readDocumentFromJson(@NotNull JsopTokenizer json, @NotNull T doc)", "class_method_signature": "RDBDocumentSerializer.readDocumentFromJson(@NotNull JsopTokenizer json, @NotNull T doc)", "testcase": false, "constructor": false}, {"identifier": "checkSdType", "parameters": "(Document doc)", "modifiers": "private static", "return": "void", "signature": "void checkSdType(Document doc)", "full_signature": "private static void checkSdType(Document doc)", "class_method_signature": "RDBDocumentSerializer.checkSdType(Document doc)", "testcase": false, "constructor": false}, {"identifier": "fromBlobData", "parameters": "(byte[] bdata)", "modifiers": "private static", "return": "String", "signature": "String fromBlobData(byte[] bdata)", "full_signature": "private static String fromBlobData(byte[] bdata)", "class_method_signature": "RDBDocumentSerializer.fromBlobData(byte[] bdata)", "testcase": false, "constructor": false}], "file": "oak-store-document/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentSerializer.java"}, "focal_method": {"identifier": "fromRow", "parameters": "(@NotNull Collection<T> collection, @NotNull RDBRow row)", "modifiers": "@NotNull public", "return": "T", "body": "@NotNull\n    public <T extends Document> T fromRow(@NotNull Collection<T> collection, @NotNull RDBRow row) throws DocumentStoreException {\n\n        final String charData = row.getData();\n        checkNotNull(charData, \"RDBRow.getData() is null for collection \" + collection + \", id: \" + row.getId());\n\n        T doc = collection.newDocument(store);\n        doc.put(ID, row.getId());\n        if (row.getModified() != RDBRow.LONG_UNSET) {\n            doc.put(MODIFIED, row.getModified());\n        }\n        if (row.getModcount() != RDBRow.LONG_UNSET) {\n            doc.put(MODCOUNT, row.getModcount());\n        }\n        if (RDBDocumentStore.USECMODCOUNT && row.getCollisionsModcount() != RDBRow.LONG_UNSET) {\n            doc.put(CMODCOUNT, row.getCollisionsModcount());\n        }\n        if (row.hasBinaryProperties() != null) {\n            doc.put(HASBINARY, row.hasBinaryProperties().longValue());\n        }\n        if (row.deletedOnce() != null) {\n            doc.put(DELETEDONCE, row.deletedOnce().booleanValue());\n        }\n        if (row.getSchemaVersion() >= 2) {\n            if (row.getSdType() != RDBRow.LONG_UNSET) {\n                doc.put(SDTYPE, row.getSdType());\n            }\n            if (row.getSdMaxRevTime() != RDBRow.LONG_UNSET) {\n                doc.put(SDMAXREVTIME, row.getSdMaxRevTime());\n            }\n        }\n\n        byte[] bdata = row.getBdata();\n        boolean blobInUse = false;\n        JsopTokenizer json;\n\n        // case #1: BDATA (blob) contains base data, DATA (string) contains\n        // update operations\n        try {\n            if (bdata != null && bdata.length != 0) {\n                String s = fromBlobData(bdata);\n                json = new JsopTokenizer(s);\n                json.read('{');\n                readDocumentFromJson(json, doc);\n                json.read(JsopReader.END);\n                blobInUse = true;\n            }\n        } catch (Exception ex) {\n            throw asDocumentStoreException(ex, \"parsing blob data as JSON\");\n        }\n\n        json = new JsopTokenizer(charData);\n\n        // start processing the VARCHAR data\n        try {\n            int next = json.read();\n\n            if (next == '{') {\n                if (blobInUse) {\n                    throw new DocumentStoreException(\"expected literal \\\"blob\\\" but found: \" + row.getData());\n                }\n                readDocumentFromJson(json, doc);\n            } else if (next == JsopReader.STRING) {\n                if (!blobInUse) {\n                    throw new DocumentStoreException(\"did not expect \\\"blob\\\" here: \" + row.getData());\n                }\n                if (!\"blob\".equals(json.getToken())) {\n                    throw new DocumentStoreException(\"expected string literal \\\"blob\\\"\");\n                }\n            } else {\n                throw new DocumentStoreException(\"unexpected token \" + next + \" in \" + row.getData());\n            }\n\n            next = json.read();\n            if (next == ',') {\n                do {\n                    Object ob = JSON.parse(json);\n                    if (!(ob instanceof List)) {\n                        throw new DocumentStoreException(\"expected array but got: \" + ob);\n                    }\n                    List<List<Object>> update = (List<List<Object>>) ob;\n                    for (List<Object> op : update) {\n                        applyUpdate(doc, update, op);\n                    }\n\n                } while (json.matches(','));\n            }\n            json.read(JsopReader.END);\n\n            // OAK-7855: check and fix _sdType\n            checkSdType(doc);\n\n            return doc;\n        } catch (Exception ex) {\n            String message = String.format(\"Error processing persisted data for document '%s'\", row.getId());\n            if (charData.length() > 0) {\n                int last = charData.charAt(charData.length() - 1);\n                if (last != '}' && last != '\"' && last != ']') {\n                    message += \" (DATA column might be truncated)\";\n                }\n            }\n\n            LOG.error(message, ex);\n            throw asDocumentStoreException(ex, message);\n        }\n    }", "signature": "T fromRow(@NotNull Collection<T> collection, @NotNull RDBRow row)", "full_signature": "@NotNull public T fromRow(@NotNull Collection<T> collection, @NotNull RDBRow row)", "class_method_signature": "RDBDocumentSerializer.fromRow(@NotNull Collection<T> collection, @NotNull RDBRow row)", "testcase": false, "constructor": false, "invocations": ["getData", "checkNotNull", "getId", "newDocument", "put", "getId", "getModified", "put", "getModified", "getModcount", "put", "getModcount", "getCollisionsModcount", "put", "getCollisionsModcount", "hasBinaryProperties", "put", "longValue", "hasBinaryProperties", "deletedOnce", "put", "booleanValue", "deletedOnce", "getSchemaVersion", "getSdType", "put", "getSdType", "getSdMaxRevTime", "put", "getSdMaxRevTime", "getBdata", "fromBlobData", "read", "readDocumentFromJson", "read", "asDocumentStoreException", "read", "getData", "readDocumentFromJson", "getData", "equals", "getToken", "getData", "read", "parse", "applyUpdate", "matches", "read", "checkSdType", "format", "getId", "length", "charAt", "length", "error", "asDocumentStoreException"]}, "repository": {"repo_id": 3657930, "url": "https://github.com/apache/jackrabbit-oak", "stars": 291, "created": "3/8/2012 8:00:14 AM +00:00", "updates": "2020-01-27T10:53:13+00:00", "fork": "False", "license": "licensed"}}