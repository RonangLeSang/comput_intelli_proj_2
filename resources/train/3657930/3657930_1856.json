{"test_class": {"identifier": "PrincipalBasedAccessControlManagerTest", "superclass": "extends AbstractPrincipalBasedTest", "interfaces": "", "fields": [{"original_string": "private PrincipalBasedAccessControlManager acMgr;", "modifier": "private", "type": "PrincipalBasedAccessControlManager", "declarator": "acMgr", "var_name": "acMgr"}, {"original_string": "private ItemBasedPrincipal validPrincipal;", "modifier": "private", "type": "ItemBasedPrincipal", "declarator": "validPrincipal", "var_name": "validPrincipal"}], "file": "oak-authorization-principalbased/src/test/java/org/apache/jackrabbit/oak/spi/security/authorization/principalbased/impl/PrincipalBasedAccessControlManagerTest.java"}, "test_case": {"identifier": "testSetPolicyNonExistingEffectivePath", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSetPolicyNonExistingEffectivePath() throws Exception {\n        PrincipalPolicyImpl policy = getPrincipalPolicyImpl(validPrincipal, acMgr);\n        policy.addEntry(testJcrPath, privilegesFromNames(JCR_READ));\n        acMgr.setPolicy(policy.getPath(), policy);\n        root.commit();\n    }", "signature": "void testSetPolicyNonExistingEffectivePath()", "full_signature": "@Test public void testSetPolicyNonExistingEffectivePath()", "class_method_signature": "PrincipalBasedAccessControlManagerTest.testSetPolicyNonExistingEffectivePath()", "testcase": true, "constructor": false, "invocations": ["getPrincipalPolicyImpl", "addEntry", "privilegesFromNames", "setPolicy", "getPath", "commit"]}, "focal_class": {"identifier": "PrincipalBasedAccessControlManager", "superclass": "extends AbstractAccessControlManager", "interfaces": "implements PolicyOwner, Constants", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(PrincipalBasedAccessControlManager.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(PrincipalBasedAccessControlManager.class)", "var_name": "log"}, {"original_string": "private final MgrProvider mgrProvider;", "modifier": "private final", "type": "MgrProvider", "declarator": "mgrProvider", "var_name": "mgrProvider"}, {"original_string": "private final int importBehavior;", "modifier": "private final", "type": "int", "declarator": "importBehavior", "var_name": "importBehavior"}, {"original_string": "private final Set<String> readPaths;", "modifier": "private final", "type": "Set<String>", "declarator": "readPaths", "var_name": "readPaths"}, {"original_string": "private final PrincipalManager principalManager;", "modifier": "private final", "type": "PrincipalManager", "declarator": "principalManager", "var_name": "principalManager"}, {"original_string": "private final PrivilegeBitsProvider privilegeBitsProvider;", "modifier": "private final", "type": "PrivilegeBitsProvider", "declarator": "privilegeBitsProvider", "var_name": "privilegeBitsProvider"}, {"original_string": "private final FilterProvider filterProvider;", "modifier": "private final", "type": "FilterProvider", "declarator": "filterProvider", "var_name": "filterProvider"}, {"original_string": "private final Filter filter;", "modifier": "private final", "type": "Filter", "declarator": "filter", "var_name": "filter"}], "methods": [{"identifier": "PrincipalBasedAccessControlManager", "parameters": "(@NotNull MgrProvider mgrProvider,\n                                       @NotNull FilterProvider filterProvider)", "modifiers": "", "return": "", "signature": " PrincipalBasedAccessControlManager(@NotNull MgrProvider mgrProvider,\n                                       @NotNull FilterProvider filterProvider)", "full_signature": "  PrincipalBasedAccessControlManager(@NotNull MgrProvider mgrProvider,\n                                       @NotNull FilterProvider filterProvider)", "class_method_signature": "PrincipalBasedAccessControlManager.PrincipalBasedAccessControlManager(@NotNull MgrProvider mgrProvider,\n                                       @NotNull FilterProvider filterProvider)", "testcase": false, "constructor": true}, {"identifier": "getApplicablePolicies", "parameters": "(@NotNull Principal principal)", "modifiers": "@NotNull @Override public", "return": "JackrabbitAccessControlPolicy[]", "signature": "JackrabbitAccessControlPolicy[] getApplicablePolicies(@NotNull Principal principal)", "full_signature": "@NotNull @Override public JackrabbitAccessControlPolicy[] getApplicablePolicies(@NotNull Principal principal)", "class_method_signature": "PrincipalBasedAccessControlManager.getApplicablePolicies(@NotNull Principal principal)", "testcase": false, "constructor": false}, {"identifier": "getPolicies", "parameters": "(@NotNull Principal principal)", "modifiers": "@NotNull @Override public", "return": "JackrabbitAccessControlPolicy[]", "signature": "JackrabbitAccessControlPolicy[] getPolicies(@NotNull Principal principal)", "full_signature": "@NotNull @Override public JackrabbitAccessControlPolicy[] getPolicies(@NotNull Principal principal)", "class_method_signature": "PrincipalBasedAccessControlManager.getPolicies(@NotNull Principal principal)", "testcase": false, "constructor": false}, {"identifier": "getEffectivePolicies", "parameters": "(@NotNull Set<Principal> principals)", "modifiers": "@NotNull @Override public", "return": "AccessControlPolicy[]", "signature": "AccessControlPolicy[] getEffectivePolicies(@NotNull Set<Principal> principals)", "full_signature": "@NotNull @Override public AccessControlPolicy[] getEffectivePolicies(@NotNull Set<Principal> principals)", "class_method_signature": "PrincipalBasedAccessControlManager.getEffectivePolicies(@NotNull Set<Principal> principals)", "testcase": false, "constructor": false}, {"identifier": "getPolicies", "parameters": "(String absPath)", "modifiers": "@Override public", "return": "AccessControlPolicy[]", "signature": "AccessControlPolicy[] getPolicies(String absPath)", "full_signature": "@Override public AccessControlPolicy[] getPolicies(String absPath)", "class_method_signature": "PrincipalBasedAccessControlManager.getPolicies(String absPath)", "testcase": false, "constructor": false}, {"identifier": "getEffectivePolicies", "parameters": "(String absPath)", "modifiers": "@Override public", "return": "AccessControlPolicy[]", "signature": "AccessControlPolicy[] getEffectivePolicies(String absPath)", "full_signature": "@Override public AccessControlPolicy[] getEffectivePolicies(String absPath)", "class_method_signature": "PrincipalBasedAccessControlManager.getEffectivePolicies(String absPath)", "testcase": false, "constructor": false}, {"identifier": "getApplicablePolicies", "parameters": "(String absPath)", "modifiers": "@Override public", "return": "AccessControlPolicyIterator", "signature": "AccessControlPolicyIterator getApplicablePolicies(String absPath)", "full_signature": "@Override public AccessControlPolicyIterator getApplicablePolicies(String absPath)", "class_method_signature": "PrincipalBasedAccessControlManager.getApplicablePolicies(String absPath)", "testcase": false, "constructor": false}, {"identifier": "setPolicy", "parameters": "(String absPath, AccessControlPolicy policy)", "modifiers": "@Override public", "return": "void", "signature": "void setPolicy(String absPath, AccessControlPolicy policy)", "full_signature": "@Override public void setPolicy(String absPath, AccessControlPolicy policy)", "class_method_signature": "PrincipalBasedAccessControlManager.setPolicy(String absPath, AccessControlPolicy policy)", "testcase": false, "constructor": false}, {"identifier": "removePolicy", "parameters": "(String absPath, AccessControlPolicy policy)", "modifiers": "@Override public", "return": "void", "signature": "void removePolicy(String absPath, AccessControlPolicy policy)", "full_signature": "@Override public void removePolicy(String absPath, AccessControlPolicy policy)", "class_method_signature": "PrincipalBasedAccessControlManager.removePolicy(String absPath, AccessControlPolicy policy)", "testcase": false, "constructor": false}, {"identifier": "defines", "parameters": "(@Nullable String absPath, @NotNull AccessControlPolicy accessControlPolicy)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean defines(@Nullable String absPath, @NotNull AccessControlPolicy accessControlPolicy)", "full_signature": "@Override public boolean defines(@Nullable String absPath, @NotNull AccessControlPolicy accessControlPolicy)", "class_method_signature": "PrincipalBasedAccessControlManager.defines(@Nullable String absPath, @NotNull AccessControlPolicy accessControlPolicy)", "testcase": false, "constructor": false}, {"identifier": "canHandle", "parameters": "(@Nullable Principal principal)", "modifiers": "private", "return": "boolean", "signature": "boolean canHandle(@Nullable Principal principal)", "full_signature": "private boolean canHandle(@Nullable Principal principal)", "class_method_signature": "PrincipalBasedAccessControlManager.canHandle(@Nullable Principal principal)", "testcase": false, "constructor": false}, {"identifier": "canHandle", "parameters": "(@NotNull Set<Principal> principals)", "modifiers": "", "return": "boolean", "signature": "boolean canHandle(@NotNull Set<Principal> principals)", "full_signature": " boolean canHandle(@NotNull Set<Principal> principals)", "class_method_signature": "PrincipalBasedAccessControlManager.canHandle(@NotNull Set<Principal> principals)", "testcase": false, "constructor": false}, {"identifier": "checkValidPolicy", "parameters": "(@Nullable String absPath, @NotNull AccessControlPolicy policy)", "modifiers": "private", "return": "PrincipalPolicyImpl", "signature": "PrincipalPolicyImpl checkValidPolicy(@Nullable String absPath, @NotNull AccessControlPolicy policy)", "full_signature": "private PrincipalPolicyImpl checkValidPolicy(@Nullable String absPath, @NotNull AccessControlPolicy policy)", "class_method_signature": "PrincipalBasedAccessControlManager.checkValidPolicy(@Nullable String absPath, @NotNull AccessControlPolicy policy)", "testcase": false, "constructor": false}, {"identifier": "getPolicyTree", "parameters": "(@NotNull Tree accessControlledTree)", "modifiers": "@NotNull private static", "return": "Tree", "signature": "Tree getPolicyTree(@NotNull Tree accessControlledTree)", "full_signature": "@NotNull private static Tree getPolicyTree(@NotNull Tree accessControlledTree)", "class_method_signature": "PrincipalBasedAccessControlManager.getPolicyTree(@NotNull Tree accessControlledTree)", "testcase": false, "constructor": false}, {"identifier": "createPolicy", "parameters": "(@NotNull Principal principal,\n                                                       boolean isEffectivePolicy)", "modifiers": "@Nullable private", "return": "JackrabbitAccessControlPolicy", "signature": "JackrabbitAccessControlPolicy createPolicy(@NotNull Principal principal,\n                                                       boolean isEffectivePolicy)", "full_signature": "@Nullable private JackrabbitAccessControlPolicy createPolicy(@NotNull Principal principal,\n                                                       boolean isEffectivePolicy)", "class_method_signature": "PrincipalBasedAccessControlManager.createPolicy(@NotNull Principal principal,\n                                                       boolean isEffectivePolicy)", "testcase": false, "constructor": false}, {"identifier": "isAccessControlled", "parameters": "(@NotNull Tree tree)", "modifiers": "private", "return": "boolean", "signature": "boolean isAccessControlled(@NotNull Tree tree)", "full_signature": "private boolean isAccessControlled(@NotNull Tree tree)", "class_method_signature": "PrincipalBasedAccessControlManager.isAccessControlled(@NotNull Tree tree)", "testcase": false, "constructor": false}, {"identifier": "getEffectivePaths", "parameters": "(@Nullable String oakPath)", "modifiers": "private", "return": "Iterable<String>", "signature": "Iterable<String> getEffectivePaths(@Nullable String oakPath)", "full_signature": "private Iterable<String> getEffectivePaths(@Nullable String oakPath)", "class_method_signature": "PrincipalBasedAccessControlManager.getEffectivePaths(@Nullable String oakPath)", "testcase": false, "constructor": false}, {"identifier": "createEffectiveEntry", "parameters": "(@NotNull Tree entryTree)", "modifiers": "@Nullable private", "return": "AbstractEntry", "signature": "AbstractEntry createEffectiveEntry(@NotNull Tree entryTree)", "full_signature": "@Nullable private AbstractEntry createEffectiveEntry(@NotNull Tree entryTree)", "class_method_signature": "PrincipalBasedAccessControlManager.createEffectiveEntry(@NotNull Tree entryTree)", "testcase": false, "constructor": false}, {"identifier": "isReadablePath", "parameters": "(@Nullable String oakPath)", "modifiers": "private", "return": "boolean", "signature": "boolean isReadablePath(@Nullable String oakPath)", "full_signature": "private boolean isReadablePath(@Nullable String oakPath)", "class_method_signature": "PrincipalBasedAccessControlManager.isReadablePath(@Nullable String oakPath)", "testcase": false, "constructor": false}], "file": "oak-authorization-principalbased/src/main/java/org/apache/jackrabbit/oak/spi/security/authorization/principalbased/impl/PrincipalBasedAccessControlManager.java"}, "focal_method": {"identifier": "setPolicy", "parameters": "(String absPath, AccessControlPolicy policy)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void setPolicy(String absPath, AccessControlPolicy policy) throws RepositoryException {\n        PrincipalPolicyImpl pp = checkValidPolicy(absPath, policy);\n        String oakPath = pp.getOakPath();\n        Tree tree = getTree(oakPath, Permissions.MODIFY_ACCESS_CONTROL, true);\n\n        Tree policyTree = getPolicyTree(tree);\n        if (policyTree.exists()) {\n            policyTree.remove();\n        }\n\n        // make sure parent has mixin set and policy node is properly initialized\n        TreeUtil.addMixin(tree, MIX_REP_PRINCIPAL_BASED_MIXIN, getRoot().getTree(NodeTypeConstants.NODE_TYPES_PATH), getRoot().getContentSession().getAuthInfo().getUserID());\n        policyTree = TreeUtil.addChild(tree, REP_PRINCIPAL_POLICY, NT_REP_PRINCIPAL_POLICY);\n        policyTree.setOrderableChildren(true);\n        policyTree.setProperty(Constants.REP_PRINCIPAL_NAME, pp.getPrincipal().getName());\n\n        int i = 0;\n        RestrictionProvider restrictionProvider = mgrProvider.getRestrictionProvider();\n        for (PrincipalPolicyImpl.EntryImpl entry : pp.getEntries()) {\n            String effectiveOakPath = Strings.nullToEmpty(entry.getOakPath());\n            Tree entryTree = TreeUtil.addChild(policyTree, \"entry\" + i++, NT_REP_PRINCIPAL_ENTRY);\n            if (!Utils.hasModAcPermission(getPermissionProvider(), effectiveOakPath)) {\n                throw new AccessDeniedException(\"Access denied.\");\n            }\n            entryTree.setProperty(REP_EFFECTIVE_PATH, effectiveOakPath, Type.PATH);\n            entryTree.setProperty(Constants.REP_PRIVILEGES, privilegeBitsProvider.getPrivilegeNames(entry.getPrivilegeBits()), Type.NAMES);\n            restrictionProvider.writeRestrictions(oakPath, entryTree, entry.getRestrictions());\n        }\n    }", "signature": "void setPolicy(String absPath, AccessControlPolicy policy)", "full_signature": "@Override public void setPolicy(String absPath, AccessControlPolicy policy)", "class_method_signature": "PrincipalBasedAccessControlManager.setPolicy(String absPath, AccessControlPolicy policy)", "testcase": false, "constructor": false, "invocations": ["checkValidPolicy", "getOakPath", "getTree", "getPolicyTree", "exists", "remove", "addMixin", "getTree", "getRoot", "getUserID", "getAuthInfo", "getContentSession", "getRoot", "addChild", "setOrderableChildren", "setProperty", "getName", "getPrincipal", "getRestrictionProvider", "getEntries", "nullToEmpty", "getOakPath", "addChild", "hasModAcPermission", "getPermissionProvider", "setProperty", "setProperty", "getPrivilegeNames", "getPrivilegeBits", "writeRestrictions", "getRestrictions"]}, "repository": {"repo_id": 3657930, "url": "https://github.com/apache/jackrabbit-oak", "stars": 291, "created": "3/8/2012 8:00:14 AM +00:00", "updates": "2020-01-27T10:53:13+00:00", "fork": "False", "license": "licensed"}}