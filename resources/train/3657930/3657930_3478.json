{"test_class": {"identifier": "FileStoreTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n    public TemporaryFolder folder = new TemporaryFolder(new File(\"target\"));", "modifier": "@Rule\n    public", "type": "TemporaryFolder", "declarator": "folder = new TemporaryFolder(new File(\"target\"))", "var_name": "folder"}], "file": "oak-segment-tar/src/test/java/org/apache/jackrabbit/oak/segment/file/FileStoreTest.java"}, "test_case": {"identifier": "overlapping", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void overlapping() throws Exception {\n        FileStore fileStore = fileStoreBuilder(getFileStoreFolder()).build();\n        try {\n            fileStoreBuilder(getFileStoreFolder()).build();\n            Assert.fail(\"should not be able to open 2 stores on the same path\");\n        } catch (Exception ex) {\n            // expected\n        } finally {\n            fileStore.close();\n        }\n    }", "signature": "void overlapping()", "full_signature": "@Test public void overlapping()", "class_method_signature": "FileStoreTest.overlapping()", "testcase": true, "constructor": false, "invocations": ["build", "fileStoreBuilder", "getFileStoreFolder", "build", "fileStoreBuilder", "getFileStoreFolder", "fail", "close"]}, "focal_class": {"identifier": "FileStore", "superclass": "extends AbstractFileStore", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(FileStore.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(FileStore.class)", "var_name": "log"}, {"original_string": "private static final int MB = 1024 * 1024;", "modifier": "private static final", "type": "int", "declarator": "MB = 1024 * 1024", "var_name": "MB"}, {"original_string": "private static final String TAR_READER_COUNT = \"TAR_READER_COUNT\";", "modifier": "private static final", "type": "String", "declarator": "TAR_READER_COUNT = \"TAR_READER_COUNT\"", "var_name": "TAR_READER_COUNT"}, {"original_string": "private static final String SEGMENT_COUNT = \"SEGMENT_COUNT\";", "modifier": "private static final", "type": "String", "declarator": "SEGMENT_COUNT = \"SEGMENT_COUNT\"", "var_name": "SEGMENT_COUNT"}, {"original_string": "@NotNull\n    private final SegmentWriter segmentWriter;", "modifier": "@NotNull\n    private final", "type": "SegmentWriter", "declarator": "segmentWriter", "var_name": "segmentWriter"}, {"original_string": "@NotNull\n    private final GarbageCollector garbageCollector;", "modifier": "@NotNull\n    private final", "type": "GarbageCollector", "declarator": "garbageCollector", "var_name": "garbageCollector"}, {"original_string": "private final TarFiles tarFiles;", "modifier": "private final", "type": "TarFiles", "declarator": "tarFiles", "var_name": "tarFiles"}, {"original_string": "private final RepositoryLock repositoryLock;", "modifier": "private final", "type": "RepositoryLock", "declarator": "repositoryLock", "var_name": "repositoryLock"}, {"original_string": "private volatile TarRevisions revisions;", "modifier": "private volatile", "type": "TarRevisions", "declarator": "revisions", "var_name": "revisions"}, {"original_string": "private final Scheduler fileStoreScheduler = new Scheduler(\"FileStore background tasks\");", "modifier": "private final", "type": "Scheduler", "declarator": "fileStoreScheduler = new Scheduler(\"FileStore background tasks\")", "var_name": "fileStoreScheduler"}, {"original_string": "private final FileReaper fileReaper;", "modifier": "private final", "type": "FileReaper", "declarator": "fileReaper", "var_name": "fileReaper"}, {"original_string": "private final AtomicBoolean sufficientDiskSpace = new AtomicBoolean(true);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "sufficientDiskSpace = new AtomicBoolean(true)", "var_name": "sufficientDiskSpace"}, {"original_string": "private final AtomicBoolean sufficientMemory = new AtomicBoolean(true);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "sufficientMemory = new AtomicBoolean(true)", "var_name": "sufficientMemory"}, {"original_string": "private final FileStoreStats stats;", "modifier": "private final", "type": "FileStoreStats", "declarator": "stats", "var_name": "stats"}, {"original_string": "private final ShutDown shutDown = new ShutDown();", "modifier": "private final", "type": "ShutDown", "declarator": "shutDown = new ShutDown()", "var_name": "shutDown"}, {"original_string": "@NotNull\n    private final SegmentNotFoundExceptionListener snfeListener;", "modifier": "@NotNull\n    private final", "type": "SegmentNotFoundExceptionListener", "declarator": "snfeListener", "var_name": "snfeListener"}, {"original_string": "private final GarbageCollectionStrategy garbageCollectionStrategy = newGarbageCollectionStrategy();", "modifier": "private final", "type": "GarbageCollectionStrategy", "declarator": "garbageCollectionStrategy = newGarbageCollectionStrategy()", "var_name": "garbageCollectionStrategy"}, {"original_string": "private final boolean eagerSegmentCaching;", "modifier": "private final", "type": "boolean", "declarator": "eagerSegmentCaching", "var_name": "eagerSegmentCaching"}], "methods": [{"identifier": "newGarbageCollectionStrategy", "parameters": "()", "modifiers": "private static", "return": "GarbageCollectionStrategy", "signature": "GarbageCollectionStrategy newGarbageCollectionStrategy()", "full_signature": "private static GarbageCollectionStrategy newGarbageCollectionStrategy()", "class_method_signature": "FileStore.newGarbageCollectionStrategy()", "testcase": false, "constructor": false}, {"identifier": "FileStore", "parameters": "(final FileStoreBuilder builder)", "modifiers": "", "return": "", "signature": " FileStore(final FileStoreBuilder builder)", "full_signature": "  FileStore(final FileStoreBuilder builder)", "class_method_signature": "FileStore.FileStore(final FileStoreBuilder builder)", "testcase": false, "constructor": true}, {"identifier": "bind", "parameters": "(TarRevisions revisions)", "modifiers": "", "return": "FileStore", "signature": "FileStore bind(TarRevisions revisions)", "full_signature": " FileStore bind(TarRevisions revisions)", "class_method_signature": "FileStore.bind(TarRevisions revisions)", "testcase": false, "constructor": false}, {"identifier": "initialNode", "parameters": "()", "modifiers": "@NotNull private", "return": "Supplier<RecordId>", "signature": "Supplier<RecordId> initialNode()", "full_signature": "@NotNull private Supplier<RecordId> initialNode()", "class_method_signature": "FileStore.initialNode()", "testcase": false, "constructor": false}, {"identifier": "getGcGeneration", "parameters": "()", "modifiers": "@NotNull private", "return": "GCGeneration", "signature": "GCGeneration getGcGeneration()", "full_signature": "@NotNull private GCGeneration getGcGeneration()", "class_method_signature": "FileStore.getGcGeneration()", "testcase": false, "constructor": false}, {"identifier": "getGCRunner", "parameters": "()", "modifiers": "public", "return": "Runnable", "signature": "Runnable getGCRunner()", "full_signature": "public Runnable getGCRunner()", "class_method_signature": "FileStore.getGCRunner()", "testcase": false, "constructor": false}, {"identifier": "getGCNodeWriteMonitor", "parameters": "()", "modifiers": "public", "return": "GCNodeWriteMonitor", "signature": "GCNodeWriteMonitor getGCNodeWriteMonitor()", "full_signature": "public GCNodeWriteMonitor getGCNodeWriteMonitor()", "class_method_signature": "FileStore.getGCNodeWriteMonitor()", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "private", "return": "long", "signature": "long size()", "full_signature": "private long size()", "class_method_signature": "FileStore.size()", "testcase": false, "constructor": false}, {"identifier": "readerCount", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int readerCount()", "full_signature": "public int readerCount()", "class_method_signature": "FileStore.readerCount()", "testcase": false, "constructor": false}, {"identifier": "getSegmentCount", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getSegmentCount()", "full_signature": "public int getSegmentCount()", "class_method_signature": "FileStore.getSegmentCount()", "testcase": false, "constructor": false}, {"identifier": "getStats", "parameters": "()", "modifiers": "public", "return": "FileStoreStats", "signature": "FileStoreStats getStats()", "full_signature": "public FileStoreStats getStats()", "class_method_signature": "FileStore.getStats()", "testcase": false, "constructor": false}, {"identifier": "doFlush", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void doFlush()", "full_signature": "private void doFlush()", "class_method_signature": "FileStore.doFlush()", "testcase": false, "constructor": false}, {"identifier": "flush", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void flush()", "full_signature": "public void flush()", "class_method_signature": "FileStore.flush()", "testcase": false, "constructor": false}, {"identifier": "tryFlush", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void tryFlush()", "full_signature": "public void tryFlush()", "class_method_signature": "FileStore.tryFlush()", "testcase": false, "constructor": false}, {"identifier": "fullGC", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void fullGC()", "full_signature": "public void fullGC()", "class_method_signature": "FileStore.fullGC()", "testcase": false, "constructor": false}, {"identifier": "tailGC", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void tailGC()", "full_signature": "public void tailGC()", "class_method_signature": "FileStore.tailGC()", "testcase": false, "constructor": false}, {"identifier": "compactFull", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean compactFull()", "full_signature": "public boolean compactFull()", "class_method_signature": "FileStore.compactFull()", "testcase": false, "constructor": false}, {"identifier": "compactTail", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean compactTail()", "full_signature": "public boolean compactTail()", "class_method_signature": "FileStore.compactTail()", "testcase": false, "constructor": false}, {"identifier": "cleanup", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void cleanup()", "full_signature": "public void cleanup()", "class_method_signature": "FileStore.cleanup()", "testcase": false, "constructor": false}, {"identifier": "collectBlobReferences", "parameters": "(Consumer<String> collector)", "modifiers": "@Override public", "return": "void", "signature": "void collectBlobReferences(Consumer<String> collector)", "full_signature": "@Override public void collectBlobReferences(Consumer<String> collector)", "class_method_signature": "FileStore.collectBlobReferences(Consumer<String> collector)", "testcase": false, "constructor": false}, {"identifier": "cancelGC", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void cancelGC()", "full_signature": "public void cancelGC()", "class_method_signature": "FileStore.cancelGC()", "testcase": false, "constructor": false}, {"identifier": "getWriter", "parameters": "()", "modifiers": "@Override @NotNull public", "return": "SegmentWriter", "signature": "SegmentWriter getWriter()", "full_signature": "@Override @NotNull public SegmentWriter getWriter()", "class_method_signature": "FileStore.getWriter()", "testcase": false, "constructor": false}, {"identifier": "getRevisions", "parameters": "()", "modifiers": "@Override @NotNull public", "return": "TarRevisions", "signature": "TarRevisions getRevisions()", "full_signature": "@Override @NotNull public TarRevisions getRevisions()", "class_method_signature": "FileStore.getRevisions()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "FileStore.close()", "testcase": false, "constructor": false}, {"identifier": "containsSegment", "parameters": "(SegmentId id)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean containsSegment(SegmentId id)", "full_signature": "@Override public boolean containsSegment(SegmentId id)", "class_method_signature": "FileStore.containsSegment(SegmentId id)", "testcase": false, "constructor": false}, {"identifier": "readSegment", "parameters": "(final SegmentId id)", "modifiers": "@Override @NotNull public", "return": "Segment", "signature": "Segment readSegment(final SegmentId id)", "full_signature": "@Override @NotNull public Segment readSegment(final SegmentId id)", "class_method_signature": "FileStore.readSegment(final SegmentId id)", "testcase": false, "constructor": false}, {"identifier": "writeSegment", "parameters": "(SegmentId id, byte[] buffer, int offset, int length)", "modifiers": "@Override public", "return": "void", "signature": "void writeSegment(SegmentId id, byte[] buffer, int offset, int length)", "full_signature": "@Override public void writeSegment(SegmentId id, byte[] buffer, int offset, int length)", "class_method_signature": "FileStore.writeSegment(SegmentId id, byte[] buffer, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "checkDiskSpace", "parameters": "(SegmentGCOptions gcOptions)", "modifiers": "private", "return": "void", "signature": "void checkDiskSpace(SegmentGCOptions gcOptions)", "full_signature": "private void checkDiskSpace(SegmentGCOptions gcOptions)", "class_method_signature": "FileStore.checkDiskSpace(SegmentGCOptions gcOptions)", "testcase": false, "constructor": false}], "file": "oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/FileStore.java"}, "focal_method": {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void close() {\n        try (ShutDownCloser ignored = shutDown.shutDown()) {\n            // avoid deadlocks by closing (and joining) the background\n            // thread before acquiring the synchronization lock\n            fileStoreScheduler.close();\n\n            try {\n                doFlush();\n            } catch (IOException e) {\n                log.warn(\"Unable to flush the store\", e);\n            }\n\n            Closer closer = Closer.create();\n            closer.register(repositoryLock::unlock);\n            closer.register(tarFiles) ;\n            closer.register(revisions);\n\n            closeAndLogOnFail(closer);\n        }\n\n        // Try removing pending files in case the scheduler didn't have a chance to run yet\n        System.gc(); // for any memory-mappings that are no longer used\n        fileReaper.reap();\n\n        log.info(\"TarMK closed: {}\", directory);\n    }", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "FileStore.close()", "testcase": false, "constructor": false, "invocations": ["shutDown", "close", "doFlush", "warn", "create", "register", "register", "register", "closeAndLogOnFail", "gc", "reap", "info"]}, "repository": {"repo_id": 3657930, "url": "https://github.com/apache/jackrabbit-oak", "stars": 291, "created": "3/8/2012 8:00:14 AM +00:00", "updates": "2020-01-27T10:53:13+00:00", "fork": "False", "license": "licensed"}}