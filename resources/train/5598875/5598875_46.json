{"test_class": {"identifier": "TestNowOrLaterRetryPolicy", "superclass": "", "interfaces": "", "fields": [{"original_string": "private NowOrLaterRetryPolicy policy;", "modifier": "private", "type": "NowOrLaterRetryPolicy", "declarator": "policy", "var_name": "policy"}, {"original_string": "private ScheduledTask task;", "modifier": "private", "type": "ScheduledTask", "declarator": "task", "var_name": "task"}], "file": "sgs-server/src/test/java/com/sun/sgs/impl/kernel/schedule/TestNowOrLaterRetryPolicy.java"}, "test_case": {"identifier": "testNotRetryableExceptionAndRecurringTask", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testNotRetryableExceptionAndRecurringTask() {\n        setupTask(new Exception());\n        // record recurring task\n        EasyMock.expect(task.isRecurring()).andStubReturn(true);\n        replayMocks();\n\n        // verify\n        SchedulerRetryAction action = policy.getRetryAction(task);\n        Assert.assertEquals(SchedulerRetryAction.DROP, action);\n        verifyMocks();\n    }", "signature": "void testNotRetryableExceptionAndRecurringTask()", "full_signature": "@Test public void testNotRetryableExceptionAndRecurringTask()", "class_method_signature": "TestNowOrLaterRetryPolicy.testNotRetryableExceptionAndRecurringTask()", "testcase": true, "constructor": false, "invocations": ["setupTask", "andStubReturn", "expect", "isRecurring", "replayMocks", "getRetryAction", "assertEquals", "verifyMocks"]}, "focal_class": {"identifier": "NowOrLaterRetryPolicy", "superclass": "", "interfaces": "implements SchedulerRetryPolicy", "fields": [{"original_string": "private static final LoggerWrapper logger =\n        new LoggerWrapper(Logger.getLogger(NowOrLaterRetryPolicy.\n                                           class.getName()));", "modifier": "private static final", "type": "LoggerWrapper", "declarator": "logger =\n        new LoggerWrapper(Logger.getLogger(NowOrLaterRetryPolicy.\n                                           class.getName()))", "var_name": "logger"}, {"original_string": "static final String RETRY_BACKOFF_THRESHOLD_PROPERTY =\n            \"com.sun.sgs.impl.kernel.schedule.retry.backoff.threshold\";", "modifier": "static final", "type": "String", "declarator": "RETRY_BACKOFF_THRESHOLD_PROPERTY =\n            \"com.sun.sgs.impl.kernel.schedule.retry.backoff.threshold\"", "var_name": "RETRY_BACKOFF_THRESHOLD_PROPERTY"}, {"original_string": "static final int DEFAULT_RETRY_BACKOFF_THRESHOLD = 10;", "modifier": "static final", "type": "int", "declarator": "DEFAULT_RETRY_BACKOFF_THRESHOLD = 10", "var_name": "DEFAULT_RETRY_BACKOFF_THRESHOLD"}, {"original_string": "private final int retryBackoffThreshold;", "modifier": "private final", "type": "int", "declarator": "retryBackoffThreshold", "var_name": "retryBackoffThreshold"}], "methods": [{"identifier": "NowOrLaterRetryPolicy", "parameters": "(Properties properties)", "modifiers": "public", "return": "", "signature": " NowOrLaterRetryPolicy(Properties properties)", "full_signature": "public  NowOrLaterRetryPolicy(Properties properties)", "class_method_signature": "NowOrLaterRetryPolicy.NowOrLaterRetryPolicy(Properties properties)", "testcase": false, "constructor": true}, {"identifier": "getRetryAction", "parameters": "(ScheduledTask task)", "modifiers": "public", "return": "SchedulerRetryAction", "signature": "SchedulerRetryAction getRetryAction(ScheduledTask task)", "full_signature": "public SchedulerRetryAction getRetryAction(ScheduledTask task)", "class_method_signature": "NowOrLaterRetryPolicy.getRetryAction(ScheduledTask task)", "testcase": false, "constructor": false}], "file": "sgs-server/src/main/java/com/sun/sgs/impl/kernel/schedule/NowOrLaterRetryPolicy.java"}, "focal_method": {"identifier": "getRetryAction", "parameters": "(ScheduledTask task)", "modifiers": "public", "return": "SchedulerRetryAction", "body": "public SchedulerRetryAction getRetryAction(ScheduledTask task) {\n        // null task is not allowed\n        if (task == null) {\n            throw new IllegalArgumentException(\"task cannot be null\");\n        }\n\n        // result cannot be null\n        Throwable result = task.getLastFailure();\n        if (result == null) {\n            throw new IllegalStateException(\"task's last failure \" +\n                                            \"cannot be null\");\n        }\n\n        if ((result instanceof ExceptionRetryStatus) &&\n            (((ExceptionRetryStatus) result).shouldRetry())) {\n\n            // Always retry in place unless we are above the backoff threshold\n            // Also note, once a task is retried more than the backoff\n            // threshold, each subsequent retry will trigger this condition\n            if (task.getTryCount() > retryBackoffThreshold) {\n                if (result instanceof TransactionTimeoutException &&\n                    task.getTimeout() * 2L < (long) Integer.MAX_VALUE) {\n                    // double the timeout, and reschedule for RETRY_LATER\n                    // if the timeout has not exceeded max int\n                    logger.logThrow(Level.WARNING,\n                                    task.getLastFailure(),\n                                    \"Task has been retried {0} times: {1}\\n\" +\n                                    \"Increasing its timeout to {2} ms and \" +\n                                    \"scheduling its retry for later\",\n                                    task.getTryCount(), task, task.getTimeout() * 2);\n                    task.setTimeout(task.getTimeout() * 2);\n                } else {\n                    // just schedule to retry later if the task failure is\n                    // not due to transaction timeout\n                    logger.logThrow(Level.WARNING,\n                                    task.getLastFailure(),\n                                    \"Task has been retried {0} times: {1}\\n\" +\n                                    \"scheduling its retry for later\",\n                                    task.getTryCount(), task);\n                }\n                return SchedulerRetryAction.RETRY_LATER;\n            } else {\n                return SchedulerRetryAction.RETRY_NOW;\n            }\n        } else {\n\n            // we're not re-trying the task, so specify reason for dropping it\n            if (logger.isLoggable(Level.FINE)) {\n                if (task.isRecurring()) {\n                    logger.log(Level.FINE,\n                               \"skipping a recurrence of a task because it \" +\n                               \"failed with a non-retryable exception: {0}\",\n                               task);\n                } else {\n                    logger.log(Level.FINE,\n                               \"dropping a task because it failed with a \" +\n                               \"non-retryable exception: {0}\", task);\n                }\n            }\n\n            return SchedulerRetryAction.DROP;\n        }\n    }", "signature": "SchedulerRetryAction getRetryAction(ScheduledTask task)", "full_signature": "public SchedulerRetryAction getRetryAction(ScheduledTask task)", "class_method_signature": "NowOrLaterRetryPolicy.getRetryAction(ScheduledTask task)", "testcase": false, "constructor": false, "invocations": ["getLastFailure", "shouldRetry", "getTryCount", "getTimeout", "logThrow", "getLastFailure", "getTryCount", "getTimeout", "setTimeout", "getTimeout", "logThrow", "getLastFailure", "getTryCount", "isLoggable", "isRecurring", "log", "log"]}, "repository": {"repo_id": 5598875, "url": "https://github.com/dworkin/reddwarf", "language": "Java", "is_fork": false, "fork_count": 49, "stargazer_count": 30, "size": 144063, "license": "licensed"}}