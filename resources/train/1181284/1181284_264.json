{"test_class": {"identifier": "HostComponentSpringStageTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private File jar;", "modifier": "private", "type": "File", "declarator": "jar", "var_name": "jar"}, {"original_string": "private OsgiContainerManager osgiContainerManager;", "modifier": "private", "type": "OsgiContainerManager", "declarator": "osgiContainerManager", "var_name": "osgiContainerManager"}, {"original_string": "private SystemExports systemExports;", "modifier": "private", "type": "SystemExports", "declarator": "systemExports", "var_name": "systemExports"}, {"original_string": "private HostComponentSpringStage transformer = new HostComponentSpringStage();", "modifier": "private", "type": "HostComponentSpringStage", "declarator": "transformer = new HostComponentSpringStage()", "var_name": "transformer"}], "file": "osgi/loader/src/test/java/org/maera/plugin/osgi/factory/transform/stage/HostComponentSpringStageTest.java"}, "test_case": {"identifier": "testTransformWithSuperClassInJar", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testTransformWithSuperClassInJar() throws Exception {\n        jar = new PluginJarBuilder()\n                .addFormattedJava(\"my.Foo\",\n                        \"package my;\",\n                        \"public class Foo {\",\n                        \"}\")\n                .addFormattedJava(\"my2.Bar\",\n                        \"package my2;\",\n                        \"public class Bar extends my.Foo {\",\n                        \"}\")\n                .addPluginInformation(\"my.plugin\", \"my.plugin\", \"1.0\")\n                .build();\n\n        final List<HostComponentRegistration> regs = new ArrayList<HostComponentRegistration>() {\n\n            {\n                add(new MockRegistration(\"foo\", FooChild.class));\n            }\n        };\n\n        final TransformContext context = new TransformContext(regs, systemExports, new JarPluginArtifact(jar), null, PluginAccessor.Descriptor.FILENAME, osgiContainerManager);\n        transformer.execute(context);\n        assertEquals(0, context.getExtraImports().size());\n    }", "signature": "void testTransformWithSuperClassInJar()", "full_signature": "@Test public void testTransformWithSuperClassInJar()", "class_method_signature": "HostComponentSpringStageTest.testTransformWithSuperClassInJar()", "testcase": true, "constructor": false, "invocations": ["build", "addPluginInformation", "addFormattedJava", "addFormattedJava", "add", "execute", "assertEquals", "size", "getExtraImports"]}, "focal_class": {"identifier": "HostComponentSpringStage", "superclass": "", "interfaces": "implements TransformStage", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(HostComponentSpringStage.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(HostComponentSpringStage.class)", "var_name": "log"}, {"original_string": "static final String SPRING_XML = \"META-INF/spring/maera-plugins-host-components.xml\";", "modifier": "static final", "type": "String", "declarator": "SPRING_XML = \"META-INF/spring/maera-plugins-host-components.xml\"", "var_name": "SPRING_XML"}], "methods": [{"identifier": "execute", "parameters": "(TransformContext context)", "modifiers": "public", "return": "void", "signature": "void execute(TransformContext context)", "full_signature": "public void execute(TransformContext context)", "class_method_signature": "HostComponentSpringStage.execute(TransformContext context)", "testcase": false, "constructor": false}, {"identifier": "addImportsForMatchedHostComponents", "parameters": "(List<HostComponentRegistration> matchedRegistrations,\n                                                    SystemExports systemExports, List<String> extraImports)", "modifiers": "private", "return": "void", "signature": "void addImportsForMatchedHostComponents(List<HostComponentRegistration> matchedRegistrations,\n                                                    SystemExports systemExports, List<String> extraImports)", "full_signature": "private void addImportsForMatchedHostComponents(List<HostComponentRegistration> matchedRegistrations,\n                                                    SystemExports systemExports, List<String> extraImports)", "class_method_signature": "HostComponentSpringStage.addImportsForMatchedHostComponents(List<HostComponentRegistration> matchedRegistrations,\n                                                    SystemExports systemExports, List<String> extraImports)", "testcase": false, "constructor": false}, {"identifier": "convertRegistrationsToSet", "parameters": "(List<HostComponentRegistration> regs)", "modifiers": "private", "return": "Set<String>", "signature": "Set<String> convertRegistrationsToSet(List<HostComponentRegistration> regs)", "full_signature": "private Set<String> convertRegistrationsToSet(List<HostComponentRegistration> regs)", "class_method_signature": "HostComponentSpringStage.convertRegistrationsToSet(List<HostComponentRegistration> regs)", "testcase": false, "constructor": false}, {"identifier": "findUsedHostComponents", "parameters": "(Set<String> allHostComponents, Set<String> matchedHostComponents, List<String> innerJarPaths, InputStream\n            jarStream)", "modifiers": "private", "return": "void", "signature": "void findUsedHostComponents(Set<String> allHostComponents, Set<String> matchedHostComponents, List<String> innerJarPaths, InputStream\n            jarStream)", "full_signature": "private void findUsedHostComponents(Set<String> allHostComponents, Set<String> matchedHostComponents, List<String> innerJarPaths, InputStream\n            jarStream)", "class_method_signature": "HostComponentSpringStage.findUsedHostComponents(Set<String> allHostComponents, Set<String> matchedHostComponents, List<String> innerJarPaths, InputStream\n            jarStream)", "testcase": false, "constructor": false}, {"identifier": "addHostComponentsUsedInSuperClasses", "parameters": "(Set<String> allHostComponents, Set<String> matchedHostComponents, Set<String> entries, Set<String> superClassNames)", "modifiers": "private", "return": "void", "signature": "void addHostComponentsUsedInSuperClasses(Set<String> allHostComponents, Set<String> matchedHostComponents, Set<String> entries, Set<String> superClassNames)", "full_signature": "private void addHostComponentsUsedInSuperClasses(Set<String> allHostComponents, Set<String> matchedHostComponents, Set<String> entries, Set<String> superClassNames)", "class_method_signature": "HostComponentSpringStage.addHostComponentsUsedInSuperClasses(Set<String> allHostComponents, Set<String> matchedHostComponents, Set<String> entries, Set<String> superClassNames)", "testcase": false, "constructor": false}, {"identifier": "findJarPaths", "parameters": "(Manifest mf)", "modifiers": "private", "return": "List<String>", "signature": "List<String> findJarPaths(Manifest mf)", "full_signature": "private List<String> findJarPaths(Manifest mf)", "class_method_signature": "HostComponentSpringStage.findJarPaths(Manifest mf)", "testcase": false, "constructor": false}, {"identifier": "determineId", "parameters": "(Set<String> hostComponentNames, String beanName, int iteration)", "modifiers": "private", "return": "String", "signature": "String determineId(Set<String> hostComponentNames, String beanName, int iteration)", "full_signature": "private String determineId(Set<String> hostComponentNames, String beanName, int iteration)", "class_method_signature": "HostComponentSpringStage.determineId(Set<String> hostComponentNames, String beanName, int iteration)", "testcase": false, "constructor": false}, {"identifier": "isRequiredHostComponent", "parameters": "(TransformContext context, String name)", "modifiers": "private", "return": "boolean", "signature": "boolean isRequiredHostComponent(TransformContext context, String name)", "full_signature": "private boolean isRequiredHostComponent(TransformContext context, String name)", "class_method_signature": "HostComponentSpringStage.isRequiredHostComponent(TransformContext context, String name)", "testcase": false, "constructor": false}], "file": "osgi/loader/src/main/java/org/maera/plugin/osgi/factory/transform/stage/HostComponentSpringStage.java"}, "focal_method": {"identifier": "execute", "parameters": "(TransformContext context)", "modifiers": "public", "return": "void", "body": "public void execute(TransformContext context) throws PluginTransformationException {\n        if (SpringHelper.shouldGenerateFile(context, SPRING_XML)) {\n            Document doc = SpringHelper.createSpringDocument();\n            Set<String> hostComponentInterfaceNames = convertRegistrationsToSet(context.getHostComponentRegistrations());\n            Set<String> matchedInterfaceNames = new HashSet<String>();\n            List<String> innerJarPaths = findJarPaths(context.getManifest());\n            InputStream pluginStream = null;\n            try {\n                pluginStream = new FileInputStream(context.getPluginFile());\n                findUsedHostComponents(hostComponentInterfaceNames, matchedInterfaceNames, innerJarPaths, pluginStream);\n            }\n            catch (IOException e) {\n                throw new PluginParseException(\"Unable to scan for host components in plugin classes\", e);\n            }\n            finally {\n                IOUtils.closeQuietly(pluginStream);\n            }\n\n            List<HostComponentRegistration> matchedRegistrations = new ArrayList<HostComponentRegistration>();\n            Element root = doc.getRootElement();\n            if (context.getHostComponentRegistrations() != null) {\n                int index = -1;\n                for (HostComponentRegistration reg : context.getHostComponentRegistrations()) {\n                    index++;\n                    boolean found = false;\n                    for (String name : reg.getMainInterfaces()) {\n                        if (matchedInterfaceNames.contains(name) || isRequiredHostComponent(context, name)) {\n                            found = true;\n                        }\n                    }\n                    Set<String> regInterfaces = new HashSet<String>(Arrays.asList(reg.getMainInterfaces()));\n                    for (ComponentImport compImport : context.getComponentImports().values()) {\n                        if (PluginUtils.doesModuleElementApplyToApplication(compImport.getSource(), context.getApplicationKeys()) &&\n                                regInterfaces.containsAll(compImport.getInterfaces())) {\n                            found = false;\n                            break;\n                        }\n                    }\n\n                    if (!found) {\n                        continue;\n                    }\n                    matchedRegistrations.add(reg);\n\n                    String beanName = reg.getProperties().get(PropertyBuilder.BEAN_NAME);\n\n                    // We don't use Spring DM service references here, because when the plugin is disabled, the proxies\n                    // will be marked destroyed, causing undesirable ServiceProxyDestroyedException fireworks.  Since we\n                    // know host components won't change over the runtime of the plugin, we can use a simple factory\n                    // bean that returns the actual component instance\n\n                    Element osgiService = root.addElement(\"beans:bean\");\n                    osgiService.addAttribute(\"id\", determineId(context.getComponentImports().keySet(), beanName, index));\n                    osgiService.addAttribute(\"lazy-init\", \"true\");\n\n                    // These are strings since we aren't compiling against the osgi-bridge jar\n                    osgiService.addAttribute(\"class\", \"org.maera.plugin.osgi.bridge.external.HostComponentFactoryBean\");\n                    context.getExtraImports().add(\"org.maera.plugin.osgi.bridge.external\");\n\n                    Element e = osgiService.addElement(\"beans:property\");\n                    e.addAttribute(\"name\", \"filter\");\n\n                    e.addAttribute(\"value\", \"(&(bean-name=\" + beanName + \")(\" + ComponentRegistrar.HOST_COMPONENT_FLAG + \"=true))\");\n\n                    Element listProp = osgiService.addElement(\"beans:property\");\n                    listProp.addAttribute(\"name\", \"interfaces\");\n                    Element list = listProp.addElement(\"beans:list\");\n                    for (String inf : reg.getMainInterfaces()) {\n                        Element tmp = list.addElement(\"beans:value\");\n                        tmp.setText(inf);\n                    }\n                }\n            }\n            addImportsForMatchedHostComponents(matchedRegistrations, context.getSystemExports(), context.getExtraImports());\n            if (root.elements().size() > 0) {\n                context.setShouldRequireSpring(true);\n                context.getFileOverrides().put(SPRING_XML, SpringHelper.documentToBytes(doc));\n            }\n        }\n    }", "signature": "void execute(TransformContext context)", "full_signature": "public void execute(TransformContext context)", "class_method_signature": "HostComponentSpringStage.execute(TransformContext context)", "testcase": false, "constructor": false, "invocations": ["shouldGenerateFile", "createSpringDocument", "convertRegistrationsToSet", "getHostComponentRegistrations", "findJarPaths", "getManifest", "getPluginFile", "findUsedHostComponents", "closeQuietly", "getRootElement", "getHostComponentRegistrations", "getHostComponentRegistrations", "getMainInterfaces", "contains", "isRequiredHostComponent", "asList", "getMainInterfaces", "values", "getComponentImports", "doesModuleElementApplyToApplication", "getSource", "getApplicationKeys", "containsAll", "getInterfaces", "add", "get", "getProperties", "addElement", "addAttribute", "determineId", "keySet", "getComponentImports", "addAttribute", "addAttribute", "add", "getExtraImports", "addElement", "addAttribute", "addAttribute", "addElement", "addAttribute", "addElement", "getMainInterfaces", "addElement", "setText", "addImportsForMatchedHostComponents", "getSystemExports", "getExtraImports", "size", "elements", "setShouldRequireSpring", "put", "getFileOverrides", "documentToBytes"]}, "repository": {"repo_id": 1181284, "url": "https://github.com/katasource/maera", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 5, "size": 966, "license": "licensed"}}