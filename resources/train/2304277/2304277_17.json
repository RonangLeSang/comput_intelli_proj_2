{"test_class": {"identifier": "AbstractShellTest", "superclass": "", "interfaces": "", "fields": [], "file": "runtime/shell/src/test/java/org/springframework/roo/shell/AbstractShellTest.java"}, "test_case": {"identifier": "testProps", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testProps() {\n    // Set up\n    final AbstractShell shell = mock(AbstractShell.class);\n    when(shell.props()).thenCallRealMethod();\n\n    // Invoke\n    final String props = shell.props();\n\n    // Check\n    assertNotNull(props);\n  }", "signature": "void testProps()", "full_signature": "@Test public void testProps()", "class_method_signature": "AbstractShellTest.testProps()", "testcase": true, "constructor": false, "invocations": ["mock", "thenCallRealMethod", "when", "props", "props", "assertNotNull"]}, "focal_class": {"identifier": "AbstractShell", "superclass": "extends AbstractShellStatusPublisher", "interfaces": "implements Shell", "fields": [{"original_string": "List<CommandListener> commandListeners = new ArrayList<CommandListener>();", "modifier": "", "type": "List<CommandListener>", "declarator": "commandListeners = new ArrayList<CommandListener>()", "var_name": "commandListeners"}, {"original_string": "private static final Logger LOGGER = HandlerUtils.getLogger(AbstractShell.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = HandlerUtils.getLogger(AbstractShell.class)", "var_name": "LOGGER"}, {"original_string": "private CommandListener commandListener;", "modifier": "private", "type": "CommandListener", "declarator": "commandListener", "var_name": "commandListener"}, {"original_string": "private static final String MY_SLOT = AbstractShell.class.getName();", "modifier": "private static final", "type": "String", "declarator": "MY_SLOT = AbstractShell.class.getName()", "var_name": "MY_SLOT"}, {"original_string": "protected static final String ROO_PROMPT = \"roo> \";", "modifier": "protected static final", "type": "String", "declarator": "ROO_PROMPT = \"roo> \"", "var_name": "ROO_PROMPT"}, {"original_string": "public static String completionKeys = \"TAB\";", "modifier": "public static", "type": "String", "declarator": "completionKeys = \"TAB\"", "var_name": "completionKeys"}, {"original_string": "public static String shellPrompt = ROO_PROMPT;", "modifier": "public static", "type": "String", "declarator": "shellPrompt = ROO_PROMPT", "var_name": "shellPrompt"}, {"original_string": "protected final Logger logger = HandlerUtils.getLogger(getClass());", "modifier": "protected final", "type": "Logger", "declarator": "logger = HandlerUtils.getLogger(getClass())", "var_name": "logger"}, {"original_string": "protected boolean inBlockComment;", "modifier": "protected", "type": "boolean", "declarator": "inBlockComment", "var_name": "inBlockComment"}, {"original_string": "protected ExitShellRequest exitShellRequest;", "modifier": "protected", "type": "ExitShellRequest", "declarator": "exitShellRequest", "var_name": "exitShellRequest"}, {"original_string": "private Tailor tailor;", "modifier": "private", "type": "Tailor", "declarator": "tailor", "var_name": "tailor"}], "methods": [{"identifier": "versionInfo", "parameters": "()", "modifiers": "public static", "return": "String", "signature": "String versionInfo()", "full_signature": "public static String versionInfo()", "class_method_signature": "AbstractShell.versionInfo()", "testcase": false, "constructor": false}, {"identifier": "buildInfo", "parameters": "()", "modifiers": "public static", "return": "String", "signature": "String buildInfo()", "full_signature": "public static String buildInfo()", "class_method_signature": "AbstractShell.buildInfo()", "testcase": false, "constructor": false}, {"identifier": "versionInfoWithoutGit", "parameters": "()", "modifiers": "public static", "return": "String", "signature": "String versionInfoWithoutGit()", "full_signature": "public static String versionInfoWithoutGit()", "class_method_signature": "AbstractShell.versionInfoWithoutGit()", "testcase": false, "constructor": false}, {"identifier": "blockCommentBegin", "parameters": "()", "modifiers": "@CliCommand(value = {\"/*\"}, help = \"Start of block comment\") public", "return": "void", "signature": "void blockCommentBegin()", "full_signature": "@CliCommand(value = {\"/*\"}, help = \"Start of block comment\") public void blockCommentBegin()", "class_method_signature": "AbstractShell.blockCommentBegin()", "testcase": false, "constructor": false}, {"identifier": "blockCommentFinish", "parameters": "()", "modifiers": "@CliCommand(value = {\"*/\"}, help = \"End of block comment\") public", "return": "void", "signature": "void blockCommentFinish()", "full_signature": "@CliCommand(value = {\"*/\"}, help = \"End of block comment\") public void blockCommentFinish()", "class_method_signature": "AbstractShell.blockCommentFinish()", "testcase": false, "constructor": false}, {"identifier": "date", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String date()", "full_signature": "public String date()", "class_method_signature": "AbstractShell.date()", "testcase": false, "constructor": false}, {"identifier": "executeCommand", "parameters": "(final String line)", "modifiers": "public", "return": "boolean", "signature": "boolean executeCommand(final String line)", "full_signature": "public boolean executeCommand(final String line)", "class_method_signature": "AbstractShell.executeCommand(final String line)", "testcase": false, "constructor": false}, {"identifier": "executeCommandImpl", "parameters": "(String line)", "modifiers": "private", "return": "boolean", "signature": "boolean executeCommandImpl(String line)", "full_signature": "private boolean executeCommandImpl(String line)", "class_method_signature": "AbstractShell.executeCommandImpl(String line)", "testcase": false, "constructor": false}, {"identifier": "executeScriptLine", "parameters": "(final String line)", "modifiers": "protected", "return": "boolean", "signature": "boolean executeScriptLine(final String line)", "full_signature": "protected boolean executeScriptLine(final String line)", "class_method_signature": "AbstractShell.executeScriptLine(final String line)", "testcase": false, "constructor": false}, {"identifier": "findResources", "parameters": "(String path)", "modifiers": "protected abstract", "return": "Collection<URL>", "signature": "Collection<URL> findResources(String path)", "full_signature": "protected abstract Collection<URL> findResources(String path)", "class_method_signature": "AbstractShell.findResources(String path)", "testcase": false, "constructor": false}, {"identifier": "flash", "parameters": "(final Level level, final String message, final String slot)", "modifiers": "public", "return": "void", "signature": "void flash(final Level level, final String message, final String slot)", "full_signature": "public void flash(final Level level, final String message, final String slot)", "class_method_signature": "AbstractShell.flash(final Level level, final String message, final String slot)", "testcase": false, "constructor": false}, {"identifier": "getExecutionStrategy", "parameters": "()", "modifiers": "protected abstract", "return": "ExecutionStrategy", "signature": "ExecutionStrategy getExecutionStrategy()", "full_signature": "protected abstract ExecutionStrategy getExecutionStrategy()", "class_method_signature": "AbstractShell.getExecutionStrategy()", "testcase": false, "constructor": false}, {"identifier": "getExitShellRequest", "parameters": "()", "modifiers": "public", "return": "ExitShellRequest", "signature": "ExitShellRequest getExitShellRequest()", "full_signature": "public ExitShellRequest getExitShellRequest()", "class_method_signature": "AbstractShell.getExitShellRequest()", "testcase": false, "constructor": false}, {"identifier": "getHome", "parameters": "()", "modifiers": "public", "return": "File", "signature": "File getHome()", "full_signature": "public File getHome()", "class_method_signature": "AbstractShell.getHome()", "testcase": false, "constructor": false}, {"identifier": "getHomeAsString", "parameters": "()", "modifiers": "protected abstract", "return": "String", "signature": "String getHomeAsString()", "full_signature": "protected abstract String getHomeAsString()", "class_method_signature": "AbstractShell.getHomeAsString()", "testcase": false, "constructor": false}, {"identifier": "getParser", "parameters": "()", "modifiers": "protected abstract", "return": "Parser", "signature": "Parser getParser()", "full_signature": "protected abstract Parser getParser()", "class_method_signature": "AbstractShell.getParser()", "testcase": false, "constructor": false}, {"identifier": "getShellPrompt", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getShellPrompt()", "full_signature": "public String getShellPrompt()", "class_method_signature": "AbstractShell.getShellPrompt()", "testcase": false, "constructor": false}, {"identifier": "inlineComment", "parameters": "()", "modifiers": "@CliCommand(value = {\"//\", \";\"}, help = \"Inline comment markers (start of line only)\") public", "return": "void", "signature": "void inlineComment()", "full_signature": "@CliCommand(value = {\"//\", \";\"}, help = \"Inline comment markers (start of line only)\") public void inlineComment()", "class_method_signature": "AbstractShell.inlineComment()", "testcase": false, "constructor": false}, {"identifier": "logCommandIfRequired", "parameters": "(final String line, final boolean successful)", "modifiers": "protected", "return": "void", "signature": "void logCommandIfRequired(final String line, final boolean successful)", "full_signature": "protected void logCommandIfRequired(final String line, final boolean successful)", "class_method_signature": "AbstractShell.logCommandIfRequired(final String line, final boolean successful)", "testcase": false, "constructor": false}, {"identifier": "logCommandToOutput", "parameters": "(final String processedLine)", "modifiers": "protected", "return": "void", "signature": "void logCommandToOutput(final String processedLine)", "full_signature": "protected void logCommandToOutput(final String processedLine)", "class_method_signature": "AbstractShell.logCommandToOutput(final String processedLine)", "testcase": false, "constructor": false}, {"identifier": "openScript", "parameters": "(final File script)", "modifiers": "private", "return": "InputStream", "signature": "InputStream openScript(final File script)", "full_signature": "private InputStream openScript(final File script)", "class_method_signature": "AbstractShell.openScript(final File script)", "testcase": false, "constructor": false}, {"identifier": "props", "parameters": "()", "modifiers": "@CliCommand(value = {\"system properties\"}, help = \"Shows the shell's properties such as if \" + \"'addon development mode' is enabled, JVM version, file encoding...\") public", "return": "String", "signature": "String props()", "full_signature": "@CliCommand(value = {\"system properties\"}, help = \"Shows the shell's properties such as if \" + \"'addon development mode' is enabled, JVM version, file encoding...\") public String props()", "class_method_signature": "AbstractShell.props()", "testcase": false, "constructor": false}, {"identifier": "round", "parameters": "(final double valueToRound, final int numberOfDecimalPlaces)", "modifiers": "private", "return": "double", "signature": "double round(final double valueToRound, final int numberOfDecimalPlaces)", "full_signature": "private double round(final double valueToRound, final int numberOfDecimalPlaces)", "class_method_signature": "AbstractShell.round(final double valueToRound, final int numberOfDecimalPlaces)", "testcase": false, "constructor": false}, {"identifier": "script", "parameters": "(\n      @CliOption(key = {\"\", \"file\"}, help = \"The file to locate and execute.\", mandatory = true) final File script,\n      @CliOption(key = \"lineNumbers\", mandatory = false, specifiedDefaultValue = \"true\",\n          unspecifiedDefaultValue = \"false\",\n          help = \"Display line numbers when executing the script. \"\n              + \"Default if option present: `true`; default if option not present: `false`.\") final boolean lineNumbers,\n      @CliOption(key = \"ignoreLines\", mandatory = false,\n          help = \"Comma-list of prefixes to ignore the lines that starts with any of the provided \"\n              + \"case-sensitive prefixes.\") final String ignoreLines)", "modifiers": "@CliCommand( value = {\"script\"}, help = \"Parses the specified resource file and executes its Roo commands. You can as well execute \" + \"_*.roo_ example scripts in the Roo classpath. Ex.: `script --file clinic.roo`.\") public", "return": "void", "signature": "void script(\n      @CliOption(key = {\"\", \"file\"}, help = \"The file to locate and execute.\", mandatory = true) final File script,\n      @CliOption(key = \"lineNumbers\", mandatory = false, specifiedDefaultValue = \"true\",\n          unspecifiedDefaultValue = \"false\",\n          help = \"Display line numbers when executing the script. \"\n              + \"Default if option present: `true`; default if option not present: `false`.\") final boolean lineNumbers,\n      @CliOption(key = \"ignoreLines\", mandatory = false,\n          help = \"Comma-list of prefixes to ignore the lines that starts with any of the provided \"\n              + \"case-sensitive prefixes.\") final String ignoreLines)", "full_signature": "@CliCommand( value = {\"script\"}, help = \"Parses the specified resource file and executes its Roo commands. You can as well execute \" + \"_*.roo_ example scripts in the Roo classpath. Ex.: `script --file clinic.roo`.\") public void script(\n      @CliOption(key = {\"\", \"file\"}, help = \"The file to locate and execute.\", mandatory = true) final File script,\n      @CliOption(key = \"lineNumbers\", mandatory = false, specifiedDefaultValue = \"true\",\n          unspecifiedDefaultValue = \"false\",\n          help = \"Display line numbers when executing the script. \"\n              + \"Default if option present: `true`; default if option not present: `false`.\") final boolean lineNumbers,\n      @CliOption(key = \"ignoreLines\", mandatory = false,\n          help = \"Comma-list of prefixes to ignore the lines that starts with any of the provided \"\n              + \"case-sensitive prefixes.\") final String ignoreLines)", "class_method_signature": "AbstractShell.script(\n      @CliOption(key = {\"\", \"file\"}, help = \"The file to locate and execute.\", mandatory = true) final File script,\n      @CliOption(key = \"lineNumbers\", mandatory = false, specifiedDefaultValue = \"true\",\n          unspecifiedDefaultValue = \"false\",\n          help = \"Display line numbers when executing the script. \"\n              + \"Default if option present: `true`; default if option not present: `false`.\") final boolean lineNumbers,\n      @CliOption(key = \"ignoreLines\", mandatory = false,\n          help = \"Comma-list of prefixes to ignore the lines that starts with any of the provided \"\n              + \"case-sensitive prefixes.\") final String ignoreLines)", "testcase": false, "constructor": false}, {"identifier": "setPromptPath", "parameters": "(final String path)", "modifiers": "public", "return": "void", "signature": "void setPromptPath(final String path)", "full_signature": "public void setPromptPath(final String path)", "class_method_signature": "AbstractShell.setPromptPath(final String path)", "testcase": false, "constructor": false}, {"identifier": "setRooPrompt", "parameters": "(final String prompt)", "modifiers": "public", "return": "void", "signature": "void setRooPrompt(final String prompt)", "full_signature": "public void setRooPrompt(final String prompt)", "class_method_signature": "AbstractShell.setRooPrompt(final String prompt)", "testcase": false, "constructor": false}, {"identifier": "setPromptPath", "parameters": "(final String path, final boolean overrideStyle)", "modifiers": "public", "return": "void", "signature": "void setPromptPath(final String path, final boolean overrideStyle)", "full_signature": "public void setPromptPath(final String path, final boolean overrideStyle)", "class_method_signature": "AbstractShell.setPromptPath(final String path, final boolean overrideStyle)", "testcase": false, "constructor": false}, {"identifier": "setTailor", "parameters": "(final Tailor tailor)", "modifiers": "public", "return": "void", "signature": "void setTailor(final Tailor tailor)", "full_signature": "public void setTailor(final Tailor tailor)", "class_method_signature": "AbstractShell.setTailor(final Tailor tailor)", "testcase": false, "constructor": false}, {"identifier": "addListerner", "parameters": "(CommandListener listener)", "modifiers": "@Override public", "return": "void", "signature": "void addListerner(CommandListener listener)", "full_signature": "@Override public void addListerner(CommandListener listener)", "class_method_signature": "AbstractShell.addListerner(CommandListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeListener", "parameters": "(CommandListener listener)", "modifiers": "@Override public", "return": "void", "signature": "void removeListener(CommandListener listener)", "full_signature": "@Override public void removeListener(CommandListener listener)", "class_method_signature": "AbstractShell.removeListener(CommandListener listener)", "testcase": false, "constructor": false}, {"identifier": "notifyExecutionFailed", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void notifyExecutionFailed()", "full_signature": "private void notifyExecutionFailed()", "class_method_signature": "AbstractShell.notifyExecutionFailed()", "testcase": false, "constructor": false}, {"identifier": "notifyExecutionSuccess", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void notifyExecutionSuccess()", "full_signature": "private void notifyExecutionSuccess()", "class_method_signature": "AbstractShell.notifyExecutionSuccess()", "testcase": false, "constructor": false}, {"identifier": "notifyBeginExecute", "parameters": "(ParseResult parseResult)", "modifiers": "private", "return": "void", "signature": "void notifyBeginExecute(ParseResult parseResult)", "full_signature": "private void notifyBeginExecute(ParseResult parseResult)", "class_method_signature": "AbstractShell.notifyBeginExecute(ParseResult parseResult)", "testcase": false, "constructor": false}, {"identifier": "version", "parameters": "(\n      @CliOption(key = \"\", help = \"Special version flags, like `roorocks`.\") final String extra)", "modifiers": "@CliCommand(value = {\"version\"}, help = \"Displays Roo Shell banner and version.\") public", "return": "String", "signature": "String version(\n      @CliOption(key = \"\", help = \"Special version flags, like `roorocks`.\") final String extra)", "full_signature": "@CliCommand(value = {\"version\"}, help = \"Displays Roo Shell banner and version.\") public String version(\n      @CliOption(key = \"\", help = \"Special version flags, like `roorocks`.\") final String extra)", "class_method_signature": "AbstractShell.version(\n      @CliOption(key = \"\", help = \"Special version flags, like `roorocks`.\") final String extra)", "testcase": false, "constructor": false}], "file": "runtime/shell/src/main/java/org/springframework/roo/shell/AbstractShell.java"}, "focal_method": {"identifier": "props", "parameters": "()", "modifiers": "@CliCommand(value = {\"system properties\"}, help = \"Shows the shell's properties such as if \" + \"'addon development mode' is enabled, JVM version, file encoding...\") public", "return": "String", "body": "@CliCommand(value = {\"system properties\"}, help = \"Shows the shell's properties such as if \"\n      + \"'addon development mode' is enabled, JVM version, file encoding...\")\n  public String props() {\n    final Set<String> data = new TreeSet<String>();\n    for (final Entry<Object, Object> entry : System.getProperties().entrySet()) {\n      data.add(entry.getKey() + \" = \" + entry.getValue());\n    }\n\n    return StringUtils.join(data, LINE_SEPARATOR) + LINE_SEPARATOR;\n  }", "signature": "String props()", "full_signature": "@CliCommand(value = {\"system properties\"}, help = \"Shows the shell's properties such as if \" + \"'addon development mode' is enabled, JVM version, file encoding...\") public String props()", "class_method_signature": "AbstractShell.props()", "testcase": false, "constructor": false, "invocations": ["entrySet", "getProperties", "add", "getKey", "getValue", "join"]}, "repository": {"repo_id": 2304277, "url": "https://github.com/spring-projects/spring-roo", "language": "Java", "is_fork": false, "fork_count": 303, "stargazer_count": 661, "size": 40033, "license": "licensed"}}