{"test_class": {"identifier": "DFAsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final boolean[] VECTOR_1 = {true, true, false, false};", "modifier": "private static final", "type": "boolean[]", "declarator": "VECTOR_1 = {true, true, false, false}", "var_name": "VECTOR_1"}, {"original_string": "private static final boolean[] VECTOR_1_NEG = {false, false, true, true};", "modifier": "private static final", "type": "boolean[]", "declarator": "VECTOR_1_NEG = {false, false, true, true}", "var_name": "VECTOR_1_NEG"}, {"original_string": "private static final boolean[] VECTOR_2 = {true, false, true, false};", "modifier": "private static final", "type": "boolean[]", "declarator": "VECTOR_2 = {true, false, true, false}", "var_name": "VECTOR_2"}, {"original_string": "private static final boolean[] AND_RESULT = {true, false, false, false};", "modifier": "private static final", "type": "boolean[]", "declarator": "AND_RESULT = {true, false, false, false}", "var_name": "AND_RESULT"}, {"original_string": "private static final boolean[] OR_RESULT = {true, true, true, false};", "modifier": "private static final", "type": "boolean[]", "declarator": "OR_RESULT = {true, true, true, false}", "var_name": "OR_RESULT"}, {"original_string": "private static final boolean[] XOR_RESULT = {false, true, true, false};", "modifier": "private static final", "type": "boolean[]", "declarator": "XOR_RESULT = {false, true, true, false}", "var_name": "XOR_RESULT"}, {"original_string": "private static final boolean[] EQUIV_RESULT = {true, false, false, true};", "modifier": "private static final", "type": "boolean[]", "declarator": "EQUIV_RESULT = {true, false, false, true}", "var_name": "EQUIV_RESULT"}, {"original_string": "private static final boolean[] IMPL_RESULT = {true, false, true, true};", "modifier": "private static final", "type": "boolean[]", "declarator": "IMPL_RESULT = {true, false, true, true}", "var_name": "IMPL_RESULT"}, {"original_string": "private final Alphabet<Integer> testAlphabet;", "modifier": "private final", "type": "Alphabet<Integer>", "declarator": "testAlphabet", "var_name": "testAlphabet"}, {"original_string": "private CompactDFA<Integer> testDfa1, testDfa2;", "modifier": "private", "type": "CompactDFA<Integer>", "declarator": "testDfa1", "var_name": "testDfa1"}], "file": "util/src/test/java/net/automatalib/util/automata/fsa/DFAsTest.java"}, "test_case": {"identifier": "testAcceptsEmptyLanguage", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testAcceptsEmptyLanguage() {\n        Assert.assertTrue(DFAs.acceptsEmptyLanguage(forVector(false)));\n\n        Assert.assertFalse(DFAs.acceptsEmptyLanguage(forVector(true)));\n    }", "signature": "void testAcceptsEmptyLanguage()", "full_signature": "@Test public void testAcceptsEmptyLanguage()", "class_method_signature": "DFAsTest.testAcceptsEmptyLanguage()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "acceptsEmptyLanguage", "forVector", "assertFalse", "acceptsEmptyLanguage", "forVector"]}, "focal_class": {"identifier": "DFAs", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "DFAs", "parameters": "()", "modifiers": "private", "return": "", "signature": " DFAs()", "full_signature": "private  DFAs()", "class_method_signature": "DFAs.DFAs()", "testcase": false, "constructor": true}, {"identifier": "combine", "parameters": "(DFA<?, I> dfa1,\n                                            DFA<?, I> dfa2,\n                                            Alphabet<I> inputAlphabet,\n                                            AcceptanceCombiner combiner)", "modifiers": "public static", "return": "CompactDFA<I>", "signature": "CompactDFA<I> combine(DFA<?, I> dfa1,\n                                            DFA<?, I> dfa2,\n                                            Alphabet<I> inputAlphabet,\n                                            AcceptanceCombiner combiner)", "full_signature": "public static CompactDFA<I> combine(DFA<?, I> dfa1,\n                                            DFA<?, I> dfa2,\n                                            Alphabet<I> inputAlphabet,\n                                            AcceptanceCombiner combiner)", "class_method_signature": "DFAs.combine(DFA<?, I> dfa1,\n                                            DFA<?, I> dfa2,\n                                            Alphabet<I> inputAlphabet,\n                                            AcceptanceCombiner combiner)", "testcase": false, "constructor": false}, {"identifier": "combine", "parameters": "(DFA<?, I> dfa1,\n                                                               DFA<?, I> dfa2,\n                                                               Collection<? extends I> inputs,\n                                                               A out,\n                                                               AcceptanceCombiner combiner)", "modifiers": "public static", "return": "A", "signature": "A combine(DFA<?, I> dfa1,\n                                                               DFA<?, I> dfa2,\n                                                               Collection<? extends I> inputs,\n                                                               A out,\n                                                               AcceptanceCombiner combiner)", "full_signature": "public static A combine(DFA<?, I> dfa1,\n                                                               DFA<?, I> dfa2,\n                                                               Collection<? extends I> inputs,\n                                                               A out,\n                                                               AcceptanceCombiner combiner)", "class_method_signature": "DFAs.combine(DFA<?, I> dfa1,\n                                                               DFA<?, I> dfa2,\n                                                               Collection<? extends I> inputs,\n                                                               A out,\n                                                               AcceptanceCombiner combiner)", "testcase": false, "constructor": false}, {"identifier": "and", "parameters": "(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "modifiers": "public static", "return": "CompactDFA<I>", "signature": "CompactDFA<I> and(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "full_signature": "public static CompactDFA<I> and(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "class_method_signature": "DFAs.and(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "testcase": false, "constructor": false}, {"identifier": "and", "parameters": "(DFA<?, I> dfa1,\n                                                           DFA<?, I> dfa2,\n                                                           Collection<? extends I> inputs,\n                                                           A out)", "modifiers": "public static", "return": "A", "signature": "A and(DFA<?, I> dfa1,\n                                                           DFA<?, I> dfa2,\n                                                           Collection<? extends I> inputs,\n                                                           A out)", "full_signature": "public static A and(DFA<?, I> dfa1,\n                                                           DFA<?, I> dfa2,\n                                                           Collection<? extends I> inputs,\n                                                           A out)", "class_method_signature": "DFAs.and(DFA<?, I> dfa1,\n                                                           DFA<?, I> dfa2,\n                                                           Collection<? extends I> inputs,\n                                                           A out)", "testcase": false, "constructor": false}, {"identifier": "or", "parameters": "(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "modifiers": "public static", "return": "CompactDFA<I>", "signature": "CompactDFA<I> or(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "full_signature": "public static CompactDFA<I> or(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "class_method_signature": "DFAs.or(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "testcase": false, "constructor": false}, {"identifier": "or", "parameters": "(DFA<?, I> dfa1,\n                                                          DFA<?, I> dfa2,\n                                                          Collection<? extends I> inputs,\n                                                          A out)", "modifiers": "public static", "return": "A", "signature": "A or(DFA<?, I> dfa1,\n                                                          DFA<?, I> dfa2,\n                                                          Collection<? extends I> inputs,\n                                                          A out)", "full_signature": "public static A or(DFA<?, I> dfa1,\n                                                          DFA<?, I> dfa2,\n                                                          Collection<? extends I> inputs,\n                                                          A out)", "class_method_signature": "DFAs.or(DFA<?, I> dfa1,\n                                                          DFA<?, I> dfa2,\n                                                          Collection<? extends I> inputs,\n                                                          A out)", "testcase": false, "constructor": false}, {"identifier": "xor", "parameters": "(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "modifiers": "public static", "return": "CompactDFA<I>", "signature": "CompactDFA<I> xor(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "full_signature": "public static CompactDFA<I> xor(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "class_method_signature": "DFAs.xor(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "testcase": false, "constructor": false}, {"identifier": "xor", "parameters": "(DFA<?, I> dfa1,\n                                                           DFA<?, I> dfa2,\n                                                           Collection<? extends I> inputs,\n                                                           A out)", "modifiers": "public static", "return": "A", "signature": "A xor(DFA<?, I> dfa1,\n                                                           DFA<?, I> dfa2,\n                                                           Collection<? extends I> inputs,\n                                                           A out)", "full_signature": "public static A xor(DFA<?, I> dfa1,\n                                                           DFA<?, I> dfa2,\n                                                           Collection<? extends I> inputs,\n                                                           A out)", "class_method_signature": "DFAs.xor(DFA<?, I> dfa1,\n                                                           DFA<?, I> dfa2,\n                                                           Collection<? extends I> inputs,\n                                                           A out)", "testcase": false, "constructor": false}, {"identifier": "equiv", "parameters": "(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "modifiers": "public static", "return": "CompactDFA<I>", "signature": "CompactDFA<I> equiv(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "full_signature": "public static CompactDFA<I> equiv(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "class_method_signature": "DFAs.equiv(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "testcase": false, "constructor": false}, {"identifier": "equiv", "parameters": "(DFA<?, I> dfa1,\n                                                             DFA<?, I> dfa2,\n                                                             Collection<? extends I> inputs,\n                                                             A out)", "modifiers": "public static", "return": "A", "signature": "A equiv(DFA<?, I> dfa1,\n                                                             DFA<?, I> dfa2,\n                                                             Collection<? extends I> inputs,\n                                                             A out)", "full_signature": "public static A equiv(DFA<?, I> dfa1,\n                                                             DFA<?, I> dfa2,\n                                                             Collection<? extends I> inputs,\n                                                             A out)", "class_method_signature": "DFAs.equiv(DFA<?, I> dfa1,\n                                                             DFA<?, I> dfa2,\n                                                             Collection<? extends I> inputs,\n                                                             A out)", "testcase": false, "constructor": false}, {"identifier": "impl", "parameters": "(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "modifiers": "public static", "return": "CompactDFA<I>", "signature": "CompactDFA<I> impl(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "full_signature": "public static CompactDFA<I> impl(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "class_method_signature": "DFAs.impl(DFA<?, I> dfa1, DFA<?, I> dfa2, Alphabet<I> inputAlphabet)", "testcase": false, "constructor": false}, {"identifier": "impl", "parameters": "(DFA<?, I> dfa1,\n                                                            DFA<?, I> dfa2,\n                                                            Collection<? extends I> inputs,\n                                                            A out)", "modifiers": "public static", "return": "A", "signature": "A impl(DFA<?, I> dfa1,\n                                                            DFA<?, I> dfa2,\n                                                            Collection<? extends I> inputs,\n                                                            A out)", "full_signature": "public static A impl(DFA<?, I> dfa1,\n                                                            DFA<?, I> dfa2,\n                                                            Collection<? extends I> inputs,\n                                                            A out)", "class_method_signature": "DFAs.impl(DFA<?, I> dfa1,\n                                                            DFA<?, I> dfa2,\n                                                            Collection<? extends I> inputs,\n                                                            A out)", "testcase": false, "constructor": false}, {"identifier": "complement", "parameters": "(DFA<?, I> dfa, Alphabet<I> inputAlphabet)", "modifiers": "public static", "return": "CompactDFA<I>", "signature": "CompactDFA<I> complement(DFA<?, I> dfa, Alphabet<I> inputAlphabet)", "full_signature": "public static CompactDFA<I> complement(DFA<?, I> dfa, Alphabet<I> inputAlphabet)", "class_method_signature": "DFAs.complement(DFA<?, I> dfa, Alphabet<I> inputAlphabet)", "testcase": false, "constructor": false}, {"identifier": "complement", "parameters": "(DFA<?, I> dfa,\n                                                                  Collection<? extends I> inputs,\n                                                                  A out)", "modifiers": "public static", "return": "A", "signature": "A complement(DFA<?, I> dfa,\n                                                                  Collection<? extends I> inputs,\n                                                                  A out)", "full_signature": "public static A complement(DFA<?, I> dfa,\n                                                                  Collection<? extends I> inputs,\n                                                                  A out)", "class_method_signature": "DFAs.complement(DFA<?, I> dfa,\n                                                                  Collection<? extends I> inputs,\n                                                                  A out)", "testcase": false, "constructor": false}, {"identifier": "complete", "parameters": "(DFA<?, I> dfa, Alphabet<I> inputs)", "modifiers": "public static", "return": "CompactDFA<I>", "signature": "CompactDFA<I> complete(DFA<?, I> dfa, Alphabet<I> inputs)", "full_signature": "public static CompactDFA<I> complete(DFA<?, I> dfa, Alphabet<I> inputs)", "class_method_signature": "DFAs.complete(DFA<?, I> dfa, Alphabet<I> inputs)", "testcase": false, "constructor": false}, {"identifier": "complete", "parameters": "(DFA<?, I> dfa, Collection<? extends I> inputs, A out)", "modifiers": "public static", "return": "A", "signature": "A complete(DFA<?, I> dfa, Collection<? extends I> inputs, A out)", "full_signature": "public static A complete(DFA<?, I> dfa, Collection<? extends I> inputs, A out)", "class_method_signature": "DFAs.complete(DFA<?, I> dfa, Collection<? extends I> inputs, A out)", "testcase": false, "constructor": false}, {"identifier": "minimize", "parameters": "(DFA<?, I> dfa, Alphabet<I> alphabet)", "modifiers": "public static", "return": "CompactDFA<I>", "signature": "CompactDFA<I> minimize(DFA<?, I> dfa, Alphabet<I> alphabet)", "full_signature": "public static CompactDFA<I> minimize(DFA<?, I> dfa, Alphabet<I> alphabet)", "class_method_signature": "DFAs.minimize(DFA<?, I> dfa, Alphabet<I> alphabet)", "testcase": false, "constructor": false}, {"identifier": "minimize", "parameters": "(A dfa)", "modifiers": "public static", "return": "CompactDFA<I>", "signature": "CompactDFA<I> minimize(A dfa)", "full_signature": "public static CompactDFA<I> minimize(A dfa)", "class_method_signature": "DFAs.minimize(A dfa)", "testcase": false, "constructor": false}, {"identifier": "isPrefixClosed", "parameters": "(DFA<S, I> dfa, Alphabet<I> alphabet)", "modifiers": "public static", "return": "boolean", "signature": "boolean isPrefixClosed(DFA<S, I> dfa, Alphabet<I> alphabet)", "full_signature": "public static boolean isPrefixClosed(DFA<S, I> dfa, Alphabet<I> alphabet)", "class_method_signature": "DFAs.isPrefixClosed(DFA<S, I> dfa, Alphabet<I> alphabet)", "testcase": false, "constructor": false}, {"identifier": "acceptsEmptyLanguage", "parameters": "(DFA<S, ?> dfa)", "modifiers": "public static", "return": "boolean", "signature": "boolean acceptsEmptyLanguage(DFA<S, ?> dfa)", "full_signature": "public static boolean acceptsEmptyLanguage(DFA<S, ?> dfa)", "class_method_signature": "DFAs.acceptsEmptyLanguage(DFA<S, ?> dfa)", "testcase": false, "constructor": false}], "file": "util/src/main/java/net/automatalib/util/automata/fsa/DFAs.java"}, "focal_method": {"identifier": "acceptsEmptyLanguage", "parameters": "(DFA<S, ?> dfa)", "modifiers": "public static", "return": "boolean", "body": "public static <S> boolean acceptsEmptyLanguage(DFA<S, ?> dfa) {\n        return dfa.getStates().stream().noneMatch(dfa::isAccepting);\n    }", "signature": "boolean acceptsEmptyLanguage(DFA<S, ?> dfa)", "full_signature": "public static boolean acceptsEmptyLanguage(DFA<S, ?> dfa)", "class_method_signature": "DFAs.acceptsEmptyLanguage(DFA<S, ?> dfa)", "testcase": false, "constructor": false, "invocations": ["noneMatch", "stream", "getStates"]}, "repository": {"repo_id": 8791847, "url": "https://github.com/LearnLib/automatalib", "language": "Java", "is_fork": false, "fork_count": 18, "stargazer_count": 54, "size": 31221, "license": "licensed"}}