{"test_class": {"identifier": "FieldParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String COLUMN_NAME = \"c1\";", "modifier": "private static final", "type": "String", "declarator": "COLUMN_NAME = \"c1\"", "var_name": "COLUMN_NAME"}, {"original_string": "private static final String EMPTY_STRING = \"\";", "modifier": "private static final", "type": "String", "declarator": "EMPTY_STRING = \"\"", "var_name": "EMPTY_STRING"}], "file": "storage-engine-backends/hbase/src/test/java/com/nearinfinity/honeycomb/hbase/bulkload/FieldParserTest.java"}, "test_case": {"identifier": "testParseValidDateFormats", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testParseValidDateFormats() throws ParseException {\n        ColumnSchema schema = ColumnSchema\n                .builder(COLUMN_NAME, ColumnType.DATE)\n                .build();\n\n        final String expectedParsedDate = \"1989-05-13\";\n\n        final List<String> formats = ImmutableList.of(expectedParsedDate,\n                \"1989.05.13\", \"1989/05/13\", \"19890513\");\n\n        for (final String format : formats) {\n            assertEquals(ByteBuffer.wrap(expectedParsedDate.getBytes()),\n                    FieldParser.parse(format, schema));\n        }\n    }", "signature": "void testParseValidDateFormats()", "full_signature": "@Test public void testParseValidDateFormats()", "class_method_signature": "FieldParserTest.testParseValidDateFormats()", "testcase": true, "constructor": false, "invocations": ["build", "builder", "of", "assertEquals", "wrap", "getBytes", "parse"]}, "focal_class": {"identifier": "FieldParser", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "FieldParser", "parameters": "()", "modifiers": "private", "return": "", "signature": " FieldParser()", "full_signature": "private  FieldParser()", "class_method_signature": "FieldParser.FieldParser()", "testcase": false, "constructor": true}, {"identifier": "parse", "parameters": "(String val, ColumnSchema schema)", "modifiers": "public static", "return": "ByteBuffer", "signature": "ByteBuffer parse(String val, ColumnSchema schema)", "full_signature": "public static ByteBuffer parse(String val, ColumnSchema schema)", "class_method_signature": "FieldParser.parse(String val, ColumnSchema schema)", "testcase": false, "constructor": false}, {"identifier": "bytesFromDigits", "parameters": "(int digits)", "modifiers": "static", "return": "int", "signature": "int bytesFromDigits(int digits)", "full_signature": "static int bytesFromDigits(int digits)", "class_method_signature": "FieldParser.bytesFromDigits(int digits)", "testcase": false, "constructor": false}, {"identifier": "extractDate", "parameters": "(String val, String dateFormat,\n                                          String... parseFormats)", "modifiers": "private static", "return": "ByteBuffer", "signature": "ByteBuffer extractDate(String val, String dateFormat,\n                                          String... parseFormats)", "full_signature": "private static ByteBuffer extractDate(String val, String dateFormat,\n                                          String... parseFormats)", "class_method_signature": "FieldParser.extractDate(String val, String dateFormat,\n                                          String... parseFormats)", "testcase": false, "constructor": false}, {"identifier": "extractDecimal", "parameters": "(String val, int precision, int right_scale)", "modifiers": "private static", "return": "ByteBuffer", "signature": "ByteBuffer extractDecimal(String val, int precision, int right_scale)", "full_signature": "private static ByteBuffer extractDecimal(String val, int precision, int right_scale)", "class_method_signature": "FieldParser.extractDecimal(String val, int precision, int right_scale)", "testcase": false, "constructor": false}], "file": "storage-engine-backends/hbase/src/main/java/com/nearinfinity/honeycomb/hbase/bulkload/FieldParser.java"}, "focal_method": {"identifier": "parse", "parameters": "(String val, ColumnSchema schema)", "modifiers": "public static", "return": "ByteBuffer", "body": "public static ByteBuffer parse(String val, ColumnSchema schema) throws ParseException {\n        checkNotNull(val, \"Should not be parsing null. Something went terribly wrong.\");\n        checkNotNull(schema, \"Column metadata is null.\");\n\n        ColumnType type = schema.getType();\n\n        if (val.length() == 0 && type != ColumnType.STRING\n                && type != ColumnType.BINARY) {\n            if (schema.getIsNullable()) {\n                return null;\n            }\n\n            throw new IllegalArgumentException(\"Expected a value for a\" +\n                    \" non-null SQL column, but no value was given.\");\n        }\n\n        switch (type) {\n            case LONG:\n                return ByteBuffer.wrap(Longs.toByteArray(Long.parseLong(val)));\n            case ULONG:\n                BigInteger n = new BigInteger(val);\n                if (n.compareTo(BigInteger.ZERO) == -1) {\n                    throw new IllegalArgumentException(\"negative value provided for unsigned column. value: \" + val);\n                }\n                return ByteBuffer.wrap(Longs.toByteArray(n.longValue()));\n            case DOUBLE:\n                return ByteBuffer.wrap(Bytes.toBytes(Double.parseDouble(val)));\n            case DATE:\n                return extractDate(val, \"yyyy-MM-dd\",\n                        \"yyyy-MM-dd\",\n                        \"yyyy/MM/dd\",\n                        \"yyyy.MM.dd\",\n                        \"yyyyMMdd\");\n            case TIME:\n                return extractDate(val, \"HH:mm:ss\",\n                        \"HH:mm:ss\",\n                        \"HHmmss\");\n            case DATETIME:\n                return extractDate(val, \"yyyy-MM-dd HH:mm:ss\",\n                        \"yyyy-MM-dd HH:mm:ss\",\n                        \"yyyy/MM/dd HH:mm:ss\",\n                        \"yyyy.MM.dd HH:mm:ss\",\n                        \"yyyyMMdd HHmmss\");\n            case DECIMAL:\n                return extractDecimal(val, schema.getPrecision(), schema.getScale());\n            case STRING:\n            case BINARY:\n            default:\n                return ByteBuffer.wrap(val.getBytes(Charset.forName(\"UTF-8\")));\n        }\n    }", "signature": "ByteBuffer parse(String val, ColumnSchema schema)", "full_signature": "public static ByteBuffer parse(String val, ColumnSchema schema)", "class_method_signature": "FieldParser.parse(String val, ColumnSchema schema)", "testcase": false, "constructor": false, "invocations": ["checkNotNull", "checkNotNull", "getType", "length", "getIsNullable", "wrap", "toByteArray", "parseLong", "compareTo", "wrap", "toByteArray", "longValue", "wrap", "toBytes", "parseDouble", "extractDate", "extractDate", "extractDate", "extractDecimal", "getPrecision", "getScale", "wrap", "getBytes", "forName"]}, "repository": {"repo_id": 5171172, "url": "https://github.com/altamiracorp/honeycomb", "language": "Java", "is_fork": false, "fork_count": 22, "stargazer_count": 74, "size": 164956, "license": "licensed"}}