{"test_class": {"identifier": "ELUtilsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Bean bean = new Bean();", "modifier": "private", "type": "Bean", "declarator": "bean = new Bean()", "var_name": "bean"}, {"original_string": "private CompositeELResolver resolver;", "modifier": "private", "type": "CompositeELResolver", "declarator": "resolver", "var_name": "resolver"}, {"original_string": "private ELContextImpl context;", "modifier": "private", "type": "ELContextImpl", "declarator": "context", "var_name": "context"}], "file": "springfaces/src/test/java/org/springframework/springfaces/expression/el/ELUtilsTest.java"}, "test_case": {"identifier": "shouldGetTypeDescriptorForNested", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void shouldGetTypeDescriptorForNested() throws Exception {\n\t\tValueExpression valueExpression = newValueExpression(\"nested.collectionOfInteger\", Object.class);\n\t\tTypeDescriptor typeDescriptor = ELUtils.getTypeDescriptor(valueExpression, this.context);\n\t\tassertThat(typeDescriptor.getType(), is(equalTo((Class) Collection.class)));\n\t\tassertThat(typeDescriptor.isCollection(), is(true));\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor(), is(TypeDescriptor.valueOf(Integer.class)));\n\t}", "signature": "void shouldGetTypeDescriptorForNested()", "full_signature": "@Test public void shouldGetTypeDescriptorForNested()", "class_method_signature": "ELUtilsTest.shouldGetTypeDescriptorForNested()", "testcase": true, "constructor": false, "invocations": ["newValueExpression", "getTypeDescriptor", "assertThat", "getType", "is", "equalTo", "assertThat", "isCollection", "is", "assertThat", "getElementTypeDescriptor", "is", "valueOf"]}, "focal_class": {"identifier": "ELUtils", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "getTypeDescriptor", "parameters": "(ValueExpression valueExpression, ELContext elContext)", "modifiers": "public static", "return": "TypeDescriptor", "signature": "TypeDescriptor getTypeDescriptor(ValueExpression valueExpression, ELContext elContext)", "full_signature": "public static TypeDescriptor getTypeDescriptor(ValueExpression valueExpression, ELContext elContext)", "class_method_signature": "ELUtils.getTypeDescriptor(ValueExpression valueExpression, ELContext elContext)", "testcase": false, "constructor": false}, {"identifier": "getProperty", "parameters": "(ValueExpression valueExpression, ELContext elContext)", "modifiers": "public static", "return": "Property", "signature": "Property getProperty(ValueExpression valueExpression, ELContext elContext)", "full_signature": "public static Property getProperty(ValueExpression valueExpression, ELContext elContext)", "class_method_signature": "ELUtils.getProperty(ValueExpression valueExpression, ELContext elContext)", "testcase": false, "constructor": false}, {"identifier": "getProperty", "parameters": "(TrackedELContext trackedContext)", "modifiers": "private static", "return": "Property", "signature": "Property getProperty(TrackedELContext trackedContext)", "full_signature": "private static Property getProperty(TrackedELContext trackedContext)", "class_method_signature": "ELUtils.getProperty(TrackedELContext trackedContext)", "testcase": false, "constructor": false}], "file": "springfaces/src/main/java/org/springframework/springfaces/expression/el/ELUtils.java"}, "focal_method": {"identifier": "getTypeDescriptor", "parameters": "(ValueExpression valueExpression, ELContext elContext)", "modifiers": "public static", "return": "TypeDescriptor", "body": "public static TypeDescriptor getTypeDescriptor(ValueExpression valueExpression, ELContext elContext) {\n\t\tAssert.notNull(valueExpression, \"ValueExpression must not be null\");\n\t\tAssert.notNull(elContext, \"ELContext must not be null\");\n\t\tTrackedELContext trackedContext = new TrackedELContext(elContext);\n\t\tClass<?> type = valueExpression.getType(trackedContext);\n\t\tif (type == null) {\n\t\t\treturn null;\n\t\t}\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(type);\n\t\tif (typeDescriptor.isCollection() || typeDescriptor.isMap()) {\n\t\t\t// We may be able to obtain the generic type info by resolving the property directly\n\t\t\tif (trackedContext.hasValues()) {\n\t\t\t\ttry {\n\t\t\t\t\tProperty property = getProperty(trackedContext);\n\t\t\t\t\tif (property != null) {\n\t\t\t\t\t\ttypeDescriptor = new TypeDescriptor(property);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn typeDescriptor;\n\t}", "signature": "TypeDescriptor getTypeDescriptor(ValueExpression valueExpression, ELContext elContext)", "full_signature": "public static TypeDescriptor getTypeDescriptor(ValueExpression valueExpression, ELContext elContext)", "class_method_signature": "ELUtils.getTypeDescriptor(ValueExpression valueExpression, ELContext elContext)", "testcase": false, "constructor": false, "invocations": ["notNull", "notNull", "getType", "valueOf", "isCollection", "isMap", "hasValues", "getProperty"]}, "repository": {"repo_id": 1642369, "url": "https://github.com/philwebb/springfaces", "language": "Java", "is_fork": false, "fork_count": 25, "stargazer_count": 34, "size": 3761, "license": "licensed"}}