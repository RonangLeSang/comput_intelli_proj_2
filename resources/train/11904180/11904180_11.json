{"test_class": {"identifier": "JDBCFactoryTest", "superclass": "", "interfaces": "", "fields": [], "file": "cascading-jdbc-core/src/test/java/cascading/jdbc/JDBCFactoryTest.java"}, "test_case": {"identifier": "testCreateTapNoTableName", "parameters": "()", "modifiers": "@Test(expected = IllegalArgumentException.class) public", "return": "void", "body": "@Test(expected = IllegalArgumentException.class)\n  public void testCreateTapNoTableName()\n    {\n    String protocol = \"jdbc\";\n    String identifier = \"jdbc:some:stuf//database\";\n    JDBCScheme mockScheme = mock( JDBCScheme.class );\n\n    JDBCFactory factory = new JDBCFactory();\n\n    Properties props = new Properties();\n    props.setProperty( JDBCFactory.PROTOCOL_FIELD_SEPARATOR, \":\" );\n    props.setProperty( JDBCFactory.PROTOCOL_JDBC_DRIVER, \"some.Driver\" );\n    props.setProperty( JDBCFactory.PROTOCOL_JDBC_USER, \"username\" );\n    props.setProperty( JDBCFactory.PROTOCOL_JDBC_PASSWORD, \"password\" );\n\n    factory.createTap( protocol, mockScheme, identifier, SinkMode.REPLACE, props );\n    }", "signature": "void testCreateTapNoTableName()", "full_signature": "@Test(expected = IllegalArgumentException.class) public void testCreateTapNoTableName()", "class_method_signature": "JDBCFactoryTest.testCreateTapNoTableName()", "testcase": true, "constructor": false, "invocations": ["mock", "setProperty", "setProperty", "setProperty", "setProperty", "createTap"]}, "focal_class": {"identifier": "JDBCFactory", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger( JDBCFactory.class );", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger( JDBCFactory.class )", "var_name": "LOG"}, {"original_string": "public static final String DEFAULT_SEPARATOR = \":\";", "modifier": "public static final", "type": "String", "declarator": "DEFAULT_SEPARATOR = \":\"", "var_name": "DEFAULT_SEPARATOR"}, {"original_string": "public static final String PROTOCOL_JDBC_USER = \"jdbcuser\";", "modifier": "public static final", "type": "String", "declarator": "PROTOCOL_JDBC_USER = \"jdbcuser\"", "var_name": "PROTOCOL_JDBC_USER"}, {"original_string": "public static final String PROTOCOL_JDBC_PASSWORD = \"jdbcpassword\";", "modifier": "public static final", "type": "String", "declarator": "PROTOCOL_JDBC_PASSWORD = \"jdbcpassword\"", "var_name": "PROTOCOL_JDBC_PASSWORD"}, {"original_string": "public static final String PROTOCOL_JDBC_DRIVER = \"jdbcdriver\";", "modifier": "public static final", "type": "String", "declarator": "PROTOCOL_JDBC_DRIVER = \"jdbcdriver\"", "var_name": "PROTOCOL_JDBC_DRIVER"}, {"original_string": "public static final String PROTOCOL_FIELD_SEPARATOR = \"tabledesc.separator\";", "modifier": "public static final", "type": "String", "declarator": "PROTOCOL_FIELD_SEPARATOR = \"tabledesc.separator\"", "var_name": "PROTOCOL_FIELD_SEPARATOR"}, {"original_string": "public static final String PROTOCOL_TABLE_NAME = \"tabledesc.tablename\";", "modifier": "public static final", "type": "String", "declarator": "PROTOCOL_TABLE_NAME = \"tabledesc.tablename\"", "var_name": "PROTOCOL_TABLE_NAME"}, {"original_string": "public static final String PROTOCOL_COLUMN_NAMES = \"tabledesc.columnnames\";", "modifier": "public static final", "type": "String", "declarator": "PROTOCOL_COLUMN_NAMES = \"tabledesc.columnnames\"", "var_name": "PROTOCOL_COLUMN_NAMES"}, {"original_string": "public static final String PROTOCOL_COLUMN_DEFS = \"tabledesc.columndefs\";", "modifier": "public static final", "type": "String", "declarator": "PROTOCOL_COLUMN_DEFS = \"tabledesc.columndefs\"", "var_name": "PROTOCOL_COLUMN_DEFS"}, {"original_string": "public static final String PROTOCOL_PRIMARY_KEYS = \"tabledesc.primarykeys\";", "modifier": "public static final", "type": "String", "declarator": "PROTOCOL_PRIMARY_KEYS = \"tabledesc.primarykeys\"", "var_name": "PROTOCOL_PRIMARY_KEYS"}, {"original_string": "public static final String PROTOCOL_SINK_MODE = \"sinkmode\";", "modifier": "public static final", "type": "String", "declarator": "PROTOCOL_SINK_MODE = \"sinkmode\"", "var_name": "PROTOCOL_SINK_MODE"}, {"original_string": "public static final String FORMAT_SEPARATOR = \"separator\";", "modifier": "public static final", "type": "String", "declarator": "FORMAT_SEPARATOR = \"separator\"", "var_name": "FORMAT_SEPARATOR"}, {"original_string": "public static final String FORMAT_COLUMNS = \"columnnames\";", "modifier": "public static final", "type": "String", "declarator": "FORMAT_COLUMNS = \"columnnames\"", "var_name": "FORMAT_COLUMNS"}, {"original_string": "public static final String FORMAT_ORDER_BY = \"orderBy\";", "modifier": "public static final", "type": "String", "declarator": "FORMAT_ORDER_BY = \"orderBy\"", "var_name": "FORMAT_ORDER_BY"}, {"original_string": "public static final String FORMAT_CONDITIONS = \"conditions\";", "modifier": "public static final", "type": "String", "declarator": "FORMAT_CONDITIONS = \"conditions\"", "var_name": "FORMAT_CONDITIONS"}, {"original_string": "public static final String FORMAT_LIMIT = \"limit\";", "modifier": "public static final", "type": "String", "declarator": "FORMAT_LIMIT = \"limit\"", "var_name": "FORMAT_LIMIT"}, {"original_string": "public static final String FORMAT_UPDATE_BY = \"updateBy\";", "modifier": "public static final", "type": "String", "declarator": "FORMAT_UPDATE_BY = \"updateBy\"", "var_name": "FORMAT_UPDATE_BY"}, {"original_string": "public static final String FORMAT_TABLE_ALIAS = \"tableAlias\";", "modifier": "public static final", "type": "String", "declarator": "FORMAT_TABLE_ALIAS = \"tableAlias\"", "var_name": "FORMAT_TABLE_ALIAS"}, {"original_string": "public static final String FORMAT_SELECT_QUERY = \"selectQuery\";", "modifier": "public static final", "type": "String", "declarator": "FORMAT_SELECT_QUERY = \"selectQuery\"", "var_name": "FORMAT_SELECT_QUERY"}, {"original_string": "public static final String FORMAT_COUNT_QUERY = \"countQuery\";", "modifier": "public static final", "type": "String", "declarator": "FORMAT_COUNT_QUERY = \"countQuery\"", "var_name": "FORMAT_COUNT_QUERY"}], "methods": [{"identifier": "createTap", "parameters": "( String protocol, Scheme scheme, String identifier, SinkMode mode, Properties properties )", "modifiers": "@SuppressWarnings(\"rawtypes\") public", "return": "Tap", "signature": "Tap createTap( String protocol, Scheme scheme, String identifier, SinkMode mode, Properties properties )", "full_signature": "@SuppressWarnings(\"rawtypes\") public Tap createTap( String protocol, Scheme scheme, String identifier, SinkMode mode, Properties properties )", "class_method_signature": "JDBCFactory.createTap( String protocol, Scheme scheme, String identifier, SinkMode mode, Properties properties )", "testcase": false, "constructor": false}, {"identifier": "createScheme", "parameters": "( String format, Fields fields, Properties properties )", "modifiers": "public", "return": "Scheme", "signature": "Scheme createScheme( String format, Fields fields, Properties properties )", "full_signature": "public Scheme createScheme( String format, Fields fields, Properties properties )", "class_method_signature": "JDBCFactory.createScheme( String format, Fields fields, Properties properties )", "testcase": false, "constructor": false}, {"identifier": "createUpdatableScheme", "parameters": "( Fields fields, long limit, String[] columnNames, Boolean tableAlias, String conditions,\n                                          String[] updateBy, Fields updateByFields, String[] orderBy, Properties properties )", "modifiers": "protected", "return": "Scheme", "signature": "Scheme createUpdatableScheme( Fields fields, long limit, String[] columnNames, Boolean tableAlias, String conditions,\n                                          String[] updateBy, Fields updateByFields, String[] orderBy, Properties properties )", "full_signature": "protected Scheme createUpdatableScheme( Fields fields, long limit, String[] columnNames, Boolean tableAlias, String conditions,\n                                          String[] updateBy, Fields updateByFields, String[] orderBy, Properties properties )", "class_method_signature": "JDBCFactory.createUpdatableScheme( Fields fields, long limit, String[] columnNames, Boolean tableAlias, String conditions,\n                                          String[] updateBy, Fields updateByFields, String[] orderBy, Properties properties )", "testcase": false, "constructor": false}, {"identifier": "createUpdatableScheme", "parameters": "( Fields fields, long limit, String[] columnNames, Boolean tableAlias, String conditions,\n      String[] updateBy, Fields updateByFields, String[] orderBy )", "modifiers": "protected", "return": "Scheme", "signature": "Scheme createUpdatableScheme( Fields fields, long limit, String[] columnNames, Boolean tableAlias, String conditions,\n      String[] updateBy, Fields updateByFields, String[] orderBy )", "full_signature": "protected Scheme createUpdatableScheme( Fields fields, long limit, String[] columnNames, Boolean tableAlias, String conditions,\n      String[] updateBy, Fields updateByFields, String[] orderBy )", "class_method_signature": "JDBCFactory.createUpdatableScheme( Fields fields, long limit, String[] columnNames, Boolean tableAlias, String conditions,\n      String[] updateBy, Fields updateByFields, String[] orderBy )", "testcase": false, "constructor": false}, {"identifier": "createScheme", "parameters": "( Fields fields, String selectQuery, String countQuery, long limit, String[] columnNames, boolean tableAlias )", "modifiers": "protected", "return": "Scheme", "signature": "Scheme createScheme( Fields fields, String selectQuery, String countQuery, long limit, String[] columnNames, boolean tableAlias )", "full_signature": "protected Scheme createScheme( Fields fields, String selectQuery, String countQuery, long limit, String[] columnNames, boolean tableAlias )", "class_method_signature": "JDBCFactory.createScheme( Fields fields, String selectQuery, String countQuery, long limit, String[] columnNames, boolean tableAlias )", "testcase": false, "constructor": false}, {"identifier": "createTableDescFromProperties", "parameters": "( Properties properties )", "modifiers": "protected", "return": "TableDesc", "signature": "TableDesc createTableDescFromProperties( Properties properties )", "full_signature": "protected TableDesc createTableDescFromProperties( Properties properties )", "class_method_signature": "JDBCFactory.createTableDescFromProperties( Properties properties )", "testcase": false, "constructor": false}, {"identifier": "getInputFormatClass", "parameters": "()", "modifiers": "protected", "return": "Class<? extends DBInputFormat>", "signature": "Class<? extends DBInputFormat> getInputFormatClass()", "full_signature": "protected Class<? extends DBInputFormat> getInputFormatClass()", "class_method_signature": "JDBCFactory.getInputFormatClass()", "testcase": false, "constructor": false}, {"identifier": "getOutputFormClass", "parameters": "()", "modifiers": "protected", "return": "Class<? extends DBOutputFormat>", "signature": "Class<? extends DBOutputFormat> getOutputFormClass()", "full_signature": "protected Class<? extends DBOutputFormat> getOutputFormClass()", "class_method_signature": "JDBCFactory.getOutputFormClass()", "testcase": false, "constructor": false}, {"identifier": "getColumnNames", "parameters": "( Fields fields, Properties properties, String separator )", "modifiers": "protected", "return": "String[]", "signature": "String[] getColumnNames( Fields fields, Properties properties, String separator )", "full_signature": "protected String[] getColumnNames( Fields fields, Properties properties, String separator )", "class_method_signature": "JDBCFactory.getColumnNames( Fields fields, Properties properties, String separator )", "testcase": false, "constructor": false}, {"identifier": "getTableAlias", "parameters": "( Properties properties )", "modifiers": "protected", "return": "boolean", "signature": "boolean getTableAlias( Properties properties )", "full_signature": "protected boolean getTableAlias( Properties properties )", "class_method_signature": "JDBCFactory.getTableAlias( Properties properties )", "testcase": false, "constructor": false}], "file": "cascading-jdbc-core/src/main/java/cascading/jdbc/JDBCFactory.java"}, "focal_method": {"identifier": "createTap", "parameters": "( String protocol, Scheme scheme, String identifier, SinkMode mode, Properties properties )", "modifiers": "@SuppressWarnings(\"rawtypes\") public", "return": "Tap", "body": "@SuppressWarnings(\"rawtypes\")\n  public Tap createTap( String protocol, Scheme scheme, String identifier, SinkMode mode, Properties properties )\n    {\n    LOG.info( \"creating jdbc protocol with properties {} in mode {}\", properties, mode );\n\n    String driver = properties.getProperty( PROTOCOL_JDBC_DRIVER );\n\n    String jdbcUserProperty = properties.getProperty( PROTOCOL_JDBC_USER );\n    String jdbcPasswordProperty = properties.getProperty( PROTOCOL_JDBC_PASSWORD );\n\n    String jdbcUser = null;\n    if( jdbcUserProperty != null && !jdbcUserProperty.isEmpty() )\n      jdbcUser = jdbcUserProperty;\n\n    String jdbcPassword = null;\n    if( jdbcPasswordProperty != null && !jdbcPasswordProperty.isEmpty() )\n      jdbcPassword = jdbcPasswordProperty;\n\n    final TableDesc tableDesc = createTableDescFromProperties( properties );\n\n    JDBCScheme jdbcScheme = (JDBCScheme) scheme;\n\n    /*\n     * it is possible, that the schema information given via properties is\n     * incomplete and therefore, we derive it from the given fields. We can only\n     * do that, if we actually get meaningful fields. There is a second place,\n     * where this happens, which is the presentSinkFields method of the\n     * JDBCScheme.\n     */\n    Fields sinkFields = jdbcScheme.getSinkFields();\n    if( !tableDesc.hasRequiredTableInformation() && sinkFields != Fields.UNKNOWN && sinkFields != Fields.ALL && sinkFields != null\n        && sinkFields.getTypes() != null )\n      {\n      LOG.debug( \"tabledesc information incomplete, falling back to sink-fields {}\", jdbcScheme.getSinkFields() );\n      tableDesc.completeFromFields( jdbcScheme.getSinkFields() );\n      ( (JDBCScheme) scheme ).setColumns( tableDesc.getColumnNames() );\n      }\n\n    // users can overwrite the sink mode.\n    String sinkModeProperty = properties.getProperty( PROTOCOL_SINK_MODE );\n    SinkMode userMode = mode;\n    if( sinkModeProperty != null && !sinkModeProperty.isEmpty() )\n      userMode = SinkMode.valueOf( sinkModeProperty );\n\n    return new JDBCTap( identifier, jdbcUser, jdbcPassword, driver, tableDesc, jdbcScheme, userMode );\n\n    }", "signature": "Tap createTap( String protocol, Scheme scheme, String identifier, SinkMode mode, Properties properties )", "full_signature": "@SuppressWarnings(\"rawtypes\") public Tap createTap( String protocol, Scheme scheme, String identifier, SinkMode mode, Properties properties )", "class_method_signature": "JDBCFactory.createTap( String protocol, Scheme scheme, String identifier, SinkMode mode, Properties properties )", "testcase": false, "constructor": false, "invocations": ["info", "getProperty", "getProperty", "getProperty", "isEmpty", "isEmpty", "createTableDescFromProperties", "getSinkFields", "hasRequiredTableInformation", "getTypes", "debug", "getSinkFields", "completeFromFields", "getSinkFields", "setColumns", "getColumnNames", "getProperty", "isEmpty", "valueOf"]}, "repository": {"repo_id": 11904180, "url": "https://github.com/Cascading/cascading-jdbc", "language": "Java", "is_fork": false, "fork_count": 16, "stargazer_count": 28, "size": 691, "license": "licensed"}}