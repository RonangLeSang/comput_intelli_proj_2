{"test_class": {"identifier": "EvCacheProviderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock\n    private EVCacheImpl evCacheImplMock;", "modifier": "@Mock\n    private", "type": "EVCacheImpl", "declarator": "evCacheImplMock", "var_name": "evCacheImplMock"}, {"original_string": "@Mock\n    private Future<String> cacheFutureMock;", "modifier": "@Mock\n    private", "type": "Future<String>", "declarator": "cacheFutureMock", "var_name": "cacheFutureMock"}, {"original_string": "@Mock\n    private EVCacheTranscoder<String> transcoderMock;", "modifier": "@Mock\n    private", "type": "EVCacheTranscoder<String>", "declarator": "transcoderMock", "var_name": "transcoderMock"}], "file": "ribbon-evcache/src/test/java/com/netflix/ribbon/evache/EvCacheProviderTest.java"}, "test_case": {"identifier": "testCanceledFuture", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCanceledFuture() throws Exception {\n        expect(evCacheImplMock.getAsynchronous(\"test1\", transcoderMock)).andReturn(cacheFutureMock);\n        expect(cacheFutureMock.isDone()).andReturn(true);\n        expect(cacheFutureMock.isCancelled()).andReturn(true);\n\n        replayAll();\n\n        EvCacheOptions options = new EvCacheOptions(\"testApp\", \"test-cache\", true, 100, transcoderMock, \"test{id}\");\n        EvCacheProvider<Object> cacheProvider = new EvCacheProvider<Object>(options);\n        Observable<Object> cacheValue = cacheProvider.get(\"test1\", null);\n\n        assertTrue(cacheValue.materialize().toBlocking().first().getThrowable() instanceof CacheFaultException);\n    }", "signature": "void testCanceledFuture()", "full_signature": "@Test public void testCanceledFuture()", "class_method_signature": "EvCacheProviderTest.testCanceledFuture()", "testcase": true, "constructor": false, "invocations": ["andReturn", "expect", "getAsynchronous", "andReturn", "expect", "isDone", "andReturn", "expect", "isCancelled", "replayAll", "get", "assertTrue", "getThrowable", "first", "toBlocking", "materialize"]}, "focal_class": {"identifier": "EvCacheProvider", "superclass": "", "interfaces": "implements CacheProvider<T>", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(EvCacheProvider.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(EvCacheProvider.class)", "var_name": "LOGGER"}, {"original_string": "private static final long WATCH_INTERVAL = 1;", "modifier": "private static final", "type": "long", "declarator": "WATCH_INTERVAL = 1", "var_name": "WATCH_INTERVAL"}, {"original_string": "private static final FutureObserver FUTURE_OBSERVER;", "modifier": "private static final", "type": "FutureObserver", "declarator": "FUTURE_OBSERVER", "var_name": "FUTURE_OBSERVER"}, {"original_string": "private final EvCacheOptions options;", "modifier": "private final", "type": "EvCacheOptions", "declarator": "options", "var_name": "options"}, {"original_string": "private final EVCache evCache;", "modifier": "private final", "type": "EVCache", "declarator": "evCache", "var_name": "evCache"}], "methods": [{"identifier": "EvCacheProvider", "parameters": "(EvCacheOptions options)", "modifiers": "public", "return": "", "signature": " EvCacheProvider(EvCacheOptions options)", "full_signature": "public  EvCacheProvider(EvCacheOptions options)", "class_method_signature": "EvCacheProvider.EvCacheProvider(EvCacheOptions options)", "testcase": false, "constructor": true}, {"identifier": "get", "parameters": "(final String key, Map<String, Object> requestProperties)", "modifiers": "@SuppressWarnings(\"unchecked\") @Override public", "return": "Observable<T>", "signature": "Observable<T> get(final String key, Map<String, Object> requestProperties)", "full_signature": "@SuppressWarnings(\"unchecked\") @Override public Observable<T> get(final String key, Map<String, Object> requestProperties)", "class_method_signature": "EvCacheProvider.get(final String key, Map<String, Object> requestProperties)", "testcase": false, "constructor": false}], "file": "ribbon-evcache/src/main/java/com/netflix/ribbon/evache/EvCacheProvider.java"}, "focal_method": {"identifier": "get", "parameters": "(final String key, Map<String, Object> requestProperties)", "modifiers": "@SuppressWarnings(\"unchecked\") @Override public", "return": "Observable<T>", "body": "@SuppressWarnings(\"unchecked\")\n    @Override\n    public Observable<T> get(final String key, Map<String, Object> requestProperties) {\n        return Observable.create(new OnSubscribe<T>() {\n            @Override\n            public void call(Subscriber<? super T> subscriber) {\n                Future<T> getFuture;\n                try {\n                    if (options.getTranscoder() == null) {\n                        getFuture = evCache.getAsynchronous(key);\n                    } else {\n                        getFuture = (Future<T>) evCache.getAsynchronous(key, options.getTranscoder());\n                    }\n                    FUTURE_OBSERVER.watchFuture(getFuture, subscriber);\n                } catch (EVCacheException e) {\n                    subscriber.onError(new CacheFaultException(\"EVCache exception when getting value for key \" + key, e));\n                }\n            }\n        });\n    }", "signature": "Observable<T> get(final String key, Map<String, Object> requestProperties)", "full_signature": "@SuppressWarnings(\"unchecked\") @Override public Observable<T> get(final String key, Map<String, Object> requestProperties)", "class_method_signature": "EvCacheProvider.get(final String key, Map<String, Object> requestProperties)", "testcase": false, "constructor": false, "invocations": ["create", "getTranscoder", "getAsynchronous", "getAsynchronous", "getTranscoder", "watchFuture", "onError"]}, "repository": {"repo_id": 7616158, "url": "https://github.com/Netflix/ribbon", "language": "Java", "is_fork": false, "fork_count": 939, "stargazer_count": 3631, "size": 3280, "license": "licensed"}}