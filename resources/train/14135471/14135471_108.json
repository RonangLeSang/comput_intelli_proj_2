{"test_class": {"identifier": "WriteOptimisticVerifyTest", "superclass": "extends AbstractMvccEntityStageTest", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(WriteOptimisticVerifyTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(WriteOptimisticVerifyTest.class)", "var_name": "logger"}], "file": "stack/corepersistence/collection/src/test/java/org/apache/usergrid/persistence/collection/mvcc/stage/write/WriteOptimisticVerifyTest.java"}, "test_case": {"identifier": "testConflict", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testConflict() throws Exception {\n\n        final ApplicationScope scope = mock( ApplicationScope.class );\n        when( scope.getApplication() )\n            .thenReturn( new SimpleId( UUIDGenerator.newTimeUUID(), \"organization\" ) );\n\n        final Session session = mock(Session.class);\n\n        // there is an entity\n        final Entity entity = generateEntity();\n        entity.setField(new StringField(\"name\", \"FOO\", true));\n        entity.setField(new StringField(\"identifier\", \"BAR\", true));\n\n        // log that one operation is active on entity\n        List<MvccLogEntry> logEntries = new ArrayList<MvccLogEntry>();\n        logEntries.add( new MvccLogEntryImpl(\n            entity.getId(), UUIDGenerator.newTimeUUID(), Stage.ACTIVE, MvccLogEntry.State.COMPLETE ));\n\n        // log another operation as active on entity\n        logEntries.add( new MvccLogEntryImpl(\n            entity.getId(), UUIDGenerator.newTimeUUID(), Stage.ACTIVE, MvccLogEntry.State.COMPLETE ));\n\n        // mock up the log\n        MvccLogEntrySerializationStrategy mvccLog =\n            mock( MvccLogEntrySerializationStrategy.class );\n        when( mvccLog.load( scope, entity.getId(), entity.getVersion(), 2) )\n            .thenReturn( logEntries );\n\n        // mock up unique values interface\n        UniqueValueSerializationStrategy uvstrat = mock( UniqueValueSerializationStrategy.class);\n        UniqueValue uv1 = new UniqueValueImpl(entity.getField(\"name\"), entity.getId(), entity.getVersion());\n        UniqueValue uv2 = new UniqueValueImpl(  entity.getField(\"identifier\"), entity.getId(), entity.getVersion());\n\n        // Run the stage, conflict should be detected\n        final MvccEntity mvccEntity = fromEntity( entity );\n        boolean conflictDetected = false;\n\n        WriteOptimisticVerify newStage = new WriteOptimisticVerify( mvccLog );\n        RollbackAction rollbackAction = new RollbackAction( mvccLog, uvstrat, session );\n\n        try {\n            newStage.call( new CollectionIoEvent<>(scope, mvccEntity));\n\n        } catch (WriteOptimisticVerifyException e) {\n            logger.info(\"Error\", e);\n            conflictDetected = true;\n            rollbackAction.call( e );\n        }\n        assertTrue( conflictDetected );\n\n        // check that unique values were deleted\n        verify( uvstrat, times(1) ).deleteCQL(scope,  uv1 );\n        verify( uvstrat, times(1) ).deleteCQL(scope,  uv2 );\n    }", "signature": "void testConflict()", "full_signature": "@Test public void testConflict()", "class_method_signature": "WriteOptimisticVerifyTest.testConflict()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "getApplication", "newTimeUUID", "mock", "generateEntity", "setField", "setField", "add", "getId", "newTimeUUID", "add", "getId", "newTimeUUID", "mock", "thenReturn", "when", "load", "getId", "getVersion", "mock", "getField", "getId", "getVersion", "getField", "getId", "getVersion", "fromEntity", "call", "info", "call", "assertTrue", "deleteCQL", "verify", "times", "deleteCQL", "verify", "times"]}, "focal_class": {"identifier": "WriteOptimisticVerify", "superclass": "", "interfaces": "implements Action1<CollectionIoEvent<MvccEntity>>", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger( WriteOptimisticVerify.class );", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger( WriteOptimisticVerify.class )", "var_name": "logger"}, {"original_string": "private final MvccLogEntrySerializationStrategy logEntryStrat;", "modifier": "private final", "type": "MvccLogEntrySerializationStrategy", "declarator": "logEntryStrat", "var_name": "logEntryStrat"}], "methods": [{"identifier": "WriteOptimisticVerify", "parameters": "( MvccLogEntrySerializationStrategy logEntryStrat )", "modifiers": "@Inject public", "return": "", "signature": " WriteOptimisticVerify( MvccLogEntrySerializationStrategy logEntryStrat )", "full_signature": "@Inject public  WriteOptimisticVerify( MvccLogEntrySerializationStrategy logEntryStrat )", "class_method_signature": "WriteOptimisticVerify.WriteOptimisticVerify( MvccLogEntrySerializationStrategy logEntryStrat )", "testcase": false, "constructor": true}, {"identifier": "call", "parameters": "( final CollectionIoEvent<MvccEntity> ioevent )", "modifiers": "@Override public", "return": "void", "signature": "void call( final CollectionIoEvent<MvccEntity> ioevent )", "full_signature": "@Override public void call( final CollectionIoEvent<MvccEntity> ioevent )", "class_method_signature": "WriteOptimisticVerify.call( final CollectionIoEvent<MvccEntity> ioevent )", "testcase": false, "constructor": false}], "file": "stack/corepersistence/collection/src/main/java/org/apache/usergrid/persistence/collection/mvcc/stage/write/WriteOptimisticVerify.java"}, "focal_method": {"identifier": "call", "parameters": "( final CollectionIoEvent<MvccEntity> ioevent )", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void call( final CollectionIoEvent<MvccEntity> ioevent ) {\n        MvccValidationUtils.verifyMvccEntityWithEntity( ioevent.getEvent() );\n\n        // If the version was included on the entity write operation (delete or write) we need\n        // to read back the entity log, and ensure that our \"new\" version is the only version\n        // entry since the last commit.\n        //\n        // If not, fail fast, signal to the user their entity is \"stale\".\n\n        MvccEntity mvccEntity = ioevent.getEvent();\n        final Entity entity = mvccEntity.getEntity().get();\n\n        ApplicationScope applicationScope = ioevent.getEntityCollection();\n\n        if ( entity.getVersion() == null ) {\n            return;\n        }\n\n\n        List<MvccLogEntry> versions = logEntryStrat.load( applicationScope, entity.getId(), entity.getVersion(), 2 );\n\n        // Previous log entry must be committed, otherwise somebody is already writing\n        if ( versions.size() > 1 && versions.get( 1 ).getStage().ordinal() < Stage.COMMITTED.ordinal() ) {\n\n            logger.debug( \"Conflict writing entity id {} version {}\", entity.getId().toString(),\n                    entity.getVersion().toString() );\n\n            throw new WriteOptimisticVerifyException( mvccEntity, applicationScope,\n                    \"Change conflict, not first writer\" );\n        }\n    }", "signature": "void call( final CollectionIoEvent<MvccEntity> ioevent )", "full_signature": "@Override public void call( final CollectionIoEvent<MvccEntity> ioevent )", "class_method_signature": "WriteOptimisticVerify.call( final CollectionIoEvent<MvccEntity> ioevent )", "testcase": false, "constructor": false, "invocations": ["verifyMvccEntityWithEntity", "getEvent", "getEvent", "get", "getEntity", "getEntityCollection", "getVersion", "load", "getId", "getVersion", "size", "ordinal", "getStage", "get", "ordinal", "debug", "toString", "getId", "toString", "getVersion"]}, "repository": {"repo_id": 14135471, "url": "https://github.com/apache/usergrid", "language": "Java", "is_fork": false, "fork_count": 432, "stargazer_count": 983, "size": 383432, "license": "licensed"}}