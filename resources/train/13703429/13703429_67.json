{"test_class": {"identifier": "PublishEncoderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "PublishEncoder m_encoder;", "modifier": "", "type": "PublishEncoder", "declarator": "m_encoder", "var_name": "m_encoder"}, {"original_string": "TestUtils.MockProtocolEncoderOutput m_mockProtoEncoder;", "modifier": "", "type": "TestUtils.MockProtocolEncoderOutput", "declarator": "m_mockProtoEncoder", "var_name": "m_mockProtoEncoder"}], "file": "parser/src/test/java/org/dna/mqtt/moquette/proto/PublishEncoderTest.java"}, "test_case": {"identifier": "testEncodeWithQos_0_noMessageID", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testEncodeWithQos_0_noMessageID() throws Exception {\n        String topic = \"/photos\";\n        PublishMessage msg = new PublishMessage();\n        msg.setQos(QOSType.MOST_ONE);\n        msg.setTopicName(topic);\n\n        //variable part\n        byte[] payload = new byte[]{0x0A, 0x0B, 0x0C};\n        msg.setPayload(payload);\n\n        //Exercise\n        m_encoder.encode(null, msg, m_mockProtoEncoder);\n\n        //Verify\n        assertEquals(0x30, m_mockProtoEncoder.getBuffer().get()); //1 byte\n        //(2+7) topic + 3 payload\n        assertEquals(12, m_mockProtoEncoder.getBuffer().get()); //remaining length\n\n        //Variable part\n        verifyString(topic, m_mockProtoEncoder.getBuffer());\n        verifyBuff(payload.length, payload, m_mockProtoEncoder.getBuffer());\n    }", "signature": "void testEncodeWithQos_0_noMessageID()", "full_signature": "@Test public void testEncodeWithQos_0_noMessageID()", "class_method_signature": "PublishEncoderTest.testEncodeWithQos_0_noMessageID()", "testcase": true, "constructor": false, "invocations": ["setQos", "setTopicName", "setPayload", "encode", "assertEquals", "get", "getBuffer", "assertEquals", "get", "getBuffer", "verifyString", "getBuffer", "verifyBuff", "getBuffer"]}, "focal_class": {"identifier": "PublishEncoder", "superclass": "", "interfaces": "implements MessageEncoder<PublishMessage>", "fields": [], "methods": [{"identifier": "encode", "parameters": "(IoSession session, PublishMessage message, ProtocolEncoderOutput out)", "modifiers": "public", "return": "void", "signature": "void encode(IoSession session, PublishMessage message, ProtocolEncoderOutput out)", "full_signature": "public void encode(IoSession session, PublishMessage message, ProtocolEncoderOutput out)", "class_method_signature": "PublishEncoder.encode(IoSession session, PublishMessage message, ProtocolEncoderOutput out)", "testcase": false, "constructor": false}], "file": "parser/src/main/java/org/dna/mqtt/moquette/proto/PublishEncoder.java"}, "focal_method": {"identifier": "encode", "parameters": "(IoSession session, PublishMessage message, ProtocolEncoderOutput out)", "modifiers": "public", "return": "void", "body": "public void encode(IoSession session, PublishMessage message, ProtocolEncoderOutput out) throws Exception {\n        if (message.getQos() == QOSType.RESERVED) {\n            throw new IllegalArgumentException(\"Found a message with RESERVED Qos\");\n        }\n        if (message.getTopicName() == null || message.getTopicName().isEmpty()) {\n            throw new IllegalArgumentException(\"Found a message with empty or null topic name\");\n        }\n        \n        IoBuffer variableHeaderBuff = IoBuffer.allocate(2).setAutoExpand(true);\n        variableHeaderBuff.put(Utils.encodeString(message.getTopicName()));\n        if (message.getQos() == QOSType.LEAST_ONE || \n            message.getQos() == QOSType.EXACTLY_ONCE ) {\n            if (message.getMessageID() == null) {\n                throw new IllegalArgumentException(\"Found a message with QOS 1 or 2 and not MessageID setted\");\n            }\n            Utils.writeWord(variableHeaderBuff, message.getMessageID());\n        }\n        variableHeaderBuff.put(message.getPayload());\n        variableHeaderBuff.flip();\n        int variableHeaderSize = variableHeaderBuff.remaining();\n        \n        byte flags = Utils.encodeFlags(message);\n        \n        IoBuffer buff = IoBuffer.allocate(2 + variableHeaderSize).setAutoExpand(true);;\n        buff.put((byte) (AbstractMessage.PUBLISH << 4 | flags));\n        buff.put(Utils.encodeRemainingLength(variableHeaderSize));\n        buff.put(variableHeaderBuff).flip();\n\n        out.write(buff);\n    }", "signature": "void encode(IoSession session, PublishMessage message, ProtocolEncoderOutput out)", "full_signature": "public void encode(IoSession session, PublishMessage message, ProtocolEncoderOutput out)", "class_method_signature": "PublishEncoder.encode(IoSession session, PublishMessage message, ProtocolEncoderOutput out)", "testcase": false, "constructor": false, "invocations": ["getQos", "getTopicName", "isEmpty", "getTopicName", "setAutoExpand", "allocate", "put", "encodeString", "getTopicName", "getQos", "getQos", "getMessageID", "writeWord", "getMessageID", "put", "getPayload", "flip", "remaining", "encodeFlags", "setAutoExpand", "allocate", "put", "put", "encodeRemainingLength", "flip", "put", "write"]}, "repository": {"repo_id": 13703429, "url": "https://github.com/milliondreams/moquette-mqtt", "language": "Java", "is_fork": false, "fork_count": 13, "stargazer_count": 19, "size": 1536, "license": "Apache License 2.0"}}