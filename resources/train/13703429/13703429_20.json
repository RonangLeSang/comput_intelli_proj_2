{"test_class": {"identifier": "ConnectDecoderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "ByteBuf m_buff;", "modifier": "", "type": "ByteBuf", "declarator": "m_buff", "var_name": "m_buff"}, {"original_string": "ConnectDecoder m_msgdec;", "modifier": "", "type": "ConnectDecoder", "declarator": "m_msgdec", "var_name": "m_msgdec"}], "file": "netty_parser/src/test/java/org/dna/mqtt/moquette/parser/netty/ConnectDecoderTest.java"}, "test_case": {"identifier": "testBaseHeader_extra_with_user_pwd", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBaseHeader_extra_with_user_pwd() throws UnsupportedEncodingException, Exception {\n        m_buff = Unpooled.buffer(55);\n        initHeader(m_buff, (byte) 53);\n        encodeString(m_buff, \"ABCDEFGH\");\n        encodeString(m_buff, \"Topic\");\n        encodeString(m_buff, \"Message\");\n        encodeString(m_buff, \"Fakeuser\");\n        encodeString(m_buff, \"pwd\");\n        List<Object> results = new ArrayList<Object >();\n        \n        //Excercise\n        m_msgdec.decode(null, m_buff, results);\n        \n        //Verify\n        assertFalse(results.isEmpty());\n        ConnectMessage message = (ConnectMessage)results.get(0); \n        verifyBaseHeader(message);\n        assertEquals(AbstractMessage.CONNECT, message.getMessageType());\n        assertEquals(\"ABCDEFGH\", message.getClientID());\n        assertEquals(\"Topic\", message.getWillTopic());\n        assertEquals(\"Message\", message.getWillMessage());\n        assertEquals(\"Fakeuser\", message.getUsername());\n        assertEquals(\"pwd\", message.getPassword());\n    }", "signature": "void testBaseHeader_extra_with_user_pwd()", "full_signature": "@Test public void testBaseHeader_extra_with_user_pwd()", "class_method_signature": "ConnectDecoderTest.testBaseHeader_extra_with_user_pwd()", "testcase": true, "constructor": false, "invocations": ["buffer", "initHeader", "encodeString", "encodeString", "encodeString", "encodeString", "encodeString", "decode", "assertFalse", "isEmpty", "get", "verifyBaseHeader", "assertEquals", "getMessageType", "assertEquals", "getClientID", "assertEquals", "getWillTopic", "assertEquals", "getWillMessage", "assertEquals", "getUsername", "assertEquals", "getPassword"]}, "focal_class": {"identifier": "ConnectDecoder", "superclass": "extends DemuxDecoder", "interfaces": "", "fields": [], "methods": [{"identifier": "decode", "parameters": "(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)", "modifiers": "@Override", "return": "void", "signature": "void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)", "full_signature": "@Override void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)", "class_method_signature": "ConnectDecoder.decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)", "testcase": false, "constructor": false}], "file": "netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/ConnectDecoder.java"}, "focal_method": {"identifier": "decode", "parameters": "(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)", "modifiers": "@Override", "return": "void", "body": "@Override\n    void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws UnsupportedEncodingException {\n        in.resetReaderIndex();\n        //Common decoding part\n        ConnectMessage message = new ConnectMessage();\n        if (!decodeCommonHeader(message, in)) {\n            in.resetReaderIndex();\n            return;\n        }\n        int remainingLength = message.getRemainingLength();\n        int start = in.readerIndex();\n\n        //Connect specific decoding part\n        //ProtocolName 8 bytes\n        if (in.readableBytes() < 12) {\n            in.resetReaderIndex();\n            return;\n        }\n        byte[] encProtoName = new byte[6];\n        in.skipBytes(2); //size, is 0x06\n        in.readBytes(encProtoName);\n        String protoName = new String(encProtoName, \"UTF-8\");\n        if (!\"MQIsdp\".equals(protoName)) {\n            in.resetReaderIndex();\n            throw new CorruptedFrameException(\"Invalid protoName: \" + protoName);\n        }\n        message.setProtocolName(protoName);\n\n        //ProtocolVersion 1 byte (value 0x03)\n        message.setProcotolVersion(in.readByte());\n\n        //Connection flag\n        byte connFlags = in.readByte();\n        boolean cleanSession = ((connFlags & 0x02) >> 1) == 1 ? true : false;\n        boolean willFlag = ((connFlags & 0x04) >> 2) == 1 ? true : false;\n        byte willQos = (byte) ((connFlags & 0x18) >> 3);\n        if (willQos > 2) {\n            in.resetReaderIndex();\n            throw new CorruptedFrameException(\"Expected will QoS in range 0..2 but found: \" + willQos);\n        }\n        boolean willRetain = ((connFlags & 0x20) >> 5) == 1 ? true : false;\n        boolean passwordFlag = ((connFlags & 0x40) >> 6) == 1 ? true : false;\n        boolean userFlag = ((connFlags & 0x80) >> 7) == 1 ? true : false;\n        //a password is true iff user is true.\n        if (!userFlag && passwordFlag) {\n            in.resetReaderIndex();\n            throw new CorruptedFrameException(\"Expected password flag to true if the user flag is true but was: \" + passwordFlag);\n        }\n        message.setCleanSession(cleanSession);\n        message.setWillFlag(willFlag);\n        message.setWillQos(willQos);\n        message.setWillRetain(willRetain);\n        message.setPasswordFlag(passwordFlag);\n        message.setUserFlag(userFlag);\n\n        //Keep Alive timer 2 bytes\n        //int keepAlive = Utils.readWord(in);\n        int keepAlive = in.readUnsignedShort();\n        message.setKeepAlive(keepAlive);\n\n        if (remainingLength == 12) {\n            out.add(message);\n            return;\n        }\n\n        //Decode the ClientID\n        String clientID = Utils.decodeString(in);\n        if (clientID == null) {\n            in.resetReaderIndex();\n            return;\n        }\n        message.setClientID(clientID);\n\n        //Decode willTopic\n        if (willFlag) {\n            String willTopic = Utils.decodeString(in);\n            if (willTopic == null) {\n                in.resetReaderIndex();\n                return;\n            }\n            message.setWillTopic(willTopic);\n        }\n\n        //Decode willMessage\n        if (willFlag) {\n            String willMessage = Utils.decodeString(in);\n            if (willMessage == null) {\n                in.resetReaderIndex();\n                return;\n            }\n            message.setWillMessage(willMessage);\n        }\n\n        //Compatibility check wieth v3.0, remaining length has precedence over\n        //the user and password flags\n        int readed = in.readerIndex() - start;\n        if (readed == remainingLength) {\n            out.add(message);\n            return;\n        }\n\n        //Decode username\n        if (userFlag) {\n            String userName = Utils.decodeString(in);\n            if (userName == null) {\n                in.resetReaderIndex();\n                return;\n            }\n            message.setUsername(userName);\n        }\n\n        readed = in.readerIndex() - start;\n        if (readed == remainingLength) {\n            out.add(message);\n            return;\n        }\n\n        //Decode password\n        if (passwordFlag) {\n            String password = Utils.decodeString(in);\n            if (password == null) {\n                in.resetReaderIndex();\n                return;\n            }\n            message.setPassword(password);\n        }\n\n        out.add(message);\n    }", "signature": "void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)", "full_signature": "@Override void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)", "class_method_signature": "ConnectDecoder.decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)", "testcase": false, "constructor": false, "invocations": ["resetReaderIndex", "decodeCommonHeader", "resetReaderIndex", "getRemainingLength", "readerIndex", "readableBytes", "resetReaderIndex", "skipBytes", "readBytes", "equals", "resetReaderIndex", "setProtocolName", "setProcotolVersion", "readByte", "readByte", "resetReaderIndex", "resetReaderIndex", "setCleanSession", "setWillFlag", "setWillQos", "setWillRetain", "setPasswordFlag", "setUserFlag", "readUnsignedShort", "setKeepAlive", "add", "decodeString", "resetReaderIndex", "setClientID", "decodeString", "resetReaderIndex", "setWillTopic", "decodeString", "resetReaderIndex", "setWillMessage", "readerIndex", "add", "decodeString", "resetReaderIndex", "setUsername", "readerIndex", "add", "decodeString", "resetReaderIndex", "setPassword", "add"]}, "repository": {"repo_id": 13703429, "url": "https://github.com/milliondreams/moquette-mqtt", "language": "Java", "is_fork": false, "fork_count": 13, "stargazer_count": 19, "size": 1536, "license": "Apache License 2.0"}}