{"test_class": {"identifier": "GroupBalancerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Function<KeyExtent,String> partitioner = new Function<>() {\n\n    @Override\n    public String apply(KeyExtent input) {\n      return (input == null || input.endRow() == null) ? null\n          : input.endRow().toString().substring(0, 2);\n    }\n  };", "modifier": "private static", "type": "Function<KeyExtent,String>", "declarator": "partitioner = new Function<>() {\n\n    @Override\n    public String apply(KeyExtent input) {\n      return (input == null || input.endRow() == null) ? null\n          : input.endRow().toString().substring(0, 2);\n    }\n  }", "var_name": "partitioner"}], "file": "server/base/src/test/java/org/apache/accumulo/server/master/balancer/GroupBalancerTest.java"}, "test_case": {"identifier": "testMaxMigrations", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testMaxMigrations() {\n\n    for (int max : new int[] {1, 2, 3, 7, 10, 30}) {\n      TabletServers tservers = new TabletServers();\n\n      for (int i = 1; i <= 9; i++) {\n        tservers.addTablet(\"01\" + i, \"192.168.1.1:9997\");\n      }\n\n      for (int i = 1; i <= 4; i++) {\n        tservers.addTablet(\"02\" + i, \"192.168.1.2:9997\");\n      }\n\n      for (int i = 1; i <= 5; i++) {\n        tservers.addTablet(\"03\" + i, \"192.168.1.3:9997\");\n      }\n\n      tservers.addTservers(\"192.168.1.4:9997\", \"192.168.1.5:9997\");\n\n      tservers.balance(max);\n    }\n  }", "signature": "void testMaxMigrations()", "full_signature": "@Test public void testMaxMigrations()", "class_method_signature": "GroupBalancerTest.testMaxMigrations()", "testcase": true, "constructor": false, "invocations": ["addTablet", "addTablet", "addTablet", "addTservers", "balance"]}, "focal_class": {"identifier": "GroupBalancer", "superclass": "extends TabletBalancer", "interfaces": "", "fields": [{"original_string": "private final TableId tableId;", "modifier": "private final", "type": "TableId", "declarator": "tableId", "var_name": "tableId"}, {"original_string": "private long lastRun = 0;", "modifier": "private", "type": "long", "declarator": "lastRun = 0", "var_name": "lastRun"}], "methods": [{"identifier": "getPartitioner", "parameters": "()", "modifiers": "protected abstract", "return": "Function<KeyExtent,String>", "signature": "Function<KeyExtent,String> getPartitioner()", "full_signature": "protected abstract Function<KeyExtent,String> getPartitioner()", "class_method_signature": "GroupBalancer.getPartitioner()", "testcase": false, "constructor": false}, {"identifier": "GroupBalancer", "parameters": "(TableId tableId)", "modifiers": "public", "return": "", "signature": " GroupBalancer(TableId tableId)", "full_signature": "public  GroupBalancer(TableId tableId)", "class_method_signature": "GroupBalancer.GroupBalancer(TableId tableId)", "testcase": false, "constructor": true}, {"identifier": "getLocationProvider", "parameters": "()", "modifiers": "protected", "return": "Iterable<Pair<KeyExtent,Location>>", "signature": "Iterable<Pair<KeyExtent,Location>> getLocationProvider()", "full_signature": "protected Iterable<Pair<KeyExtent,Location>> getLocationProvider()", "class_method_signature": "GroupBalancer.getLocationProvider()", "testcase": false, "constructor": false}, {"identifier": "getWaitTime", "parameters": "()", "modifiers": "protected", "return": "long", "signature": "long getWaitTime()", "full_signature": "protected long getWaitTime()", "class_method_signature": "GroupBalancer.getWaitTime()", "testcase": false, "constructor": false}, {"identifier": "getMaxMigrations", "parameters": "()", "modifiers": "protected", "return": "int", "signature": "int getMaxMigrations()", "full_signature": "protected int getMaxMigrations()", "class_method_signature": "GroupBalancer.getMaxMigrations()", "testcase": false, "constructor": false}, {"identifier": "shouldBalance", "parameters": "(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations)", "modifiers": "protected", "return": "boolean", "signature": "boolean shouldBalance(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations)", "full_signature": "protected boolean shouldBalance(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations)", "class_method_signature": "GroupBalancer.shouldBalance(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations)", "testcase": false, "constructor": false}, {"identifier": "getAssignments", "parameters": "(SortedMap<TServerInstance,TabletServerStatus> current,\n      Map<KeyExtent,TServerInstance> unassigned, Map<KeyExtent,TServerInstance> assignments)", "modifiers": "@Override public", "return": "void", "signature": "void getAssignments(SortedMap<TServerInstance,TabletServerStatus> current,\n      Map<KeyExtent,TServerInstance> unassigned, Map<KeyExtent,TServerInstance> assignments)", "full_signature": "@Override public void getAssignments(SortedMap<TServerInstance,TabletServerStatus> current,\n      Map<KeyExtent,TServerInstance> unassigned, Map<KeyExtent,TServerInstance> assignments)", "class_method_signature": "GroupBalancer.getAssignments(SortedMap<TServerInstance,TabletServerStatus> current,\n      Map<KeyExtent,TServerInstance> unassigned, Map<KeyExtent,TServerInstance> assignments)", "testcase": false, "constructor": false}, {"identifier": "balance", "parameters": "(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations, List<TabletMigration> migrationsOut)", "modifiers": "@Override public", "return": "long", "signature": "long balance(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations, List<TabletMigration> migrationsOut)", "full_signature": "@Override public long balance(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations, List<TabletMigration> migrationsOut)", "class_method_signature": "GroupBalancer.balance(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations, List<TabletMigration> migrationsOut)", "testcase": false, "constructor": false}, {"identifier": "balanceExtraExtra", "parameters": "(Map<TServerInstance,TserverGroupInfo> tservers, int maxExtraGroups,\n      Moves moves)", "modifiers": "private", "return": "void", "signature": "void balanceExtraExtra(Map<TServerInstance,TserverGroupInfo> tservers, int maxExtraGroups,\n      Moves moves)", "full_signature": "private void balanceExtraExtra(Map<TServerInstance,TserverGroupInfo> tservers, int maxExtraGroups,\n      Moves moves)", "class_method_signature": "GroupBalancer.balanceExtraExtra(Map<TServerInstance,TserverGroupInfo> tservers, int maxExtraGroups,\n      Moves moves)", "testcase": false, "constructor": false}, {"identifier": "balanceExtraMultiple", "parameters": "(Map<TServerInstance,TserverGroupInfo> tservers,\n      int maxExtraGroups, Moves moves)", "modifiers": "private", "return": "boolean", "signature": "boolean balanceExtraMultiple(Map<TServerInstance,TserverGroupInfo> tservers,\n      int maxExtraGroups, Moves moves)", "full_signature": "private boolean balanceExtraMultiple(Map<TServerInstance,TserverGroupInfo> tservers,\n      int maxExtraGroups, Moves moves)", "class_method_signature": "GroupBalancer.balanceExtraMultiple(Map<TServerInstance,TserverGroupInfo> tservers,\n      int maxExtraGroups, Moves moves)", "testcase": false, "constructor": false}, {"identifier": "balanceExtraMultiple", "parameters": "(Map<TServerInstance,TserverGroupInfo> tservers,\n      int maxExtraGroups, Moves moves, Multimap<String,TserverGroupInfo> extraMultiple,\n      boolean alwaysAdd)", "modifiers": "private", "return": "void", "signature": "void balanceExtraMultiple(Map<TServerInstance,TserverGroupInfo> tservers,\n      int maxExtraGroups, Moves moves, Multimap<String,TserverGroupInfo> extraMultiple,\n      boolean alwaysAdd)", "full_signature": "private void balanceExtraMultiple(Map<TServerInstance,TserverGroupInfo> tservers,\n      int maxExtraGroups, Moves moves, Multimap<String,TserverGroupInfo> extraMultiple,\n      boolean alwaysAdd)", "class_method_signature": "GroupBalancer.balanceExtraMultiple(Map<TServerInstance,TserverGroupInfo> tservers,\n      int maxExtraGroups, Moves moves, Multimap<String,TserverGroupInfo> extraMultiple,\n      boolean alwaysAdd)", "testcase": false, "constructor": false}, {"identifier": "balanceExtraExpected", "parameters": "(Map<TServerInstance,TserverGroupInfo> tservers,\n      int expectedExtra, Moves moves)", "modifiers": "private", "return": "void", "signature": "void balanceExtraExpected(Map<TServerInstance,TserverGroupInfo> tservers,\n      int expectedExtra, Moves moves)", "full_signature": "private void balanceExtraExpected(Map<TServerInstance,TserverGroupInfo> tservers,\n      int expectedExtra, Moves moves)", "class_method_signature": "GroupBalancer.balanceExtraExpected(Map<TServerInstance,TserverGroupInfo> tservers,\n      int expectedExtra, Moves moves)", "testcase": false, "constructor": false}, {"identifier": "balanceExpected", "parameters": "(Map<TServerInstance,TserverGroupInfo> tservers, Moves moves)", "modifiers": "private", "return": "void", "signature": "void balanceExpected(Map<TServerInstance,TserverGroupInfo> tservers, Moves moves)", "full_signature": "private void balanceExpected(Map<TServerInstance,TserverGroupInfo> tservers, Moves moves)", "class_method_signature": "GroupBalancer.balanceExpected(Map<TServerInstance,TserverGroupInfo> tservers, Moves moves)", "testcase": false, "constructor": false}, {"identifier": "populateMigrations", "parameters": "(Set<TServerInstance> current, List<TabletMigration> migrationsOut,\n      Moves moves)", "modifiers": "private", "return": "void", "signature": "void populateMigrations(Set<TServerInstance> current, List<TabletMigration> migrationsOut,\n      Moves moves)", "full_signature": "private void populateMigrations(Set<TServerInstance> current, List<TabletMigration> migrationsOut,\n      Moves moves)", "class_method_signature": "GroupBalancer.populateMigrations(Set<TServerInstance> current, List<TabletMigration> migrationsOut,\n      Moves moves)", "testcase": false, "constructor": false}], "file": "server/base/src/main/java/org/apache/accumulo/server/master/balancer/GroupBalancer.java"}, "focal_method": {"identifier": "balance", "parameters": "(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations, List<TabletMigration> migrationsOut)", "modifiers": "@Override public", "return": "long", "body": "@Override\n  public long balance(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations, List<TabletMigration> migrationsOut) {\n\n    // The terminology extra and expected are used in this code. Expected tablets is the number of\n    // tablets a tserver must have for a given group and is\n    // numInGroup/numTservers. Extra tablets are any tablets more than the number expected for a\n    // given group. If numInGroup % numTservers > 0, then a tserver\n    // may have one extra tablet for a group.\n    //\n    // Assume we have 4 tservers and group A has 11 tablets.\n    // * expected tablets : group A is expected to have 2 tablets on each tservers\n    // * extra tablets : group A may have an additional tablet on each tserver. Group A has a total\n    // of 3 extra tablets.\n    //\n    // This balancer also evens out the extra tablets across all groups. The terminology\n    // extraExpected and extraExtra is used to describe these tablets.\n    // ExtraExpected is totalExtra/numTservers. ExtraExtra is totalExtra%numTservers. Each tserver\n    // should have at least expectedExtra extra tablets and at most\n    // one extraExtra tablets. All extra tablets on a tserver must be from different groups.\n    //\n    // Assume we have 6 tservers and three groups (G1, G2, G3) with 9 tablets each. Each tserver is\n    // expected to have one tablet from each group and could\n    // possibly have 2 tablets from a group. Below is an illustration of an ideal balancing of extra\n    // tablets. To understand the illustration, the first column\n    // shows tserver T1 with 2 tablets from G1, 1 tablet from G2, and two tablets from G3. EE means\n    // empty, put it there so eclipse formatting would not mess up\n    // table.\n    //\n    // T1 | T2 | T3 | T4 | T5 | T6\n    // ---+----+----+----+----+-----\n    // G3 | G2 | G3 | EE | EE | EE <-- extra extra tablets\n    // G1 | G1 | G1 | G2 | G3 | G2 <-- extra expected tablets.\n    // G1 | G1 | G1 | G1 | G1 | G1 <-- expected tablets for group 1\n    // G2 | G2 | G2 | G2 | G2 | G2 <-- expected tablets for group 2\n    // G3 | G3 | G3 | G3 | G3 | G3 <-- expected tablets for group 3\n    //\n    // Do not want to balance the extra tablets like the following. There are two problem with this.\n    // First extra tablets are not evenly spread. Since there are\n    // a total of 9 extra tablets, every tserver is expected to have at least one extra tablet.\n    // Second tserver T1 has two extra tablet for group G1. This\n    // violates the principal that a tserver can only have one extra tablet for a given group.\n    //\n    // T1 | T2 | T3 | T4 | T5 | T6\n    // ---+----+----+----+----+-----\n    // G1 | EE | EE | EE | EE | EE <--- one extra tablets from group 1\n    // G3 | G3 | G3 | EE | EE | EE <--- three extra tablets from group 3\n    // G2 | G2 | G2 | EE | EE | EE <--- three extra tablets from group 2\n    // G1 | G1 | EE | EE | EE | EE <--- two extra tablets from group 1\n    // G1 | G1 | G1 | G1 | G1 | G1 <-- expected tablets for group 1\n    // G2 | G2 | G2 | G2 | G2 | G2 <-- expected tablets for group 2\n    // G3 | G3 | G3 | G3 | G3 | G3 <-- expected tablets for group 3\n\n    if (!shouldBalance(current, migrations)) {\n      return 5000;\n    }\n\n    if (System.currentTimeMillis() - lastRun < getWaitTime()) {\n      return 5000;\n    }\n\n    MapCounter<String> groupCounts = new MapCounter<>();\n    Map<TServerInstance,TserverGroupInfo> tservers = new HashMap<>();\n\n    for (TServerInstance tsi : current.keySet()) {\n      tservers.put(tsi, new TserverGroupInfo(tsi));\n    }\n\n    Function<KeyExtent,String> partitioner = getPartitioner();\n\n    // collect stats about current state\n    for (Pair<KeyExtent,Location> entry : getLocationProvider()) {\n      String group = partitioner.apply(entry.getFirst());\n      Location loc = entry.getSecond();\n\n      if (loc.equals(Location.NONE) || !tservers.containsKey(loc.getTserverInstance())) {\n        return 5000;\n      }\n\n      groupCounts.increment(group, 1);\n      TserverGroupInfo tgi = tservers.get(loc.getTserverInstance());\n      tgi.addGroup(group);\n    }\n\n    Map<String,Integer> expectedCounts = new HashMap<>();\n\n    int totalExtra = 0;\n    for (String group : groupCounts.keySet()) {\n      int groupCount = groupCounts.getInt(group);\n      totalExtra += groupCount % current.size();\n      expectedCounts.put(group, (groupCount / current.size()));\n    }\n\n    // The number of extra tablets from all groups that each tserver must have.\n    int expectedExtra = totalExtra / current.size();\n    int maxExtraGroups = expectedExtra + 1;\n\n    expectedCounts = Collections.unmodifiableMap(expectedCounts);\n    tservers = Collections.unmodifiableMap(tservers);\n\n    for (TserverGroupInfo tgi : tservers.values()) {\n      tgi.finishedAdding(expectedCounts);\n    }\n\n    Moves moves = new Moves();\n\n    // The order of the following steps is important, because as ordered each step should not move\n    // any tablets moved by a previous step.\n    balanceExpected(tservers, moves);\n    if (moves.size() < getMaxMigrations()) {\n      balanceExtraExpected(tservers, expectedExtra, moves);\n      if (moves.size() < getMaxMigrations()) {\n        boolean cont = balanceExtraMultiple(tservers, maxExtraGroups, moves);\n        if (cont && moves.size() < getMaxMigrations()) {\n          balanceExtraExtra(tservers, maxExtraGroups, moves);\n        }\n      }\n    }\n\n    populateMigrations(tservers.keySet(), migrationsOut, moves);\n\n    lastRun = System.currentTimeMillis();\n\n    return 5000;\n  }", "signature": "long balance(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations, List<TabletMigration> migrationsOut)", "full_signature": "@Override public long balance(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations, List<TabletMigration> migrationsOut)", "class_method_signature": "GroupBalancer.balance(SortedMap<TServerInstance,TabletServerStatus> current,\n      Set<KeyExtent> migrations, List<TabletMigration> migrationsOut)", "testcase": false, "constructor": false, "invocations": ["shouldBalance", "currentTimeMillis", "getWaitTime", "keySet", "put", "getPartitioner", "getLocationProvider", "apply", "getFirst", "getSecond", "equals", "containsKey", "getTserverInstance", "increment", "get", "getTserverInstance", "addGroup", "keySet", "getInt", "size", "put", "size", "size", "unmodifiableMap", "unmodifiableMap", "values", "finishedAdding", "balanceExpected", "size", "getMaxMigrations", "balanceExtraExpected", "size", "getMaxMigrations", "balanceExtraMultiple", "size", "getMaxMigrations", "balanceExtraExtra", "populateMigrations", "keySet", "currentTimeMillis"]}, "repository": {"repo_id": 2524488, "url": "https://github.com/apache/accumulo", "stars": 779, "created": "10/6/2011 7:00:09 AM +00:00", "updates": "2020-01-24T17:34:30+00:00", "fork": "False", "license": "licensed"}}