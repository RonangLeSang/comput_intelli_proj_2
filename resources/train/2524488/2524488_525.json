{"test_class": {"identifier": "FileUtilTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n  public TemporaryFolder tmpDir =\n      new TemporaryFolder(new File(System.getProperty(\"user.dir\") + \"/target\"));", "modifier": "@Rule\n  public", "type": "TemporaryFolder", "declarator": "tmpDir =\n      new TemporaryFolder(new File(System.getProperty(\"user.dir\") + \"/target\"))", "var_name": "tmpDir"}, {"original_string": "@Rule\n  public TestName testName = new TestName();", "modifier": "@Rule\n  public", "type": "TestName", "declarator": "testName = new TestName()", "var_name": "testName"}, {"original_string": "private File accumuloDir;", "modifier": "private", "type": "File", "declarator": "accumuloDir", "var_name": "accumuloDir"}], "file": "server/base/src/test/java/org/apache/accumulo/server/util/FileUtilTest.java"}, "test_case": {"identifier": "testCleanupIndexOpWithoutCommonParentVolume", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testCleanupIndexOpWithoutCommonParentVolume() throws IOException {\n    // Make some directories to simulate multiple volumes\n    File v1 = new File(accumuloDir, \"v1\"), v2 = new File(accumuloDir, \"v2\");\n    assertTrue(v1.mkdirs() || v1.isDirectory());\n    assertTrue(v2.mkdirs() || v2.isDirectory());\n\n    // And a \"unique\" tmp directory for each volume\n    File tmp1 = new File(v1, \"tmp\"), tmp2 = new File(v2, \"tmp\");\n    assertTrue(tmp1.mkdirs() || tmp1.isDirectory());\n    assertTrue(tmp2.mkdirs() || tmp2.isDirectory());\n    Path tmpPath1 = new Path(tmp1.toURI()), tmpPath2 = new Path(tmp2.toURI());\n\n    HashMap<Property,String> testProps = new HashMap<>();\n    testProps.put(Property.INSTANCE_VOLUMES, v1.toURI() + \",\" + v2.toURI());\n\n    try (var fs = VolumeManagerImpl.getLocalForTesting(accumuloDir.getAbsolutePath())) {\n      FileUtil.cleanupIndexOp(tmpPath1, fs, new ArrayList<>());\n      assertFalse(\"Expected \" + tmp1 + \" to be cleaned up but it wasn't\", tmp1.exists());\n      FileUtil.cleanupIndexOp(tmpPath2, fs, new ArrayList<>());\n      assertFalse(\"Expected \" + tmp2 + \" to be cleaned up but it wasn't\", tmp2.exists());\n    }\n  }", "signature": "void testCleanupIndexOpWithoutCommonParentVolume()", "full_signature": "@Test public void testCleanupIndexOpWithoutCommonParentVolume()", "class_method_signature": "FileUtilTest.testCleanupIndexOpWithoutCommonParentVolume()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "mkdirs", "isDirectory", "assertTrue", "mkdirs", "isDirectory", "assertTrue", "mkdirs", "isDirectory", "assertTrue", "mkdirs", "isDirectory", "toURI", "toURI", "put", "toURI", "toURI", "getLocalForTesting", "getAbsolutePath", "cleanupIndexOp", "assertFalse", "exists", "cleanupIndexOp", "assertFalse", "exists"]}, "focal_class": {"identifier": "FileUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(FileUtil.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(FileUtil.class)", "var_name": "log"}], "methods": [{"identifier": "createTmpDir", "parameters": "(ServerContext context, String tabletDirectory)", "modifiers": "private static", "return": "Path", "signature": "Path createTmpDir(ServerContext context, String tabletDirectory)", "full_signature": "private static Path createTmpDir(ServerContext context, String tabletDirectory)", "class_method_signature": "FileUtil.createTmpDir(ServerContext context, String tabletDirectory)", "testcase": false, "constructor": false}, {"identifier": "reduceFiles", "parameters": "(ServerContext context, Configuration conf,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, int maxFiles, Path tmpDir,\n      int pass)", "modifiers": "public static", "return": "Collection<TabletFile>", "signature": "Collection<TabletFile> reduceFiles(ServerContext context, Configuration conf,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, int maxFiles, Path tmpDir,\n      int pass)", "full_signature": "public static Collection<TabletFile> reduceFiles(ServerContext context, Configuration conf,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, int maxFiles, Path tmpDir,\n      int pass)", "class_method_signature": "FileUtil.reduceFiles(ServerContext context, Configuration conf,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, int maxFiles, Path tmpDir,\n      int pass)", "testcase": false, "constructor": false}, {"identifier": "findMidPoint", "parameters": "(ServerContext context, String tabletDir,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, double minSplit)", "modifiers": "public static", "return": "SortedMap<Double,Key>", "signature": "SortedMap<Double,Key> findMidPoint(ServerContext context, String tabletDir,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, double minSplit)", "full_signature": "public static SortedMap<Double,Key> findMidPoint(ServerContext context, String tabletDir,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, double minSplit)", "class_method_signature": "FileUtil.findMidPoint(ServerContext context, String tabletDir,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, double minSplit)", "testcase": false, "constructor": false}, {"identifier": "estimatePercentageLTE", "parameters": "(ServerContext context, String tabletDir,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, Text splitRow)", "modifiers": "public static", "return": "double", "signature": "double estimatePercentageLTE(ServerContext context, String tabletDir,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, Text splitRow)", "full_signature": "public static double estimatePercentageLTE(ServerContext context, String tabletDir,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, Text splitRow)", "class_method_signature": "FileUtil.estimatePercentageLTE(ServerContext context, String tabletDir,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, Text splitRow)", "testcase": false, "constructor": false}, {"identifier": "findMidPoint", "parameters": "(ServerContext context, String tabletDirectory,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, double minSplit,\n      boolean useIndex)", "modifiers": "public static", "return": "SortedMap<Double,Key>", "signature": "SortedMap<Double,Key> findMidPoint(ServerContext context, String tabletDirectory,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, double minSplit,\n      boolean useIndex)", "full_signature": "public static SortedMap<Double,Key> findMidPoint(ServerContext context, String tabletDirectory,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, double minSplit,\n      boolean useIndex)", "class_method_signature": "FileUtil.findMidPoint(ServerContext context, String tabletDirectory,\n      Text prevEndRow, Text endRow, Collection<TabletFile> mapFiles, double minSplit,\n      boolean useIndex)", "testcase": false, "constructor": false}, {"identifier": "cleanupIndexOp", "parameters": "(Path tmpDir, VolumeManager fs,\n      ArrayList<FileSKVIterator> readers)", "modifiers": "protected static", "return": "void", "signature": "void cleanupIndexOp(Path tmpDir, VolumeManager fs,\n      ArrayList<FileSKVIterator> readers)", "full_signature": "protected static void cleanupIndexOp(Path tmpDir, VolumeManager fs,\n      ArrayList<FileSKVIterator> readers)", "class_method_signature": "FileUtil.cleanupIndexOp(Path tmpDir, VolumeManager fs,\n      ArrayList<FileSKVIterator> readers)", "testcase": false, "constructor": false}, {"identifier": "countIndexEntries", "parameters": "(ServerContext context, Text prevEndRow, Text endRow,\n      Collection<TabletFile> mapFiles, boolean useIndex, ArrayList<FileSKVIterator> readers)", "modifiers": "private static", "return": "long", "signature": "long countIndexEntries(ServerContext context, Text prevEndRow, Text endRow,\n      Collection<TabletFile> mapFiles, boolean useIndex, ArrayList<FileSKVIterator> readers)", "full_signature": "private static long countIndexEntries(ServerContext context, Text prevEndRow, Text endRow,\n      Collection<TabletFile> mapFiles, boolean useIndex, ArrayList<FileSKVIterator> readers)", "class_method_signature": "FileUtil.countIndexEntries(ServerContext context, Text prevEndRow, Text endRow,\n      Collection<TabletFile> mapFiles, boolean useIndex, ArrayList<FileSKVIterator> readers)", "testcase": false, "constructor": false}, {"identifier": "tryToGetFirstAndLastRows", "parameters": "(ServerContext context,\n      Set<TabletFile> mapfiles)", "modifiers": "public static", "return": "Map<TabletFile,FileInfo>", "signature": "Map<TabletFile,FileInfo> tryToGetFirstAndLastRows(ServerContext context,\n      Set<TabletFile> mapfiles)", "full_signature": "public static Map<TabletFile,FileInfo> tryToGetFirstAndLastRows(ServerContext context,\n      Set<TabletFile> mapfiles)", "class_method_signature": "FileUtil.tryToGetFirstAndLastRows(ServerContext context,\n      Set<TabletFile> mapfiles)", "testcase": false, "constructor": false}, {"identifier": "findLastKey", "parameters": "(ServerContext context,\n      Collection<TabletFile> mapFiles)", "modifiers": "public static", "return": "WritableComparable<Key>", "signature": "WritableComparable<Key> findLastKey(ServerContext context,\n      Collection<TabletFile> mapFiles)", "full_signature": "public static WritableComparable<Key> findLastKey(ServerContext context,\n      Collection<TabletFile> mapFiles)", "class_method_signature": "FileUtil.findLastKey(ServerContext context,\n      Collection<TabletFile> mapFiles)", "testcase": false, "constructor": false}, {"identifier": "estimateSizes", "parameters": "(ServerContext context, Path mapFile,\n      long fileSize, List<KeyExtent> extents)", "modifiers": "public static", "return": "Map<KeyExtent,Long>", "signature": "Map<KeyExtent,Long> estimateSizes(ServerContext context, Path mapFile,\n      long fileSize, List<KeyExtent> extents)", "full_signature": "public static Map<KeyExtent,Long> estimateSizes(ServerContext context, Path mapFile,\n      long fileSize, List<KeyExtent> extents)", "class_method_signature": "FileUtil.estimateSizes(ServerContext context, Path mapFile,\n      long fileSize, List<KeyExtent> extents)", "testcase": false, "constructor": false}], "file": "server/base/src/main/java/org/apache/accumulo/server/util/FileUtil.java"}, "focal_method": {"identifier": "cleanupIndexOp", "parameters": "(Path tmpDir, VolumeManager fs,\n      ArrayList<FileSKVIterator> readers)", "modifiers": "protected static", "return": "void", "body": "protected static void cleanupIndexOp(Path tmpDir, VolumeManager fs,\n      ArrayList<FileSKVIterator> readers) throws IOException {\n    // close all of the index sequence files\n    for (FileSKVIterator r : readers) {\n      try {\n        if (r != null)\n          r.close();\n      } catch (IOException e) {\n        // okay, try to close the rest anyway\n        log.error(\"{}\", e.getMessage(), e);\n      }\n    }\n\n    if (tmpDir != null) {\n      FileSystem actualFs = fs.getFileSystemByPath(tmpDir);\n      if (actualFs.exists(tmpDir)) {\n        fs.deleteRecursively(tmpDir);\n        return;\n      }\n\n      log.error(\"Did not delete tmp dir because it wasn't a tmp dir {}\", tmpDir);\n    }\n  }", "signature": "void cleanupIndexOp(Path tmpDir, VolumeManager fs,\n      ArrayList<FileSKVIterator> readers)", "full_signature": "protected static void cleanupIndexOp(Path tmpDir, VolumeManager fs,\n      ArrayList<FileSKVIterator> readers)", "class_method_signature": "FileUtil.cleanupIndexOp(Path tmpDir, VolumeManager fs,\n      ArrayList<FileSKVIterator> readers)", "testcase": false, "constructor": false, "invocations": ["close", "error", "getMessage", "getFileSystemByPath", "exists", "deleteRecursively", "error"]}, "repository": {"repo_id": 2524488, "url": "https://github.com/apache/accumulo", "stars": 779, "created": "10/6/2011 7:00:09 AM +00:00", "updates": "2020-01-24T17:34:30+00:00", "fork": "False", "license": "licensed"}}