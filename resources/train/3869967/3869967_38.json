{"test_class": {"identifier": "LdapMapperTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(LdapMapperTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(LdapMapperTest.class)", "var_name": "log"}], "file": "ldap/src/test/java/org/soluvas/ldap/LdapMapperTest.java"}, "test_case": {"identifier": "canMapToBooleanTrue", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void canMapToBooleanTrue() throws LdapException {\n\t\tfinal LdapMapper<SocialPerson> mapper = new LdapMapper<>();\n\t\t\n\t\tfinal SocialPerson hendy = new SocialPerson(\"hendy\", \"hendy\", \"Hendy\", \"Irawan\");\n\t\thendy.setNewsletterSubscriptionEnabled(true);\n\t\tlog.info(\"Input Person: {}\", hendy);\n\t\t\n\t\tfinal Entry personEntry = mapper.toEntry(hendy, \"ou=users\");\n\t\tassertEquals(\"TRUE\", personEntry.get(\"newsletterSubscriptionEnabled\").getString());\n\t}", "signature": "void canMapToBooleanTrue()", "full_signature": "@Test public void canMapToBooleanTrue()", "class_method_signature": "LdapMapperTest.canMapToBooleanTrue()", "testcase": true, "constructor": false, "invocations": ["setNewsletterSubscriptionEnabled", "info", "toEntry", "assertEquals", "getString", "get"]}, "focal_class": {"identifier": "LdapMapper", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger log = LoggerFactory.getLogger(LdapMapper.class);", "modifier": "private static", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(LdapMapper.class)", "var_name": "log"}, {"original_string": "private final LoadingCache<Class<?>, LdapMapping> mappings = CacheBuilder.newBuilder().build(new CacheLoader<Class<?>, LdapMapping>() {\n\t\t@Override\n\t\tpublic LdapMapping load(Class<?> clazz) throws Exception {\n\t\t\tfinal List<Field> fields = ReflectionUtils.getAllFields(clazz);\n\t\t\t\n\t\t\tfinal LdapEntry entryAnn = clazz.getAnnotation(LdapEntry.class);\n\t\t\tif (entryAnn != null) {\n\t\t\t\tfinal String[] objectClasses = entryAnn.objectClasses();\n\t\t\t\tlog.debug(\"Class {} maps to {} LDAP objectClasses: {}\", clazz.getName(), objectClasses.length, objectClasses);\n\t\t\t\tlog.debug(\"Mapping {} from {} fields: {}\", clazz.getName(), fields.size(), fields);\n\t\t\t\tfinal ImmutableList.Builder<LdapAttributeMapping> attrMappingBuilder = ImmutableList.builder();\n\t\t\t\tLdapAttributeMapping rdnMapping = null; \n\t\t\t\tfor (final Field field : fields) {\n\t\t\t\t\tfinal LdapAttribute ldapAttribute = field.getAnnotation(LdapAttribute.class);\n\t\t\t\t\tif (ldapAttribute == null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfinal String attrName = ldapAttribute.value()[0];\n\t\t\t\t\tfinal LdapRdn ldapRdn = field.getAnnotation(LdapRdn.class);\n\t\t\t\t\tfinal String fieldName = field.getName();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (ldapRdn != null) {\n\t\t\t\t\t\t\tif (rdnMapping != null) {\n\t\t\t\t\t\t\t\tthrow new LdapMappingException(clazz.getName() + \" has multiple @LdapRdn\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trdnMapping = new LdapAttributeMapping(field, attrName, false);\n\t\t\t\t\t\t\tattrMappingBuilder.add(rdnMapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (Set.class.isAssignableFrom(field.getType())) {\n\t\t\t\t\t\t\t\tfinal LdapAttributeMapping attrMapping = new LdapAttributeMapping(field, attrName, true);\n\t\t\t\t\t\t\t\tattrMappingBuilder.add(attrMapping);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfinal LdapAttributeMapping attrMapping = new LdapAttributeMapping(field, attrName, false);\n\t\t\t\t\t\t\t\tattrMappingBuilder.add(attrMapping);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tthrow new LdapMappingException(e, \"Error mapping %s property %s to attribute %s\",\n\t\t\t\t\t\t\t\tclazz.getName(), fieldName, attrName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPreconditions.checkNotNull(rdnMapping, \"%s has %s fields, one must have @LdapRdn annotation\", clazz.getName(), fields.size());\n\t\t\t\tfinal LdapMapping mapping = new LdapMapping( ImmutableSet.copyOf(objectClasses), rdnMapping, attrMappingBuilder.build() );\n\t\t\t\treturn mapping;\n\t\t\t} else {\n\t\t\t\tlog.info(\"Class \" + clazz.getName() + \" (probably a generic superclass) is not annotated with @LdapEntry, not mapping LDAP\");\n\t\t\t\treturn new LdapMapping( ImmutableSet.<String>of(), null, ImmutableList.<LdapAttributeMapping>of() );\n\t\t\t}\n\t\t}\n\t});", "modifier": "private final", "type": "LoadingCache<Class<?>, LdapMapping>", "declarator": "mappings = CacheBuilder.newBuilder().build(new CacheLoader<Class<?>, LdapMapping>() {\n\t\t@Override\n\t\tpublic LdapMapping load(Class<?> clazz) throws Exception {\n\t\t\tfinal List<Field> fields = ReflectionUtils.getAllFields(clazz);\n\t\t\t\n\t\t\tfinal LdapEntry entryAnn = clazz.getAnnotation(LdapEntry.class);\n\t\t\tif (entryAnn != null) {\n\t\t\t\tfinal String[] objectClasses = entryAnn.objectClasses();\n\t\t\t\tlog.debug(\"Class {} maps to {} LDAP objectClasses: {}\", clazz.getName(), objectClasses.length, objectClasses);\n\t\t\t\tlog.debug(\"Mapping {} from {} fields: {}\", clazz.getName(), fields.size(), fields);\n\t\t\t\tfinal ImmutableList.Builder<LdapAttributeMapping> attrMappingBuilder = ImmutableList.builder();\n\t\t\t\tLdapAttributeMapping rdnMapping = null; \n\t\t\t\tfor (final Field field : fields) {\n\t\t\t\t\tfinal LdapAttribute ldapAttribute = field.getAnnotation(LdapAttribute.class);\n\t\t\t\t\tif (ldapAttribute == null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfinal String attrName = ldapAttribute.value()[0];\n\t\t\t\t\tfinal LdapRdn ldapRdn = field.getAnnotation(LdapRdn.class);\n\t\t\t\t\tfinal String fieldName = field.getName();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (ldapRdn != null) {\n\t\t\t\t\t\t\tif (rdnMapping != null) {\n\t\t\t\t\t\t\t\tthrow new LdapMappingException(clazz.getName() + \" has multiple @LdapRdn\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trdnMapping = new LdapAttributeMapping(field, attrName, false);\n\t\t\t\t\t\t\tattrMappingBuilder.add(rdnMapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (Set.class.isAssignableFrom(field.getType())) {\n\t\t\t\t\t\t\t\tfinal LdapAttributeMapping attrMapping = new LdapAttributeMapping(field, attrName, true);\n\t\t\t\t\t\t\t\tattrMappingBuilder.add(attrMapping);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfinal LdapAttributeMapping attrMapping = new LdapAttributeMapping(field, attrName, false);\n\t\t\t\t\t\t\t\tattrMappingBuilder.add(attrMapping);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tthrow new LdapMappingException(e, \"Error mapping %s property %s to attribute %s\",\n\t\t\t\t\t\t\t\tclazz.getName(), fieldName, attrName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPreconditions.checkNotNull(rdnMapping, \"%s has %s fields, one must have @LdapRdn annotation\", clazz.getName(), fields.size());\n\t\t\t\tfinal LdapMapping mapping = new LdapMapping( ImmutableSet.copyOf(objectClasses), rdnMapping, attrMappingBuilder.build() );\n\t\t\t\treturn mapping;\n\t\t\t} else {\n\t\t\t\tlog.info(\"Class \" + clazz.getName() + \" (probably a generic superclass) is not annotated with @LdapEntry, not mapping LDAP\");\n\t\t\t\treturn new LdapMapping( ImmutableSet.<String>of(), null, ImmutableList.<LdapAttributeMapping>of() );\n\t\t\t}\n\t\t}\n\t})", "var_name": "mappings"}], "methods": [{"identifier": "LdapMapper", "parameters": "()", "modifiers": "public", "return": "", "signature": " LdapMapper()", "full_signature": "public  LdapMapper()", "class_method_signature": "LdapMapper.LdapMapper()", "testcase": false, "constructor": true}, {"identifier": "getMapping", "parameters": "(final Class<?> clazz)", "modifiers": "public", "return": "LdapMapping", "signature": "LdapMapping getMapping(final Class<?> clazz)", "full_signature": "public LdapMapping getMapping(final Class<?> clazz)", "class_method_signature": "LdapMapper.getMapping(final Class<?> clazz)", "testcase": false, "constructor": false}, {"identifier": "toEntry", "parameters": "(Object obj, String baseDn)", "modifiers": "public", "return": "Entry", "signature": "Entry toEntry(Object obj, String baseDn)", "full_signature": "public Entry toEntry(Object obj, String baseDn)", "class_method_signature": "LdapMapper.toEntry(Object obj, String baseDn)", "testcase": false, "constructor": false}, {"identifier": "getAttributeIds", "parameters": "(Class<?> clazz)", "modifiers": "public", "return": "Set<String>", "signature": "Set<String> getAttributeIds(Class<?> clazz)", "full_signature": "public Set<String> getAttributeIds(Class<?> clazz)", "class_method_signature": "LdapMapper.getAttributeIds(Class<?> clazz)", "testcase": false, "constructor": false}, {"identifier": "mapFromProperties", "parameters": "(final Object obj, String baseDn, final Class<?> clazz,\n\t\t\tfinal Entry entry)", "modifiers": "protected", "return": "void", "signature": "void mapFromProperties(final Object obj, String baseDn, final Class<?> clazz,\n\t\t\tfinal Entry entry)", "full_signature": "protected void mapFromProperties(final Object obj, String baseDn, final Class<?> clazz,\n\t\t\tfinal Entry entry)", "class_method_signature": "LdapMapper.mapFromProperties(final Object obj, String baseDn, final Class<?> clazz,\n\t\t\tfinal Entry entry)", "testcase": false, "constructor": false}, {"identifier": "fromEntry", "parameters": "(Entry entry, Class<? extends T> entityClass)", "modifiers": "public", "return": "T", "signature": "T fromEntry(Entry entry, Class<? extends T> entityClass)", "full_signature": "public T fromEntry(Entry entry, Class<? extends T> entityClass)", "class_method_signature": "LdapMapper.fromEntry(Entry entry, Class<? extends T> entityClass)", "testcase": false, "constructor": false}, {"identifier": "getDn", "parameters": "(final String rdnValue, final Class<?> clazz, final String baseDn)", "modifiers": "public", "return": "String", "signature": "String getDn(final String rdnValue, final Class<?> clazz, final String baseDn)", "full_signature": "public String getDn(final String rdnValue, final Class<?> clazz, final String baseDn)", "class_method_signature": "LdapMapper.getDn(final String rdnValue, final Class<?> clazz, final String baseDn)", "testcase": false, "constructor": false}, {"identifier": "getDn", "parameters": "(final Object obj, final String baseDn)", "modifiers": "@Nonnull public", "return": "String", "signature": "String getDn(final Object obj, final String baseDn)", "full_signature": "@Nonnull public String getDn(final Object obj, final String baseDn)", "class_method_signature": "LdapMapper.getDn(final Object obj, final String baseDn)", "testcase": false, "constructor": false}, {"identifier": "getRdnValue", "parameters": "(final Object obj)", "modifiers": "@Nullable public", "return": "String", "signature": "String getRdnValue(final Object obj)", "full_signature": "@Nullable public String getRdnValue(final Object obj)", "class_method_signature": "LdapMapper.getRdnValue(final Object obj)", "testcase": false, "constructor": false}, {"identifier": "mapToProperties", "parameters": "(Entry entry, Class<?> clazz, T bean)", "modifiers": "protected", "return": "void", "signature": "void mapToProperties(Entry entry, Class<?> clazz, T bean)", "full_signature": "protected void mapToProperties(Entry entry, Class<?> clazz, T bean)", "class_method_signature": "LdapMapper.mapToProperties(Entry entry, Class<?> clazz, T bean)", "testcase": false, "constructor": false}, {"identifier": "convertToPropertyValue", "parameters": "(Class<R> fieldType, final Object value)", "modifiers": "@SuppressWarnings(\"unchecked\") protected", "return": "R", "signature": "R convertToPropertyValue(Class<R> fieldType, final Object value)", "full_signature": "@SuppressWarnings(\"unchecked\") protected R convertToPropertyValue(Class<R> fieldType, final Object value)", "class_method_signature": "LdapMapper.convertToPropertyValue(Class<R> fieldType, final Object value)", "testcase": false, "constructor": false}, {"identifier": "convertFromPropertyValue", "parameters": "(Class<?> fieldType, final Object value)", "modifiers": "protected", "return": "String", "signature": "String convertFromPropertyValue(Class<?> fieldType, final Object value)", "full_signature": "protected String convertFromPropertyValue(Class<?> fieldType, final Object value)", "class_method_signature": "LdapMapper.convertFromPropertyValue(Class<?> fieldType, final Object value)", "testcase": false, "constructor": false}, {"identifier": "createModifyRequest", "parameters": "(final Entry existingEntry, final T existing, final T up)", "modifiers": "public", "return": "ModifyRequest", "signature": "ModifyRequest createModifyRequest(final Entry existingEntry, final T existing, final T up)", "full_signature": "public ModifyRequest createModifyRequest(final Entry existingEntry, final T existing, final T up)", "class_method_signature": "LdapMapper.createModifyRequest(final Entry existingEntry, final T existing, final T up)", "testcase": false, "constructor": false}], "file": "ldap/src/main/java/org/soluvas/ldap/LdapMapper.java"}, "focal_method": {"identifier": "toEntry", "parameters": "(Object obj, String baseDn)", "modifiers": "public", "return": "Entry", "body": "public Entry toEntry(Object obj, String baseDn) {\n\t\tPreconditions.checkNotNull(obj, \"Cannot map null object in %s\", baseDn);\n\t\tfinal Class<?> clazz = obj.getClass();\n\t\tlog.trace(\"Mapping {} {} as Entry in {}\", clazz.getName(), obj, baseDn);\n\t\t\n\t\t// Create the Entry (TODO: should be after mapping is prepared)\n\t\tfinal DefaultEntry entry = new DefaultEntry();\n\t\t\n\t\t// Prepare the mapping from the provided object side\n\t\t\n\t\t// Prepare the mapping from the Class side\n\t\tLdapEntry entryAnn = clazz.getAnnotation(LdapEntry.class);\n\t\tif (entryAnn == null) {\n\t\t\tthrow new LdapMappingException(clazz.getName() + \" must be annotated with @LdapEntry\");\n\t\t}\n\t\tfinal String[] objectClasses = entryAnn.objectClasses();\n\t\tlog.trace(\"{} maps to objectClasses: {}\", clazz.getName(), objectClasses);\n\t\ttry {\n\t\t\tentry.add(\"objectClass\", objectClasses);\n\t\t\t\n\t\t\tClass<?> currentClass = clazz;\n\t\t\twhile (currentClass != null) {\n\t\t\t\tmapFromProperties(obj, baseDn, currentClass, entry);\n\t\t\t\tcurrentClass = currentClass.getSuperclass();\n\t\t\t\tif (currentClass == Object.class || currentClass == EObjectImpl.class) // stop when we find the \"root\" superclass\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\treturn entry;\n\t\t} catch (LdapException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new LdapMappingException(e, \"Error mapping \" + clazz.getName());\n\t\t}\n\t}", "signature": "Entry toEntry(Object obj, String baseDn)", "full_signature": "public Entry toEntry(Object obj, String baseDn)", "class_method_signature": "LdapMapper.toEntry(Object obj, String baseDn)", "testcase": false, "constructor": false, "invocations": ["checkNotNull", "getClass", "trace", "getName", "getAnnotation", "getName", "objectClasses", "trace", "getName", "add", "mapFromProperties", "getSuperclass", "getName"]}, "repository": {"repo_id": 3869967, "url": "https://github.com/soluvas/soluvas-framework", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 11, "size": 19799, "license": "licensed"}}