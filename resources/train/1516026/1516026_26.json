{"test_class": {"identifier": "DateUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "qcadoo-localization/src/test/java/com/qcadoo/localization/api/utils/DateUtilsTest.java"}, "test_case": {"identifier": "shouldParseYearMonthDayDown", "parameters": "()", "modifiers": "@Test public final", "return": "void", "body": "@Test\n    public final void shouldParseYearMonthDayDown() throws ParseException {\n        // given\n        final String expr = \"2013-05-20\";\n        final boolean upComplete = false;\n\n        // when\n        final Date date = DateUtils.parseAndComplete(expr, upComplete);\n\n        // then\n        assertDateEquals(new DateTime(2013, 5, 20, 0, 0, 0, 0), date);\n    }", "signature": "void shouldParseYearMonthDayDown()", "full_signature": "@Test public final void shouldParseYearMonthDayDown()", "class_method_signature": "DateUtilsTest.shouldParseYearMonthDayDown()", "testcase": true, "constructor": false, "invocations": ["parseAndComplete", "assertDateEquals"]}, "focal_class": {"identifier": "DateUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String PARSE_EXCEPTION_MSG = \"Can't parse date from value '%s'\";", "modifier": "private static final", "type": "String", "declarator": "PARSE_EXCEPTION_MSG = \"Can't parse date from value '%s'\"", "var_name": "PARSE_EXCEPTION_MSG"}, {"original_string": "private static final String L_WRONG_DATE = \"wrong date\";", "modifier": "private static final", "type": "String", "declarator": "L_WRONG_DATE = \"wrong date\"", "var_name": "L_WRONG_DATE"}, {"original_string": "public static final String L_DATE_FORMAT = \"yyyy-MM-dd\";", "modifier": "public static final", "type": "String", "declarator": "L_DATE_FORMAT = \"yyyy-MM-dd\"", "var_name": "L_DATE_FORMAT"}, {"original_string": "public static final String L_DATE_TIME_FORMAT = \"yyyy-MM-dd HH:mm:ss\";", "modifier": "public static final", "type": "String", "declarator": "L_DATE_TIME_FORMAT = \"yyyy-MM-dd HH:mm:ss\"", "var_name": "L_DATE_TIME_FORMAT"}, {"original_string": "public static final String L_REPORT_DATE_TIME_FORMAT = \"yyyy_MM_dd_HH_mm_ss\";", "modifier": "public static final", "type": "String", "declarator": "L_REPORT_DATE_TIME_FORMAT = \"yyyy_MM_dd_HH_mm_ss\"", "var_name": "L_REPORT_DATE_TIME_FORMAT"}, {"original_string": "private static final String[] SUPPORTED_PATTERNS = new String[] { L_DATE_TIME_FORMAT, \"yyyy-MM-dd HH:mm:\",\n            \"yyyy-MM-dd HH:mm\", \"yyyy-MM-dd HH:\", \"yyyy-MM-dd HH\", \"yyyy-MM-dd\", \"yyyy-MM-\", \"yyyy-MM\", \"yyyy-\", \"yyyy\" };", "modifier": "private static final", "type": "String[]", "declarator": "SUPPORTED_PATTERNS = new String[] { L_DATE_TIME_FORMAT, \"yyyy-MM-dd HH:mm:\",\n            \"yyyy-MM-dd HH:mm\", \"yyyy-MM-dd HH:\", \"yyyy-MM-dd HH\", \"yyyy-MM-dd\", \"yyyy-MM-\", \"yyyy-MM\", \"yyyy-\", \"yyyy\" }", "var_name": "SUPPORTED_PATTERNS"}], "methods": [{"identifier": "DateUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " DateUtils()", "full_signature": "private  DateUtils()", "class_method_signature": "DateUtils.DateUtils()", "testcase": false, "constructor": true}, {"identifier": "parseAndComplete", "parameters": "(final String dateExpression, final boolean upComplete)", "modifiers": "public static", "return": "Date", "signature": "Date parseAndComplete(final String dateExpression, final boolean upComplete)", "full_signature": "public static Date parseAndComplete(final String dateExpression, final boolean upComplete)", "class_method_signature": "DateUtils.parseAndComplete(final String dateExpression, final boolean upComplete)", "testcase": false, "constructor": false}, {"identifier": "round", "parameters": "(final DateTime dateTime, final boolean upComplete, final String[] dateAndTime)", "modifiers": "private static", "return": "DateTime", "signature": "DateTime round(final DateTime dateTime, final boolean upComplete, final String[] dateAndTime)", "full_signature": "private static DateTime round(final DateTime dateTime, final boolean upComplete, final String[] dateAndTime)", "class_method_signature": "DateUtils.round(final DateTime dateTime, final boolean upComplete, final String[] dateAndTime)", "testcase": false, "constructor": false}, {"identifier": "roundUpDate", "parameters": "(final DateTime dateTime, final String dateExpressionPart)", "modifiers": "private static", "return": "DateTime", "signature": "DateTime roundUpDate(final DateTime dateTime, final String dateExpressionPart)", "full_signature": "private static DateTime roundUpDate(final DateTime dateTime, final String dateExpressionPart)", "class_method_signature": "DateUtils.roundUpDate(final DateTime dateTime, final String dateExpressionPart)", "testcase": false, "constructor": false}, {"identifier": "roundUpTime", "parameters": "(final DateTime dateTime, final String timeExpressionPart)", "modifiers": "private static", "return": "DateTime", "signature": "DateTime roundUpTime(final DateTime dateTime, final String timeExpressionPart)", "full_signature": "private static DateTime roundUpTime(final DateTime dateTime, final String timeExpressionPart)", "class_method_signature": "DateUtils.roundUpTime(final DateTime dateTime, final String timeExpressionPart)", "testcase": false, "constructor": false}, {"identifier": "toDateTimeString", "parameters": "(final Date date)", "modifiers": "public static", "return": "String", "signature": "String toDateTimeString(final Date date)", "full_signature": "public static String toDateTimeString(final Date date)", "class_method_signature": "DateUtils.toDateTimeString(final Date date)", "testcase": false, "constructor": false}, {"identifier": "toDateString", "parameters": "(final Date date)", "modifiers": "public static", "return": "String", "signature": "String toDateString(final Date date)", "full_signature": "public static String toDateString(final Date date)", "class_method_signature": "DateUtils.toDateString(final Date date)", "testcase": false, "constructor": false}, {"identifier": "formatDate", "parameters": "(final Date date, final String pattern)", "modifiers": "private static", "return": "String", "signature": "String formatDate(final Date date, final String pattern)", "full_signature": "private static String formatDate(final Date date, final String pattern)", "class_method_signature": "DateUtils.formatDate(final Date date, final String pattern)", "testcase": false, "constructor": false}, {"identifier": "parseDate", "parameters": "(final Object value)", "modifiers": "public static", "return": "Date", "signature": "Date parseDate(final Object value)", "full_signature": "public static Date parseDate(final Object value)", "class_method_signature": "DateUtils.parseDate(final Object value)", "testcase": false, "constructor": false}, {"identifier": "tryParse", "parameters": "(final Object value)", "modifiers": "public static", "return": "Either<? extends Exception, Optional<DateTime>>", "signature": "Either<? extends Exception, Optional<DateTime>> tryParse(final Object value)", "full_signature": "public static Either<? extends Exception, Optional<DateTime>> tryParse(final Object value)", "class_method_signature": "DateUtils.tryParse(final Object value)", "testcase": false, "constructor": false}, {"identifier": "copy", "parameters": "(final Date date)", "modifiers": "public static", "return": "Date", "signature": "Date copy(final Date date)", "full_signature": "public static Date copy(final Date date)", "class_method_signature": "DateUtils.copy(final Date date)", "testcase": false, "constructor": false}], "file": "qcadoo-localization/src/main/java/com/qcadoo/localization/api/utils/DateUtils.java"}, "focal_method": {"identifier": "parseAndComplete", "parameters": "(final String dateExpression, final boolean upComplete)", "modifiers": "public static", "return": "Date", "body": "public static Date parseAndComplete(final String dateExpression, final boolean upComplete) throws ParseException {\n        final String trimmedDateExpression = StringUtils.trim(dateExpression);\n        DateTime parsedDate = new DateTime(org.apache.commons.lang3.time.DateUtils.parseDateStrictly(trimmedDateExpression,\n                SUPPORTED_PATTERNS));\n\n        final String[] dateAndTime = trimmedDateExpression.split(\" \");\n        if (dateAndTime.length > 2 || parsedDate.getYear() < 1500 || parsedDate.getYear() > 2500) {\n            throw new ParseException(L_WRONG_DATE, 1);\n        }\n\n        return round(parsedDate, upComplete, dateAndTime).toDate();\n    }", "signature": "Date parseAndComplete(final String dateExpression, final boolean upComplete)", "full_signature": "public static Date parseAndComplete(final String dateExpression, final boolean upComplete)", "class_method_signature": "DateUtils.parseAndComplete(final String dateExpression, final boolean upComplete)", "testcase": false, "constructor": false, "invocations": ["trim", "parseDateStrictly", "split", "getYear", "getYear", "toDate", "round"]}, "repository": {"repo_id": 1516026, "url": "https://github.com/qcadoo/qcadoo", "stars": 47, "created": "3/23/2011 12:07:38 PM +00:00", "updates": "2020-01-24T13:11:14+00:00", "fork": "False", "license": "licensed"}}