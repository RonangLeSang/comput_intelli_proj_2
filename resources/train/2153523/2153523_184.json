{"test_class": {"identifier": "DefaultProxyUriManagerTest", "superclass": "extends UriManagerTestBase", "interfaces": "", "fields": [{"original_string": "private static final Uri RESOURCE_1 = Uri.parse(\"http://example.com/one.dat?param=value\");", "modifier": "private static final", "type": "Uri", "declarator": "RESOURCE_1 = Uri.parse(\"http://example.com/one.dat?param=value\")", "var_name": "RESOURCE_1"}, {"original_string": "private static final Uri RESOURCE_2 = Uri.parse(\"http://gadgets.com/two.dat\");", "modifier": "private static final", "type": "Uri", "declarator": "RESOURCE_2 = Uri.parse(\"http://gadgets.com/two.dat\")", "var_name": "RESOURCE_2"}, {"original_string": "private static final Uri RESOURCE_3 = Uri.parse(\"http://foobar.com/three.dat\");", "modifier": "private static final", "type": "Uri", "declarator": "RESOURCE_3 = Uri.parse(\"http://foobar.com/three.dat\")", "var_name": "RESOURCE_3"}], "file": "java/gadgets/src/test/java/org/apache/shindig/gadgets/uri/DefaultProxyUriManagerTest.java"}, "test_case": {"identifier": "missingUrlChained", "parameters": "()", "modifiers": "@Test(expected = GadgetException.class) public", "return": "void", "body": "@Test(expected = GadgetException.class)\n  public void missingUrlChained() throws Exception {\n    String host = \"host.com\";\n    String path = \"/proxy/\" + DefaultProxyUriManager.CHAINED_PARAMS_TOKEN + \"/path\";\n    DefaultProxyUriManager manager = makeManager(host, path, null);\n    Uri testUri = new UriBuilder().setAuthority(host).setPath(\n        \"/proxy/container=\" +\n        CONTAINER + \"/path/\").toUri();\n    manager.process(testUri);\n  }", "signature": "void missingUrlChained()", "full_signature": "@Test(expected = GadgetException.class) public void missingUrlChained()", "class_method_signature": "DefaultProxyUriManagerTest.missingUrlChained()", "testcase": true, "constructor": false, "invocations": ["makeManager", "toUri", "setPath", "setAuthority", "process"]}, "focal_class": {"identifier": "DefaultProxyUriManager", "superclass": "", "interfaces": "implements ProxyUriManager", "fields": [{"original_string": "public static final String PROXY_HOST_PARAM = \"gadgets.uri.proxy.host\";", "modifier": "public static final", "type": "String", "declarator": "PROXY_HOST_PARAM = \"gadgets.uri.proxy.host\"", "var_name": "PROXY_HOST_PARAM"}, {"original_string": "public static final String PROXY_PATH_PARAM = \"gadgets.uri.proxy.path\";", "modifier": "public static final", "type": "String", "declarator": "PROXY_PATH_PARAM = \"gadgets.uri.proxy.path\"", "var_name": "PROXY_PATH_PARAM"}, {"original_string": "static final String CHAINED_PARAMS_TOKEN = \"%chained_params%\";", "modifier": "static final", "type": "String", "declarator": "CHAINED_PARAMS_TOKEN = \"%chained_params%\"", "var_name": "CHAINED_PARAMS_TOKEN"}, {"original_string": "private final ContainerConfig config;", "modifier": "private final", "type": "ContainerConfig", "declarator": "config", "var_name": "config"}, {"original_string": "private final Versioner versioner;", "modifier": "private final", "type": "Versioner", "declarator": "versioner", "var_name": "versioner"}, {"original_string": "private boolean strictParsing = false;", "modifier": "private", "type": "boolean", "declarator": "strictParsing = false", "var_name": "strictParsing"}], "methods": [{"identifier": "DefaultProxyUriManager", "parameters": "(ContainerConfig config,\n                                @Nullable Versioner versioner)", "modifiers": "@Inject public", "return": "", "signature": " DefaultProxyUriManager(ContainerConfig config,\n                                @Nullable Versioner versioner)", "full_signature": "@Inject public  DefaultProxyUriManager(ContainerConfig config,\n                                @Nullable Versioner versioner)", "class_method_signature": "DefaultProxyUriManager.DefaultProxyUriManager(ContainerConfig config,\n                                @Nullable Versioner versioner)", "testcase": false, "constructor": true}, {"identifier": "setUseStrictParsing", "parameters": "(@Named(\"shindig.uri.proxy.use-strict-parsing\") boolean useStrict)", "modifiers": "@Inject(optional = true) public", "return": "void", "signature": "void setUseStrictParsing(@Named(\"shindig.uri.proxy.use-strict-parsing\") boolean useStrict)", "full_signature": "@Inject(optional = true) public void setUseStrictParsing(@Named(\"shindig.uri.proxy.use-strict-parsing\") boolean useStrict)", "class_method_signature": "DefaultProxyUriManager.setUseStrictParsing(@Named(\"shindig.uri.proxy.use-strict-parsing\") boolean useStrict)", "testcase": false, "constructor": false}, {"identifier": "make", "parameters": "(List<ProxyUri> resources, Integer forcedRefresh)", "modifiers": "public", "return": "List<Uri>", "signature": "List<Uri> make(List<ProxyUri> resources, Integer forcedRefresh)", "full_signature": "public List<Uri> make(List<ProxyUri> resources, Integer forcedRefresh)", "class_method_signature": "DefaultProxyUriManager.make(List<ProxyUri> resources, Integer forcedRefresh)", "testcase": false, "constructor": false}, {"identifier": "makeProxiedUri", "parameters": "(ProxyUri puc, Integer forcedRefresh, String version)", "modifiers": "private", "return": "Uri", "signature": "Uri makeProxiedUri(ProxyUri puc, Integer forcedRefresh, String version)", "full_signature": "private Uri makeProxiedUri(ProxyUri puc, Integer forcedRefresh, String version)", "class_method_signature": "DefaultProxyUriManager.makeProxiedUri(ProxyUri puc, Integer forcedRefresh, String version)", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "(Uri uriIn)", "modifiers": "@SuppressWarnings(\"deprecation\") public", "return": "ProxyUri", "signature": "ProxyUri process(Uri uriIn)", "full_signature": "@SuppressWarnings(\"deprecation\") public ProxyUri process(Uri uriIn)", "class_method_signature": "DefaultProxyUriManager.process(Uri uriIn)", "testcase": false, "constructor": false}, {"identifier": "getReqConfig", "parameters": "(String container, String key)", "modifiers": "private", "return": "String", "signature": "String getReqConfig(String container, String key)", "full_signature": "private String getReqConfig(String container, String key)", "class_method_signature": "DefaultProxyUriManager.getReqConfig(String container, String key)", "testcase": false, "constructor": false}], "file": "java/gadgets/src/main/java/org/apache/shindig/gadgets/uri/DefaultProxyUriManager.java"}, "focal_method": {"identifier": "process", "parameters": "(Uri uriIn)", "modifiers": "@SuppressWarnings(\"deprecation\") public", "return": "ProxyUri", "body": "@SuppressWarnings(\"deprecation\")\n  public ProxyUri process(Uri uriIn) throws GadgetException {\n    UriStatus status = UriStatus.BAD_URI;\n    Uri uri = null;\n\n    // First determine if the URI is chained-syntax or query-style.\n    String container = uriIn.getQueryParameter(Param.CONTAINER.getKey());\n    if (container == null) {\n      container = uriIn.getQueryParameter(Param.SYND.getKey());\n    }\n    String uriStr = null;\n    Uri queryUri = null;\n    if (container != null &&\n        config.getString(container, PROXY_PATH_PARAM) != null &&\n        config.getString(container, PROXY_PATH_PARAM).equalsIgnoreCase(uriIn.getPath())) {\n      // Query-style. Has container param and path matches.\n      uriStr = uriIn.getQueryParameter(Param.URL.getKey());\n      queryUri = uriIn;\n    } else {\n      // Check for chained query string in the path.\n      String containerStr = Param.CONTAINER.getKey() + '=';\n      String path = uriIn.getPath();\n      // It is possible to get decoded url ('=' converted to %3d)\n      // for example from CssResponseRewriter, so we should support it\n      boolean doDecode = (!path.contains(containerStr));\n      if (doDecode) {\n        path = Utf8UrlCoder.decode(path);\n      }\n      int start = path.indexOf(containerStr);\n      if (start > 0) {\n        start += containerStr.length();\n        int end = path.indexOf('&', start);\n        if (end < start) {\n          end = path.indexOf('/', start);\n        }\n        if (end > start) {\n          // Looks like chained proxy syntax. Pull out params.\n          container = path.substring(start,end);\n        }\n        if (container != null) {\n          String proxyPath = config.getString(container, PROXY_PATH_PARAM);\n          if (proxyPath != null) {\n            String[] chainedChunks = StringUtils.splitByWholeSeparatorPreserveAllTokens(\n                proxyPath, CHAINED_PARAMS_TOKEN);\n\n            // Parse out the URI of the actual resource. This URI is found as the\n            // substring of the \"full\" URI, after the chained proxy prefix. We\n            // first search for the pre- and post-fixes of the original /pre/%chained_params%/post\n            // ContainerConfig value, and take the URI as everything beyond that point.\n            String startToken = chainedChunks[0];\n            String endToken = \"/\";\n            if (chainedChunks.length == 2 && chainedChunks[1].length() > 0) {\n              endToken = chainedChunks[1];\n            }\n\n            // Pull URI out of original inUri's full representation.\n            String fullProxyUri = uriIn.toString();\n            int startIx = fullProxyUri.indexOf(startToken) + startToken.length();\n            int endIx = fullProxyUri.indexOf(endToken, startIx);\n            if (startIx > 0 && endIx > 0) {\n              String chainedQuery = fullProxyUri.substring(startIx, endIx);\n              if (doDecode) {\n                chainedQuery = Utf8UrlCoder.decode(chainedQuery);\n              }\n              queryUri = new UriBuilder().setQuery(chainedQuery).toUri();\n              uriStr = fullProxyUri.substring(endIx + endToken.length());\n              while (uriStr.startsWith(\"/\")) {\n                uriStr = uriStr.substring(1);\n              }\n\n            }\n          }\n        }\n      }\n    }\n\n    if (!strictParsing && container != null && StringUtils.isEmpty(uriStr)) {\n      // Query-style despite the container being configured for chained style.\n      uriStr = uriIn.getQueryParameter(Param.URL.getKey());\n      queryUri = uriIn;\n    }\n\n    // Parameter validation.\n    if (StringUtils.isEmpty(uriStr) || StringUtils.isEmpty(container)) {\n      throw new GadgetException(GadgetException.Code.MISSING_PARAMETER,\n          \"Missing required parameter(s):\" +\n          (StringUtils.isEmpty(uriStr) ? ' ' + Param.URL.getKey() : \"\") +\n          (StringUtils.isEmpty(container) ? ' ' + Param.CONTAINER.getKey() : \"\"),\n          HttpResponse.SC_BAD_REQUEST);\n    }\n\n    String queryHost = config.getString(container, PROXY_HOST_PARAM);\n    if (strictParsing) {\n      if (queryHost == null || !queryHost.equalsIgnoreCase(uriIn.getAuthority())) {\n        throw new GadgetException(GadgetException.Code.INVALID_PATH, \"Invalid proxy host\",\n            HttpResponse.SC_BAD_REQUEST);\n      }\n    }\n\n    try {\n      uri = Uri.parse(uriStr);\n    } catch (Exception e) {\n      // NullPointerException or InvalidArgumentException.\n      throw new GadgetException(GadgetException.Code.INVALID_PARAMETER,\n          \"Invalid \" + Param.URL.getKey() + \": \" + uriStr, HttpResponse.SC_BAD_REQUEST);\n    }\n\n    // URI is valid.\n    status = UriStatus.VALID_UNVERSIONED;\n\n    String version = queryUri.getQueryParameter(Param.VERSION.getKey());\n    if (versioner != null && version != null) {\n      status = versioner.validate(uri, container, version);\n    }\n\n    ProxyUri proxied = new ProxyUri(status, uri, queryUri);\n    proxied.setHtmlTagContext(uriIn.getQueryParameter(Param.HTML_TAG_CONTEXT.getKey()));\n    return proxied;\n  }", "signature": "ProxyUri process(Uri uriIn)", "full_signature": "@SuppressWarnings(\"deprecation\") public ProxyUri process(Uri uriIn)", "class_method_signature": "DefaultProxyUriManager.process(Uri uriIn)", "testcase": false, "constructor": false, "invocations": ["getQueryParameter", "getKey", "getQueryParameter", "getKey", "getString", "equalsIgnoreCase", "getString", "getPath", "getQueryParameter", "getKey", "getKey", "getPath", "contains", "decode", "indexOf", "length", "indexOf", "indexOf", "substring", "getString", "splitByWholeSeparatorPreserveAllTokens", "length", "toString", "indexOf", "length", "indexOf", "substring", "decode", "toUri", "setQuery", "substring", "length", "startsWith", "substring", "isEmpty", "getQueryParameter", "getKey", "isEmpty", "isEmpty", "isEmpty", "getKey", "isEmpty", "getKey", "getString", "equalsIgnoreCase", "getAuthority", "parse", "getKey", "getQueryParameter", "getKey", "validate", "setHtmlTagContext", "getQueryParameter", "getKey"]}, "repository": {"repo_id": 2153523, "url": "https://github.com/gatein/gatein-shindig", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 6, "size": 3564, "license": "licensed"}}