{"test_class": {"identifier": "PlanMigratorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(PlanMigratorTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(PlanMigratorTest.class)", "var_name": "log"}, {"original_string": "private File tempDir;", "modifier": "private", "type": "File", "declarator": "tempDir", "var_name": "tempDir"}, {"original_string": "private String tempPath;", "modifier": "private", "type": "String", "declarator": "tempPath", "var_name": "tempPath"}], "file": "planning-core/src/test/java/eu/scape_project/planning/xml/PlanMigratorTest.java"}, "test_case": {"identifier": "migrateDirectory", "parameters": "()", "modifiers": "@Test @Ignore public", "return": "void", "body": "@Test\n    @Ignore\n    public void migrateDirectory() throws PlatoException, FileNotFoundException{\n        PlanMigrator migrator = new PlanMigrator();\n        \n        File dir = new File(\"/home/kraxner/Documents/SCAPE/plan-problems\");\n        \n        File plans[] = dir.listFiles();\n        for (File plan : plans) {\n            if (plan.isFile() && plan.getName().endsWith(\".xml\")) {\n                String tempPath = dir.getAbsolutePath() + File.separator + plan.getName().substring(0, plan.getName().length()-4) + File.separator;\n                File tempDir = new File(tempPath);\n                tempDir.mkdirs();\n\n                List<String> appliedTransformations = new ArrayList<String>();\n                String currentVersionData;\n                try {\n                    currentVersionData = migrator.getCurrentVersionData(new FileInputStream(plan), tempPath, appliedTransformations);\n                    File migratedFile = new File(currentVersionData);\n                    File outFile = new File(\"d://plans//out//\" + migratedFile.getName());\n                    if (!migratedFile.renameTo(outFile)) {\n                        log.error(\"Failed to move file : \" + currentVersionData);\n                    }\n                } catch (Exception e) {\n                    log.error(\"failed to migrate file: \" + plan.getName(), e);\n                }\n            }\n        }\n        \n    }", "signature": "void migrateDirectory()", "full_signature": "@Test @Ignore public void migrateDirectory()", "class_method_signature": "PlanMigratorTest.migrateDirectory()", "testcase": true, "constructor": false, "invocations": ["listFiles", "isFile", "endsWith", "getName", "getAbsolutePath", "substring", "getName", "length", "getName", "mkdirs", "getCurrentVersionData", "getName", "renameTo", "error", "error", "getName"]}, "focal_class": {"identifier": "PlanMigrator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(PlanMigrator.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(PlanMigrator.class)", "var_name": "log"}, {"original_string": "private String fileVersion;", "modifier": "private", "type": "String", "declarator": "fileVersion", "var_name": "fileVersion"}], "methods": [{"identifier": "getCurrentVersionData", "parameters": "(final InputStream in, final String tempPath, final List<String> appliedTransformations)", "modifiers": "public", "return": "String", "signature": "String getCurrentVersionData(final InputStream in, final String tempPath, final List<String> appliedTransformations)", "full_signature": "public String getCurrentVersionData(final InputStream in, final String tempPath, final List<String> appliedTransformations)", "class_method_signature": "PlanMigrator.getCurrentVersionData(final InputStream in, final String tempPath, final List<String> appliedTransformations)", "testcase": false, "constructor": false}, {"identifier": "transformXmlData", "parameters": "(final String fromFile, final String toFile, final String xslFile)", "modifiers": "public", "return": "boolean", "signature": "boolean transformXmlData(final String fromFile, final String toFile, final String xslFile)", "full_signature": "public boolean transformXmlData(final String fromFile, final String toFile, final String xslFile)", "class_method_signature": "PlanMigrator.transformXmlData(final String fromFile, final String toFile, final String xslFile)", "testcase": false, "constructor": false}, {"identifier": "setFileVersion", "parameters": "(final String fileVersion)", "modifiers": "public", "return": "void", "signature": "void setFileVersion(final String fileVersion)", "full_signature": "public void setFileVersion(final String fileVersion)", "class_method_signature": "PlanMigrator.setFileVersion(final String fileVersion)", "testcase": false, "constructor": false}], "file": "planning-core/src/main/java/eu/scape_project/planning/xml/PlanMigrator.java"}, "focal_method": {"identifier": "getCurrentVersionData", "parameters": "(final InputStream in, final String tempPath, final List<String> appliedTransformations)", "modifiers": "public", "return": "String", "body": "public String getCurrentVersionData(final InputStream in, final String tempPath, final List<String> appliedTransformations) throws PlatoException {\n        String originalFile = tempPath + \"_original.xml\";\n        try {\n            FileUtils.writeToFile(in, new FileOutputStream(originalFile));\n\n            /** check for the version of the file **/\n\n            // The version of the read xml file is unknown, so it is not possible to\n            // validate it\n            // moreover, in old plans the version attribute was on different\n            // nodes(project, projects),\n            // with a different name (fileVersion)\n            // to be backwards compatible we create rules for all these attributes\n            fileVersion = \"xxx\";\n            SAXParserFactory factory = SAXParserFactory.newInstance();\n            factory.setNamespaceAware(false);\n            Digester d = new Digester(factory.newSAXParser());\n            \n            d.setValidating(false);\n            // StrictErrorHandler errorHandler = new StrictErrorHandler();\n            // d.setErrorHandler(errorHandler);\n            d.push(this);\n            // to read the version we have to support all versions:\n            d.addSetProperties(\"*/projects\", \"version\", \"fileVersion\");\n            // manually migrated projects may have the file version in the node\n            // projects/project\n            d.addSetProperties(\"*/projects/project\", \"version\", \"fileVersion\");\n            // pre V1.3 version info was stored in the project node\n            d.addSetProperties(\"*/project\", \"version\", \"fileVersion\");\n            // since V1.9 the root node is plans:\n            d.addSetProperties(\"plans\", \"version\", \"fileVersion\");\n\n            InputStream inV = new FileInputStream(originalFile);\n            d.parse(inV);\n            inV.close();\n            /** this could be more sophisticated, but for now this is enough **/\n            String version = \"1.0\";\n            if (fileVersion != null) {\n                version = fileVersion;\n            }\n\n            String fileTo = originalFile;\n            String fileFrom = originalFile;\n\n            boolean success = true;\n            if (\"xxx\".equals(version)) {\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V1.3.xml\";\n                /** this is an old export file, transform it to the 1.3 schema **/\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/Vxxx-to-V1.3.xsl\");\n                appliedTransformations.add(\"Vxxx-to-V1.3.xsl\");\n                version = \"1.3\";\n            }\n            if (success && \"1.3\".equals(version)) {\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V1.9.xml\";\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/V1.3-to-V1.9.xsl\");\n                appliedTransformations.add(\"V1.3-to-V1.9.xsl\");\n                version = \"1.9\";\n            }\n            // with release of Plato 2.0 and its schema ProjectExporter creates\n            // documents with version 2.0\n            if (success && \"1.9\".equals(version)) {\n                version = \"2.0\";\n            }\n            if (success && \"2.0\".equals(version)) {\n                // transform the document to version 2.1\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V2.1.xml\";\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/V2.0-to-V2.1.xsl\");\n                appliedTransformations.add(\"V2.0-to-V2.1.xsl\");\n                version = \"2.1\";\n            }\n            if (success && \"2.1\".equals(version)) {\n                // transform the document to version 2.1.2\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V2.1.2.xml\";\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/V2.1-to-V2.1.2.xsl\");\n                appliedTransformations.add(\"V2.1-to-V2.1.2.xsl\");\n                version = \"2.1.2\";\n            }\n            if (success && \"2.1.1\".equals(version)) {\n                // transform the document to version 2.1.2\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V2.1.2.xml\";\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/V2.1.1-to-V2.1.2.xsl\");\n                appliedTransformations.add(\"V2.1.1-to-V2.1.2.xsl\");\n                version = \"2.1.2\";\n            }\n\n            if (success && \"2.1.2\".equals(version)) {\n                // transform the document to version 3.0.0\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V3.0.0.xml\";\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/V2.1.2-to-V3.0.0.xsl\");\n                appliedTransformations.add(\"V2.1.2-to-V3.0.0.xsl\");\n                version = \"3.0.0\";\n            }\n            if (success && \"3.0.0\".equals(version)) {\n                // transform the document to version 3.0.1\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V3.0.1.xml\";\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/V3.0.0-to-V3.0.1.xsl\");\n                appliedTransformations.add(\"V3.0.0-to-V3.0.1.xsl\");\n                version = \"3.0.1\";\n            }\n            if (success && \"3.0.1\".equals(version)) {\n                // transform the document to version 3.9.0\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V3.9.0.xml\";\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/V3.0.1-to-V3.9.0.xsl\");\n                appliedTransformations.add(\"V3.0.1-to-V3.9.0.xsl\");\n                version = \"3.9.0\";\n            }\n            if (success && \"3.9.0\".equals(version)) {\n                // transform the document to version 3.9.9\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V3.9.9.xml\";\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/V3.9.0-to-V3.9.9.xsl\");\n                appliedTransformations.add(\"V3.9.0-to-V3.9.9.xsl\");\n                version = \"3.9.9\";\n            }\n            if (success && \"3.9.9\".equals(version)) {\n                // transform the document to version 4.0.0\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V4.0.1.xml\";\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/V3.9.9-to-V4.0.1.xsl\");\n                appliedTransformations.add(\"V3.9.9-to-V4.0.1.xsl\");\n                version = \"4.0.1\";\n            }\n            if (success && \"4.0.1\".equals(version)) {\n                // transform the document to version 4.0.0\n                fileFrom = fileTo;\n                fileTo = fileFrom + \"_V4.0.2.xml\";\n                success = transformXmlData(fileFrom, fileTo, \"data/xslt/V4.0.1-to-V4.0.2.xsl\");\n                appliedTransformations.add(\"V4.0.1-to-V4.0.2.xsl\");\n                version = \"4.0.2\";\n            }\n\n            if (success) {\n                return fileTo;\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            throw new PlatoException(\"Failed to update plan to current version.\", e);\n        }\n    }", "signature": "String getCurrentVersionData(final InputStream in, final String tempPath, final List<String> appliedTransformations)", "full_signature": "public String getCurrentVersionData(final InputStream in, final String tempPath, final List<String> appliedTransformations)", "class_method_signature": "PlanMigrator.getCurrentVersionData(final InputStream in, final String tempPath, final List<String> appliedTransformations)", "testcase": false, "constructor": false, "invocations": ["writeToFile", "newInstance", "setNamespaceAware", "newSAXParser", "setValidating", "push", "addSetProperties", "addSetProperties", "addSetProperties", "addSetProperties", "parse", "close", "equals", "transformXmlData", "add", "equals", "transformXmlData", "add", "equals", "equals", "transformXmlData", "add", "equals", "transformXmlData", "add", "equals", "transformXmlData", "add", "equals", "transformXmlData", "add", "equals", "transformXmlData", "add", "equals", "transformXmlData", "add", "equals", "transformXmlData", "add", "equals", "transformXmlData", "add", "equals", "transformXmlData", "add"]}, "repository": {"repo_id": 4406463, "url": "https://github.com/openpreserve/plato", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 8, "size": 66861, "license": "licensed"}}