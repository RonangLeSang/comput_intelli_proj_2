{"test_class": {"identifier": "BruteForceCompoundNounRootFinderTest", "superclass": "extends BaseRootFinderTest<DynamicRoot>", "interfaces": "", "fields": [], "file": "core/src/test/java/org/trnltk/morphology/contextless/rootfinder/BruteForceCompoundNounRootFinderTest.java"}, "test_case": {"identifier": "should_create_roots_with_consontant_insertion_s", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void should_create_roots_with_consontant_insertion_s() {\n        // most of the following words are made up!\n        {\n            final List<DynamicRoot> roots = findRootsForPartialInput(\"suborusu\", \"suborusuna\");\n            assertThat(roots, hasSize(2));\n            assertThat(roots.get(0).getSequence().getUnderlyingString(), equalTo(\"suborus\"));\n            assertThat(roots.get(0).getLexeme().getLemmaRoot(), equalTo(\"suborusu\"));\n            assertThat(roots.get(0).getLexeme().getLemma(), equalTo(\"suborusu\"));\n            assertThat(roots.get(0).getLexeme().getPrimaryPos(), equalTo(PrimaryPos.Noun));\n            assertThat(roots.get(0).getLexeme().getAttributes(), equalTo((Set<LexemeAttribute>) ImmutableSet.of(LexemeAttribute.CompoundP3sg)));\n            assertThat(roots.get(1).getSequence().getUnderlyingString(), equalTo(\"suboru\"));\n            assertThat(roots.get(1).getLexeme().getLemmaRoot(), equalTo(\"suborusu\"));\n            assertThat(roots.get(1).getLexeme().getLemma(), equalTo(\"suborusu\"));\n            assertThat(roots.get(1).getLexeme().getPrimaryPos(), equalTo(PrimaryPos.Noun));\n            assertThat(roots.get(1).getLexeme().getAttributes(), equalTo((Set<LexemeAttribute>) ImmutableSet.of(LexemeAttribute.CompoundP3sg)));\n        }\n        // InverseHarmony and consonant 's' doesn't work together.\n        // Compound gets the 's' if it ends with a vowel.\n        // However, a word ending with a vowel cannot have InverseHarmony.\n        // Thus, this is an invalid case!\n        //}{final List<DynamicRoot> roots = findRootsForPartialInput(\"abcdes\u0131\", \"abcdes\u0131na\");\n        //assertThat(roots, hasSize(2));\n        //assertThat(roots.get(0).getSequence().getUnderlyingString(), equalTo(\"abcdes\"));\n        //assertThat(roots.get(0).getLexeme().getLemmaRoot(), equalTo(\"abcdes\u0131\"));\n        //assertThat(roots.get(0).getLexeme().getLemma(), equalTo(\"abcdes\u0131\"));\n        //assertThat(roots.get(0).getLexeme().getPrimaryPos(), equalTo(PrimaryPos.Noun));\n        //assertThat(roots.get(0).getLexeme().getAttributes(), equalTo((Set<LexemeAttribute>) ImmutableSet.of(LexemeAttribute.CompoundP3sg, LexemeAttribute.InverseHarmony)));\n        //assertThat(roots.get(1).getSequence().getUnderlyingString(), equalTo(\"abcde\"));\n        //assertThat(roots.get(1).getLexeme().getLemmaRoot(), equalTo(\"abcdes\u0131\"));\n        //assertThat(roots.get(1).getLexeme().getLemma(), equalTo(\"abcdes\u0131\"));\n        //assertThat(roots.get(1).getLexeme().getPrimaryPos(), equalTo(PrimaryPos.Noun));\n        //assertThat(roots.get(1).getLexeme().getAttributes(), equalTo((Set<LexemeAttribute>) ImmutableSet.of(LexemeAttribute.CompoundP3sg, LexemeAttribute.InverseHarmony}))\n        //}\n    }", "signature": "void should_create_roots_with_consontant_insertion_s()", "full_signature": "@Test public void should_create_roots_with_consontant_insertion_s()", "class_method_signature": "BruteForceCompoundNounRootFinderTest.should_create_roots_with_consontant_insertion_s()", "testcase": true, "constructor": false, "invocations": ["findRootsForPartialInput", "assertThat", "hasSize", "assertThat", "getUnderlyingString", "getSequence", "get", "equalTo", "assertThat", "getLemmaRoot", "getLexeme", "get", "equalTo", "assertThat", "getLemma", "getLexeme", "get", "equalTo", "assertThat", "getPrimaryPos", "getLexeme", "get", "equalTo", "assertThat", "getAttributes", "getLexeme", "get", "equalTo", "of", "assertThat", "getUnderlyingString", "getSequence", "get", "equalTo", "assertThat", "getLemmaRoot", "getLexeme", "get", "equalTo", "assertThat", "getLemma", "getLexeme", "get", "equalTo", "assertThat", "getPrimaryPos", "getLexeme", "get", "equalTo", "assertThat", "getAttributes", "getLexeme", "get", "equalTo", "of"]}, "focal_class": {"identifier": "BruteForceCompoundNounRootFinder", "superclass": "", "interfaces": "implements RootFinder", "fields": [{"original_string": "private final BruteForceNounRootFinder bruteForceNounRootFinder = new BruteForceNounRootFinder();", "modifier": "private final", "type": "BruteForceNounRootFinder", "declarator": "bruteForceNounRootFinder = new BruteForceNounRootFinder()", "var_name": "bruteForceNounRootFinder"}], "methods": [{"identifier": "handles", "parameters": "(TurkishSequence partialInput, TurkishSequence wholeSurface)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean handles(TurkishSequence partialInput, TurkishSequence wholeSurface)", "full_signature": "@Override public boolean handles(TurkishSequence partialInput, TurkishSequence wholeSurface)", "class_method_signature": "BruteForceCompoundNounRootFinder.handles(TurkishSequence partialInput, TurkishSequence wholeSurface)", "testcase": false, "constructor": false}, {"identifier": "findRootsForPartialInput", "parameters": "(TurkishSequence partialInput, TurkishSequence wholeSurface)", "modifiers": "@Override public", "return": "Collection<DynamicRoot>", "signature": "Collection<DynamicRoot> findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "full_signature": "@Override public Collection<DynamicRoot> findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "class_method_signature": "BruteForceCompoundNounRootFinder.findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/trnltk/morphology/contextless/rootfinder/BruteForceCompoundNounRootFinder.java"}, "focal_method": {"identifier": "findRootsForPartialInput", "parameters": "(TurkishSequence partialInput, TurkishSequence wholeSurface)", "modifiers": "@Override public", "return": "Collection<DynamicRoot>", "body": "@Override\n    public Collection<DynamicRoot> findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface) {\n\n        final TurkishChar previousChar = partialInput.charAt(partialInput.length() - 2);\n\n        final List<DynamicRoot> compoundResults = new ArrayList<DynamicRoot>();\n\n        final Collection<DynamicRoot> resultsWithPartialInputOneCharMissing =\n                this.bruteForceNounRootFinder.findRootsForPartialInput(partialInput.subsequence(0, partialInput.length() - 1), wholeSurface);\n\n\n        // illustrate:\n        // partial_input = suborusu, whole_surface = suborusuna\n        // results_with_partial_input_one_char_missing : <'suborus','suborus'>\n        // partial_input = bacakkalemi, whole_surface = bacakkalemini\n        // results_with_partial_input_one_char_missing : <'bacakkalem','bacakkalem'>\n        // partial_input = atkuyrugu, whole_surface=atkuyruguna\n        // results_with_partial_input_one_char_missing : <'atkuyruk', 'atkuyrug', 'atkuyrugh'>\n\n        // these are all roots of noun compound. so the lexeme can be derived from any of\n        // atkuyruk+u, atkuyrug+u, atkuyrugh+u\n\n        for (DynamicRoot normalNounResult : resultsWithPartialInputOneCharMissing) {\n            final DynamicRoot cloneResult = new DynamicRoot(normalNounResult);\n            cloneResult.setSequence(new TurkishSequence(cloneResult.getLexeme().getLemmaRoot()));\n            cloneResult.getLexeme().setLemmaRoot(partialInput.getUnderlyingString());\n            cloneResult.getLexeme().setLemma(partialInput.getUnderlyingString());\n\n            compoundResults.add(cloneResult);\n        }\n\n        final TurkicLetter previousLetter = previousChar.getLetter();\n\n        if (previousLetter.equals(TurkishAlphabet.L_s)) {\n            final Collection<DynamicRoot> resultsWithPartialInputTwoCharMissing =\n                    this.bruteForceNounRootFinder.findRootsForPartialInput(partialInput.subsequence(0, partialInput.length() - 2), wholeSurface);\n\n            // illustrate:\n            // partial_input = suborusu, whole_surface = suborusuna\n            // results_with_partial_input_two_chars_missing : <'suboru','suboru'>\n\n            for (DynamicRoot normalNounResult : resultsWithPartialInputTwoCharMissing) {\n                final DynamicRoot cloneResult = new DynamicRoot(normalNounResult);\n                cloneResult.getLexeme().setLemmaRoot(partialInput.getUnderlyingString());\n                cloneResult.getLexeme().setLemma(partialInput.getUnderlyingString());\n\n                compoundResults.add(cloneResult);\n            }\n        }\n\n        for (DynamicRoot compoundResult : compoundResults) {\n            compoundResult.getLexeme().getAttributes().add(LexemeAttribute.CompoundP3sg);\n        }\n\n        return compoundResults;\n    }", "signature": "Collection<DynamicRoot> findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "full_signature": "@Override public Collection<DynamicRoot> findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "class_method_signature": "BruteForceCompoundNounRootFinder.findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "testcase": false, "constructor": false, "invocations": ["charAt", "length", "findRootsForPartialInput", "subsequence", "length", "setSequence", "getLemmaRoot", "getLexeme", "setLemmaRoot", "getLexeme", "getUnderlyingString", "setLemma", "getLexeme", "getUnderlyingString", "add", "getLetter", "equals", "findRootsForPartialInput", "subsequence", "length", "setLemmaRoot", "getLexeme", "getUnderlyingString", "setLemma", "getLexeme", "getUnderlyingString", "add", "add", "getAttributes", "getLexeme"]}, "repository": {"repo_id": 7321072, "url": "https://github.com/aliok/trnltk-java", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 39, "size": 3428, "license": "licensed"}}