{"test_class": {"identifier": "BruteForceVerbRootFinderTest", "superclass": "extends BaseRootFinderTest<DynamicRoot>", "interfaces": "", "fields": [{"original_string": "private static final Comparator<? super Root> ROOT_COMPARATOR_BY_LEXEME = new Comparator<Root>() {\n        @Override\n        public int compare(Root o1, Root o2) {\n\n            // first try comparing with the lemma\n            // then lexemeAttributes\n\n            final String o1Lemma = o1.getLexeme().getLemma();\n            final String o2Lemma = o2.getLexeme().getLemma();\n\n            final int lemmaCompare = o1Lemma.compareTo(o2Lemma);\n            if (lemmaCompare != 0)\n                return lemmaCompare;\n\n            final Set<LexemeAttribute> o1Attrs = o1.getLexeme().getAttributes();\n            final Set<LexemeAttribute> o2Attrs = o2.getLexeme().getAttributes();\n\n            final int lexemeAttrsCompare = Ordering.natural().compare(o1Attrs.size(), o2Attrs.size());\n            if (lexemeAttrsCompare == 0) {\n                final ArrayList<LexemeAttribute> o1AttrsList = new ArrayList<LexemeAttribute>(o1Attrs);\n                final ArrayList<LexemeAttribute> o2AttrsList = new ArrayList<LexemeAttribute>(o2Attrs);\n                Collections.sort(o1AttrsList);\n                Collections.sort(o2AttrsList);\n                final Iterator<LexemeAttribute> o1Iterator = o1AttrsList.iterator();\n                final Iterator<LexemeAttribute> o2Iterator = o2AttrsList.iterator();\n                while (true) {\n                    if (!o1Iterator.hasNext() && !o2Iterator.hasNext())\n                        return 0;\n                    final LexemeAttribute o1Attr = o1Iterator.next();\n                    final LexemeAttribute o2Attr = o2Iterator.next();\n\n                    final int attrCompare = o1Attr.name().compareTo(o2Attr.name());\n                    if (attrCompare == 0)\n                        continue;\n                    else\n                        return attrCompare;\n\n                }\n            }\n            return lexemeAttrsCompare;\n        }\n    };", "modifier": "private static final", "type": "Comparator<? super Root>", "declarator": "ROOT_COMPARATOR_BY_LEXEME = new Comparator<Root>() {\n        @Override\n        public int compare(Root o1, Root o2) {\n\n            // first try comparing with the lemma\n            // then lexemeAttributes\n\n            final String o1Lemma = o1.getLexeme().getLemma();\n            final String o2Lemma = o2.getLexeme().getLemma();\n\n            final int lemmaCompare = o1Lemma.compareTo(o2Lemma);\n            if (lemmaCompare != 0)\n                return lemmaCompare;\n\n            final Set<LexemeAttribute> o1Attrs = o1.getLexeme().getAttributes();\n            final Set<LexemeAttribute> o2Attrs = o2.getLexeme().getAttributes();\n\n            final int lexemeAttrsCompare = Ordering.natural().compare(o1Attrs.size(), o2Attrs.size());\n            if (lexemeAttrsCompare == 0) {\n                final ArrayList<LexemeAttribute> o1AttrsList = new ArrayList<LexemeAttribute>(o1Attrs);\n                final ArrayList<LexemeAttribute> o2AttrsList = new ArrayList<LexemeAttribute>(o2Attrs);\n                Collections.sort(o1AttrsList);\n                Collections.sort(o2AttrsList);\n                final Iterator<LexemeAttribute> o1Iterator = o1AttrsList.iterator();\n                final Iterator<LexemeAttribute> o2Iterator = o2AttrsList.iterator();\n                while (true) {\n                    if (!o1Iterator.hasNext() && !o2Iterator.hasNext())\n                        return 0;\n                    final LexemeAttribute o1Attr = o1Iterator.next();\n                    final LexemeAttribute o2Attr = o2Iterator.next();\n\n                    final int attrCompare = o1Attr.name().compareTo(o2Attr.name());\n                    if (attrCompare == 0)\n                        continue;\n                    else\n                        return attrCompare;\n\n                }\n            }\n            return lexemeAttrsCompare;\n        }\n    }", "var_name": "ROOT_COMPARATOR_BY_LEXEME"}], "file": "core/src/test/java/org/trnltk/morphology/contextless/rootfinder/BruteForceVerbRootFinderTest.java"}, "test_case": {"identifier": "should_create_roots_with_passive_In", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void should_create_roots_with_passive_In() {\n        {\n            final List<DynamicRoot> roots = findRootsForPartialInput(\"al\", \"al\u0131nd\u0131\");\n            assertThat(roots, hasSize(2));\n            assertThat(roots.get(0).getSequence().getUnderlyingString(), equalTo(\"al\"));\n            assertThat(roots.get(0).getLexeme().getLemmaRoot(), equalTo(\"al\"));\n            assertThat(roots.get(0).getLexeme().getLemma(), equalTo(\"almak\"));\n            assertThat(roots.get(0).getLexeme().getPrimaryPos(), equalTo(PrimaryPos.Verb));\n            assertThat(roots.get(0).getLexeme().getAttributes(), equalTo((Set<LexemeAttribute>) ImmutableSet.of(LexemeAttribute.NoVoicing)));\n            assertThat(roots.get(1).getSequence().getUnderlyingString(), equalTo(\"al\"));\n            assertThat(roots.get(1).getLexeme().getLemmaRoot(), equalTo(\"al\"));\n            assertThat(roots.get(1).getLexeme().getLemma(), equalTo(\"almak\"));\n            assertThat(roots.get(1).getLexeme().getPrimaryPos(), equalTo(PrimaryPos.Verb));\n            assertThat(roots.get(1).getLexeme().getAttributes(), equalTo((Set<LexemeAttribute>) ImmutableSet.of(LexemeAttribute.NoVoicing, LexemeAttribute.Passive_In)));\n        }\n        {\n            final List<DynamicRoot> roots = findRootsForPartialInput(\"tekmele\", \"tekmelendim\");\n            assertThat(roots, hasSize(2));\n            assertThat(roots.get(0).getSequence().getUnderlyingString(), equalTo(\"tekmele\"));\n            assertThat(roots.get(0).getLexeme().getLemmaRoot(), equalTo(\"tekmele\"));\n            assertThat(roots.get(0).getLexeme().getLemma(), equalTo(\"tekmelemek\"));\n            assertThat(roots.get(0).getLexeme().getPrimaryPos(), equalTo(PrimaryPos.Verb));\n            assertThat(roots.get(0).getLexeme().getAttributes(), equalTo((Set<LexemeAttribute>) ImmutableSet.of(LexemeAttribute.NoVoicing)));\n            assertThat(roots.get(1).getSequence().getUnderlyingString(), equalTo(\"tekmele\"));\n            assertThat(roots.get(1).getLexeme().getLemmaRoot(), equalTo(\"tekmele\"));\n            assertThat(roots.get(1).getLexeme().getLemma(), equalTo(\"tekmelemek\"));\n            assertThat(roots.get(1).getLexeme().getPrimaryPos(), equalTo(PrimaryPos.Verb));\n            assertThat(roots.get(1).getLexeme().getAttributes(), equalTo((Set<LexemeAttribute>) ImmutableSet.of(LexemeAttribute.NoVoicing, LexemeAttribute.Passive_In)));\n        }\n    }", "signature": "void should_create_roots_with_passive_In()", "full_signature": "@Test public void should_create_roots_with_passive_In()", "class_method_signature": "BruteForceVerbRootFinderTest.should_create_roots_with_passive_In()", "testcase": true, "constructor": false, "invocations": ["findRootsForPartialInput", "assertThat", "hasSize", "assertThat", "getUnderlyingString", "getSequence", "get", "equalTo", "assertThat", "getLemmaRoot", "getLexeme", "get", "equalTo", "assertThat", "getLemma", "getLexeme", "get", "equalTo", "assertThat", "getPrimaryPos", "getLexeme", "get", "equalTo", "assertThat", "getAttributes", "getLexeme", "get", "equalTo", "of", "assertThat", "getUnderlyingString", "getSequence", "get", "equalTo", "assertThat", "getLemmaRoot", "getLexeme", "get", "equalTo", "assertThat", "getLemma", "getLexeme", "get", "equalTo", "assertThat", "getPrimaryPos", "getLexeme", "get", "equalTo", "assertThat", "getAttributes", "getLexeme", "get", "equalTo", "of", "findRootsForPartialInput", "assertThat", "hasSize", "assertThat", "getUnderlyingString", "getSequence", "get", "equalTo", "assertThat", "getLemmaRoot", "getLexeme", "get", "equalTo", "assertThat", "getLemma", "getLexeme", "get", "equalTo", "assertThat", "getPrimaryPos", "getLexeme", "get", "equalTo", "assertThat", "getAttributes", "getLexeme", "get", "equalTo", "of", "assertThat", "getUnderlyingString", "getSequence", "get", "equalTo", "assertThat", "getLemmaRoot", "getLexeme", "get", "equalTo", "assertThat", "getLemma", "getLexeme", "get", "equalTo", "assertThat", "getPrimaryPos", "getLexeme", "get", "equalTo", "assertThat", "getAttributes", "getLexeme", "get", "equalTo", "of"]}, "focal_class": {"identifier": "BruteForceVerbRootFinder", "superclass": "", "interfaces": "implements RootFinder", "fields": [{"original_string": "private final PhoneticsEngine phoneticsEngine = new PhoneticsEngine(new SuffixFormSequenceApplier());", "modifier": "private final", "type": "PhoneticsEngine", "declarator": "phoneticsEngine = new PhoneticsEngine(new SuffixFormSequenceApplier())", "var_name": "phoneticsEngine"}, {"original_string": "private final PhoneticsAnalyzer phoneticsAnalyzer = new PhoneticsAnalyzer();", "modifier": "private final", "type": "PhoneticsAnalyzer", "declarator": "phoneticsAnalyzer = new PhoneticsAnalyzer()", "var_name": "phoneticsAnalyzer"}, {"original_string": "private static final SuffixFormSequence INFINITIVE_SUFFIX_FORM = new SuffixFormSequence(\"mAk\");", "modifier": "private static final", "type": "SuffixFormSequence", "declarator": "INFINITIVE_SUFFIX_FORM = new SuffixFormSequence(\"mAk\")", "var_name": "INFINITIVE_SUFFIX_FORM"}], "methods": [{"identifier": "handles", "parameters": "(TurkishSequence partialInput, TurkishSequence wholeSurface)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean handles(TurkishSequence partialInput, TurkishSequence wholeSurface)", "full_signature": "@Override public boolean handles(TurkishSequence partialInput, TurkishSequence wholeSurface)", "class_method_signature": "BruteForceVerbRootFinder.handles(TurkishSequence partialInput, TurkishSequence wholeSurface)", "testcase": false, "constructor": false}, {"identifier": "findRootsForPartialInput", "parameters": "(TurkishSequence partialInput, TurkishSequence wholeSurface)", "modifiers": "@Override @SuppressWarnings({\"UnnecessaryLocalVariable\", \"ConstantConditions\"}) public", "return": "Collection<DynamicRoot>", "signature": "Collection<DynamicRoot> findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "full_signature": "@Override @SuppressWarnings({\"UnnecessaryLocalVariable\", \"ConstantConditions\"}) public Collection<DynamicRoot> findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "class_method_signature": "BruteForceVerbRootFinder.findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "testcase": false, "constructor": false}, {"identifier": "setLexemeAndPhoneticAttributes", "parameters": "(Collection<DynamicRoot> generatedRoots)", "modifiers": "private", "return": "void", "signature": "void setLexemeAndPhoneticAttributes(Collection<DynamicRoot> generatedRoots)", "full_signature": "private void setLexemeAndPhoneticAttributes(Collection<DynamicRoot> generatedRoots)", "class_method_signature": "BruteForceVerbRootFinder.setLexemeAndPhoneticAttributes(Collection<DynamicRoot> generatedRoots)", "testcase": false, "constructor": false}, {"identifier": "setLemma", "parameters": "(Collection<DynamicRoot> generatedRoots)", "modifiers": "private", "return": "void", "signature": "void setLemma(Collection<DynamicRoot> generatedRoots)", "full_signature": "private void setLemma(Collection<DynamicRoot> generatedRoots)", "class_method_signature": "BruteForceVerbRootFinder.setLemma(Collection<DynamicRoot> generatedRoots)", "testcase": false, "constructor": false}, {"identifier": "seemsLikeAValidVerbRoot", "parameters": "(TurkishSequence partialInput)", "modifiers": "private", "return": "boolean", "signature": "boolean seemsLikeAValidVerbRoot(TurkishSequence partialInput)", "full_signature": "private boolean seemsLikeAValidVerbRoot(TurkishSequence partialInput)", "class_method_signature": "BruteForceVerbRootFinder.seemsLikeAValidVerbRoot(TurkishSequence partialInput)", "testcase": false, "constructor": false}, {"identifier": "getProgressiveDropRoots", "parameters": "(DynamicRoot noAttrRoot, TurkishChar lastVowel)", "modifiers": "private", "return": "Set<DynamicRoot>", "signature": "Set<DynamicRoot> getProgressiveDropRoots(DynamicRoot noAttrRoot, TurkishChar lastVowel)", "full_signature": "private Set<DynamicRoot> getProgressiveDropRoots(DynamicRoot noAttrRoot, TurkishChar lastVowel)", "class_method_signature": "BruteForceVerbRootFinder.getProgressiveDropRoots(DynamicRoot noAttrRoot, TurkishChar lastVowel)", "testcase": false, "constructor": false}, {"identifier": "getAorist_A_Roots", "parameters": "(DynamicRoot noAttrRoot)", "modifiers": "private", "return": "Set<DynamicRoot>", "signature": "Set<DynamicRoot> getAorist_A_Roots(DynamicRoot noAttrRoot)", "full_signature": "private Set<DynamicRoot> getAorist_A_Roots(DynamicRoot noAttrRoot)", "class_method_signature": "BruteForceVerbRootFinder.getAorist_A_Roots(DynamicRoot noAttrRoot)", "testcase": false, "constructor": false}, {"identifier": "getAorist_I_Roots", "parameters": "(DynamicRoot noAttrRoot)", "modifiers": "private", "return": "Set<DynamicRoot>", "signature": "Set<DynamicRoot> getAorist_I_Roots(DynamicRoot noAttrRoot)", "full_signature": "private Set<DynamicRoot> getAorist_I_Roots(DynamicRoot noAttrRoot)", "class_method_signature": "BruteForceVerbRootFinder.getAorist_I_Roots(DynamicRoot noAttrRoot)", "testcase": false, "constructor": false}, {"identifier": "getPossibleCausativeRoots", "parameters": "(TurkicLetter lastLetter, TurkishSequence partialInput, TurkishSequence wholeSurface, DynamicRoot noAttrRoot)", "modifiers": "private", "return": "Set<DynamicRoot>", "signature": "Set<DynamicRoot> getPossibleCausativeRoots(TurkicLetter lastLetter, TurkishSequence partialInput, TurkishSequence wholeSurface, DynamicRoot noAttrRoot)", "full_signature": "private Set<DynamicRoot> getPossibleCausativeRoots(TurkicLetter lastLetter, TurkishSequence partialInput, TurkishSequence wholeSurface, DynamicRoot noAttrRoot)", "class_method_signature": "BruteForceVerbRootFinder.getPossibleCausativeRoots(TurkicLetter lastLetter, TurkishSequence partialInput, TurkishSequence wholeSurface, DynamicRoot noAttrRoot)", "testcase": false, "constructor": false}, {"identifier": "getPossiblePassiveRoots", "parameters": "(TurkicLetter lastLetter, TurkishSequence partialInput, TurkishSequence wholeSurface, DynamicRoot noAttrRoot)", "modifiers": "private", "return": "Set<DynamicRoot>", "signature": "Set<DynamicRoot> getPossiblePassiveRoots(TurkicLetter lastLetter, TurkishSequence partialInput, TurkishSequence wholeSurface, DynamicRoot noAttrRoot)", "full_signature": "private Set<DynamicRoot> getPossiblePassiveRoots(TurkicLetter lastLetter, TurkishSequence partialInput, TurkishSequence wholeSurface, DynamicRoot noAttrRoot)", "class_method_signature": "BruteForceVerbRootFinder.getPossiblePassiveRoots(TurkicLetter lastLetter, TurkishSequence partialInput, TurkishSequence wholeSurface, DynamicRoot noAttrRoot)", "testcase": false, "constructor": false}, {"identifier": "getPossibleVoicingRoot", "parameters": "(DynamicRoot root)", "modifiers": "private", "return": "DynamicRoot", "signature": "DynamicRoot getPossibleVoicingRoot(DynamicRoot root)", "full_signature": "private DynamicRoot getPossibleVoicingRoot(DynamicRoot root)", "class_method_signature": "BruteForceVerbRootFinder.getPossibleVoicingRoot(DynamicRoot root)", "testcase": false, "constructor": false}, {"identifier": "strStartsWithAnyAdditionOfStr", "parameters": "(String wholeSurfaceStr, String partialInputStr, List<String> suffixes)", "modifiers": "private", "return": "boolean", "signature": "boolean strStartsWithAnyAdditionOfStr(String wholeSurfaceStr, String partialInputStr, List<String> suffixes)", "full_signature": "private boolean strStartsWithAnyAdditionOfStr(String wholeSurfaceStr, String partialInputStr, List<String> suffixes)", "class_method_signature": "BruteForceVerbRootFinder.strStartsWithAnyAdditionOfStr(String wholeSurfaceStr, String partialInputStr, List<String> suffixes)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/trnltk/morphology/contextless/rootfinder/BruteForceVerbRootFinder.java"}, "focal_method": {"identifier": "findRootsForPartialInput", "parameters": "(TurkishSequence partialInput, TurkishSequence wholeSurface)", "modifiers": "@Override @SuppressWarnings({\"UnnecessaryLocalVariable\", \"ConstantConditions\"}) public", "return": "Collection<DynamicRoot>", "body": "@Override\n    @SuppressWarnings({\"UnnecessaryLocalVariable\", \"ConstantConditions\"})\n    public Collection<DynamicRoot> findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface) {\n        final TurkishChar lastVowel = partialInput.getLastVowel();\n\n        final TurkishSequence rootSeq = partialInput;\n        final TurkishSequence lemmaSeq = rootSeq;\n        final TurkishSequence lemmaRootSeq = lemmaSeq;\n        final PrimaryPos primaryPos = PrimaryPos.Verb;\n        final SecondaryPos secondaryPos = null;\n        final EnumSet<LexemeAttribute> lexemeAttributes = EnumSet.noneOf(LexemeAttribute.class);\n        final DynamicLexeme lexeme = new DynamicLexeme(lemmaSeq.getUnderlyingString(), lemmaRootSeq.getUnderlyingString(), primaryPos, secondaryPos, lexemeAttributes);\n        final EnumSet<PhoneticExpectation> phoneticExpectations = EnumSet.noneOf(PhoneticExpectation.class);\n        final EnumSet<PhoneticAttribute> phoneticAttributes = phoneticsAnalyzer.calculatePhoneticAttributes(partialInput, lexemeAttributes);\n\n        final DynamicRoot noAttrRoot = new DynamicRoot(rootSeq, lexeme, phoneticAttributes, phoneticExpectations);\n\n        this.setLexemeAndPhoneticAttributes(Arrays.asList(noAttrRoot));\n        this.setLemma(Arrays.asList(noAttrRoot));\n\n        final TurkishChar lastChar = partialInput.getLastChar();\n        final TurkicLetter lastLetter = lastChar.getLetter();\n\n        final boolean partialSurfaceCanBeRootOfAVerb = this.seemsLikeAValidVerbRoot(partialInput);\n\n        if (wholeSurface.equals(partialInput))\n            return partialSurfaceCanBeRootOfAVerb ? Arrays.asList(noAttrRoot) : Collections.<DynamicRoot>emptyList();\n\n        final TurkishChar firstCharAfterPartialInput = wholeSurface.charAt(partialInput.length());\n\n        final TurkicLetter firstLetterAfterPartialInput = firstCharAfterPartialInput.getLetter();\n\n        final String wholeSurfaceStr = wholeSurface.getUnderlyingString();\n        final String partialInputStr = partialInput.getUnderlyingString();\n\n        final boolean mightHaveProgressiveVowelDrop = !lastLetter.isVowel()\n                && strStartsWithAnyAdditionOfStr(wholeSurfaceStr, partialInputStr, Arrays.asList(\"iyor\", \"\u0131yor\", \"uyor\", \"\u00fcyor\"));\n\n        final boolean mightHaveAorist_A = !lastLetter.isVowel()\n                && strStartsWithAnyAdditionOfStr(wholeSurfaceStr, partialInputStr, Arrays.asList(\"ar\", \"er\"));\n\n        // no Aorist_I for -ur, -\u00fcr\n        final boolean mightHaveAorist_I = !lastLetter.isVowel()\n                && strStartsWithAnyAdditionOfStr(wholeSurfaceStr, partialInputStr, Arrays.asList(\"\u0131r\", \"ir\"));\n\n        // for other letters, no voicing in verbs. {git+er->gider} vs {yapar, a\u00e7ar, diker}\n        final boolean voicingMightHaveHappened = lastLetter.equals(TurkishAlphabet.L_d) && firstLetterAfterPartialInput.isVowel();\n\n        final Set<DynamicRoot> possibleProgressiveVowelDropRoots = mightHaveProgressiveVowelDrop\n                ? this.getProgressiveDropRoots(noAttrRoot, lastVowel)\n                : new HashSet<DynamicRoot>();\n\n        final Set<DynamicRoot> possibleAorist_A_Roots = mightHaveAorist_A\n                ? this.getAorist_A_Roots(noAttrRoot)\n                : new HashSet<DynamicRoot>();\n\n        final Set<DynamicRoot> possibleAorist_I_Roots = mightHaveAorist_I\n                ? this.getAorist_I_Roots(noAttrRoot)\n                : new HashSet<DynamicRoot>();\n\n        final Set<DynamicRoot> possibleCausativeRoots = this.getPossibleCausativeRoots(lastLetter, partialInput, wholeSurface, noAttrRoot);\n        final Set<DynamicRoot> possiblePassiveRoots = this.getPossiblePassiveRoots(lastLetter, partialInput, wholeSurface, noAttrRoot);\n\n        if (voicingMightHaveHappened) {\n            Function<DynamicRoot, DynamicRoot> voicingRootFunction = new Function<DynamicRoot, DynamicRoot>() {\n                @Override\n                public DynamicRoot apply(DynamicRoot input) {\n                    return getPossibleVoicingRoot(input);\n                }\n            };\n\n            final Collection<DynamicRoot> possibleProgressiveVowelDropRoots_voicing = Collections2.transform(ImmutableSet.copyOf(possibleProgressiveVowelDropRoots), voicingRootFunction);\n            possibleProgressiveVowelDropRoots.addAll(possibleProgressiveVowelDropRoots_voicing);\n\n            final Collection<DynamicRoot> possibleAorist_A_Roots_voicing = Collections2.transform(ImmutableSet.copyOf(possibleAorist_A_Roots), voicingRootFunction);\n            possibleAorist_A_Roots.addAll(possibleAorist_A_Roots_voicing);\n\n            final Collection<DynamicRoot> possibleAorist_I_Roots_voicing = Collections2.transform(ImmutableSet.copyOf(possibleAorist_I_Roots), voicingRootFunction);\n            possibleAorist_A_Roots.addAll(possibleAorist_I_Roots_voicing);\n\n            final Collection<DynamicRoot> possibleCausativeRoots_voicing = Collections2.transform(ImmutableSet.copyOf(possibleCausativeRoots), voicingRootFunction);\n            possibleCausativeRoots.addAll(possibleCausativeRoots_voicing);\n\n            final Collection<DynamicRoot> possiblePassiveRoots_voicing = Collections2.transform(ImmutableSet.copyOf(possiblePassiveRoots), voicingRootFunction);\n            possiblePassiveRoots.addAll(possiblePassiveRoots_voicing);\n        }\n\n        final HashSet<DynamicRoot> generatedRoots = new HashSet<DynamicRoot>();\n\n        generatedRoots.add(noAttrRoot);\n\n        if (voicingMightHaveHappened)\n            generatedRoots.add(this.getPossibleVoicingRoot(noAttrRoot));\n\n        generatedRoots.addAll(possibleProgressiveVowelDropRoots);\n        generatedRoots.addAll(possibleAorist_A_Roots);\n        generatedRoots.addAll(possibleAorist_I_Roots);\n        generatedRoots.addAll(possibleCausativeRoots);\n        generatedRoots.addAll(possiblePassiveRoots);\n\n        this.setLexemeAndPhoneticAttributes(generatedRoots);\n        this.setLemma(generatedRoots);\n\n        return Collections2.filter(generatedRoots, new Predicate<DynamicRoot>() {\n            @Override\n            public boolean apply(DynamicRoot input) {\n                return seemsLikeAValidVerbRoot(new TurkishSequence(input.getLexeme().getLemmaRoot()));\n            }\n        });\n    }", "signature": "Collection<DynamicRoot> findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "full_signature": "@Override @SuppressWarnings({\"UnnecessaryLocalVariable\", \"ConstantConditions\"}) public Collection<DynamicRoot> findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "class_method_signature": "BruteForceVerbRootFinder.findRootsForPartialInput(TurkishSequence partialInput, TurkishSequence wholeSurface)", "testcase": false, "constructor": false, "invocations": ["getLastVowel", "noneOf", "getUnderlyingString", "getUnderlyingString", "noneOf", "calculatePhoneticAttributes", "setLexemeAndPhoneticAttributes", "asList", "setLemma", "asList", "getLastChar", "getLetter", "seemsLikeAValidVerbRoot", "equals", "asList", "emptyList", "charAt", "length", "getLetter", "getUnderlyingString", "getUnderlyingString", "isVowel", "strStartsWithAnyAdditionOfStr", "asList", "isVowel", "strStartsWithAnyAdditionOfStr", "asList", "isVowel", "strStartsWithAnyAdditionOfStr", "asList", "equals", "isVowel", "getProgressiveDropRoots", "getAorist_A_Roots", "getAorist_I_Roots", "getPossibleCausativeRoots", "getPossiblePassiveRoots", "getPossibleVoicingRoot", "transform", "copyOf", "addAll", "transform", "copyOf", "addAll", "transform", "copyOf", "addAll", "transform", "copyOf", "addAll", "transform", "copyOf", "addAll", "add", "add", "getPossibleVoicingRoot", "addAll", "addAll", "addAll", "addAll", "addAll", "setLexemeAndPhoneticAttributes", "setLemma", "filter", "seemsLikeAValidVerbRoot", "getLemmaRoot", "getLexeme"]}, "repository": {"repo_id": 7321072, "url": "https://github.com/aliok/trnltk-java", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 39, "size": 3428, "license": "licensed"}}