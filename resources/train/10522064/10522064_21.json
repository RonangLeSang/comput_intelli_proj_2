{"test_class": {"identifier": "ElementBasedStrategyTest", "superclass": "extends SemanticTest", "interfaces": "", "fields": [{"original_string": "private Model previousContext;", "modifier": "private", "type": "Model", "declarator": "previousContext", "var_name": "previousContext"}, {"original_string": "private Model liveContext;", "modifier": "private", "type": "Model", "declarator": "liveContext", "var_name": "liveContext"}, {"original_string": "private UpdateStrategy strategy;", "modifier": "private", "type": "UpdateStrategy", "declarator": "strategy", "var_name": "strategy"}, {"original_string": "private static final URI ENVIRONMENT = new URIImpl(\"urn:environment\");", "modifier": "private static final", "type": "URI", "declarator": "ENVIRONMENT = new URIImpl(\"urn:environment\")", "var_name": "ENVIRONMENT"}, {"original_string": "private static final URI PEERS = new URIImpl(\"urn:peers\");", "modifier": "private static final", "type": "URI", "declarator": "PEERS = new URIImpl(\"urn:peers\")", "var_name": "PEERS"}], "file": "dime-personalserver/dime-semantic/src/test/java/eu/dime/ps/semantic/service/context/ElementBasedStrategyTest.java"}, "test_case": {"identifier": "testCombinedAddition", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testCombinedAddition() throws LiveContextException {\n\t\t\n\t\tList<Statement> toAdd = new ArrayList<Statement>();\n\t\tList<Statement> toRemove = new ArrayList<Statement>();\n\n\t\tURI temperature = new URIImpl(\"urn:uuid:\" + UUID.randomUUID());\n\t\ttoAdd.add(new StatementImpl(null, ENVIRONMENT, DCON.currentTemperature, temperature));\n\t\ttoAdd.add(new StatementImpl(null, temperature, DCON.temperature, new PlainLiteralImpl(\"34\")));\n\n\t\tURI weather = new URIImpl(\"urn:uuid:\" + UUID.randomUUID());\n\t\ttoAdd.add(new StatementImpl(null, ENVIRONMENT, DCON.currentWeather, weather));\n\t\ttoAdd.add(new StatementImpl(null, weather, DCON.cloudcover, new PlainLiteralImpl(\"5\")));\n\t\t\n\t\tstrategy.update(toAdd, toRemove);\n\t\ttoAdd.clear();\n\t\ttoRemove.clear();\n\t\t\n\t\tassertTrue(liveContext.contains(ENVIRONMENT, DCON.currentWeather, weather));\n\t\tassertTrue(liveContext.contains(temperature, DCON.temperature, new PlainLiteralImpl(\"34\")));\n\t\tassertTrue(liveContext.contains(ENVIRONMENT, DCON.currentWeather, weather));\n\t\tassertTrue(liveContext.contains(weather, DCON.cloudcover, new PlainLiteralImpl(\"5\")));\n\t\tassertFalse(previousContext.contains(ENVIRONMENT, DCON.currentWeather, Variable.ANY));\n\t\tassertFalse(previousContext.contains(temperature, DCON.temperature, Variable.ANY));\n\t\tassertFalse(previousContext.contains(weather, DCON.cloudcover, Variable.ANY));\n\t}", "signature": "void testCombinedAddition()", "full_signature": "@Test public void testCombinedAddition()", "class_method_signature": "ElementBasedStrategyTest.testCombinedAddition()", "testcase": true, "constructor": false, "invocations": ["randomUUID", "add", "add", "randomUUID", "add", "add", "update", "clear", "clear", "assertTrue", "contains", "assertTrue", "contains", "assertTrue", "contains", "assertTrue", "contains", "assertFalse", "contains", "assertFalse", "contains", "assertFalse", "contains"]}, "focal_class": {"identifier": "ElementBasedStrategy", "superclass": "", "interfaces": "implements UpdateStrategy", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(ElementBasedStrategy.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(ElementBasedStrategy.class)", "var_name": "logger"}, {"original_string": "private final String allElementsQuery;", "modifier": "private final", "type": "String", "declarator": "allElementsQuery", "var_name": "allElementsQuery"}, {"original_string": "private final Set<URI> allProperties = new HashSet<URI>();", "modifier": "private final", "type": "Set<URI>", "declarator": "allProperties = new HashSet<URI>()", "var_name": "allProperties"}, {"original_string": "private Model previousContext;", "modifier": "private", "type": "Model", "declarator": "previousContext", "var_name": "previousContext"}, {"original_string": "private Model liveContext;", "modifier": "private", "type": "Model", "declarator": "liveContext", "var_name": "liveContext"}], "methods": [{"identifier": "ElementBasedStrategy", "parameters": "(Model previousContext, Model liveContext)", "modifiers": "public", "return": "", "signature": " ElementBasedStrategy(Model previousContext, Model liveContext)", "full_signature": "public  ElementBasedStrategy(Model previousContext, Model liveContext)", "class_method_signature": "ElementBasedStrategy.ElementBasedStrategy(Model previousContext, Model liveContext)", "testcase": false, "constructor": true}, {"identifier": "update", "parameters": "(List<Statement> toAdd, List<Statement> toRemove)", "modifiers": "@Override public", "return": "void", "signature": "void update(List<Statement> toAdd, List<Statement> toRemove)", "full_signature": "@Override public void update(List<Statement> toAdd, List<Statement> toRemove)", "class_method_signature": "ElementBasedStrategy.update(List<Statement> toAdd, List<Statement> toRemove)", "testcase": false, "constructor": false}, {"identifier": "findElements", "parameters": "(List<Statement> statements)", "modifiers": "private", "return": "Set<URI>", "signature": "Set<URI> findElements(List<Statement> statements)", "full_signature": "private Set<URI> findElements(List<Statement> statements)", "class_method_signature": "ElementBasedStrategy.findElements(List<Statement> statements)", "testcase": false, "constructor": false}], "file": "dime-personalserver/dime-semantic/src/main/java/eu/dime/ps/semantic/service/context/ElementBasedStrategy.java"}, "focal_method": {"identifier": "update", "parameters": "(List<Statement> toAdd, List<Statement> toRemove)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void update(List<Statement> toAdd, List<Statement> toRemove) {\n\t\t\n\t\t// loads statements to be added to a temporary model, so it can be queried\n\t\tModel newData = RDF2Go.getModelFactory().createModel().open();\n\t\tfor (Statement s : toAdd) {\n\t\t\tnewData.addStatement(s);\n\t\t}\n\t\t\n\t\t// extracts all URIs of Element resources from the statements to add/remove\n\t\tSet<URI> elements = new HashSet<URI>();\n\t\telements.addAll(findElements(toAdd));\n\t\telements.addAll(findElements(toRemove));\n\t\t\n\t\tlogger.debug(\"Updating live context... elements to be updated: \"+StringUtils.join(elements, \", \"));\n\n\t\tfor (URI element : elements) {\n\n\t\t\t// if an element is being modified/deleted, the current data from the live context\n\t\t\t// for that element is copied over to the previous context (removing the existing if any!)\n\t\t\tif (liveContext.contains(Variable.ANY, Variable.ANY, element)) {\n\t\t\t\tpreviousContext.removeStatements(Variable.ANY, Variable.ANY, element);\n\t\t\t\tpreviousContext.removeStatements(element, Variable.ANY, Variable.ANY);\n\t\t\t\tpreviousContext.addAll(liveContext.findStatements(Variable.ANY, Variable.ANY, element));\n\t\t\t\tpreviousContext.addAll(liveContext.findStatements(element, Variable.ANY, Variable.ANY));\n\t\t\t}\n\t\t\t\n\t\t\t// however, if a new element is inserted in the live context, all other elements for that aspect\n\t\t\t// are copied over to the previous context if they are not there yet\n\t\t\telse {\n\t\t\t\t// get all elements attached to a specific aspect in the live context\n\t\t\t\tURI aspect = newData.findStatements(Variable.ANY, Variable.ANY, element).next().getSubject().asURI();\n\t\t\t\tString query = \"SELECT DISTINCT ?element WHERE { \"+aspect.toSPARQL()+\" ?p ?element . }\";\n\t\t\t\tSet<URI> existing = new HashSet<URI>();\n\t\t\t\tClosableIterator<QueryRow> results = liveContext.sparqlSelect(query).iterator();\n\t\t\t\twhile (results.hasNext()) {\n\t\t\t\t\texisting.add(results.next().getValue(\"element\").asURI());\n\t\t\t\t}\n\t\t\t\tresults.close();\n\t\t\t\t\n\t\t\t\tfor (URI e : existing) {\n\t\t\t\t\t// if it doesn't exist in the previous context, its metadata is copied over;\n\t\t\t\t\t// nothing is done otherwise\n\t\t\t\t\tif (!previousContext.contains(aspect, Variable.ANY, e)) {\n\t\t\t\t\t\tpreviousContext.addAll(liveContext.findStatements(aspect, Variable.ANY, e));\n\t\t\t\t\t\tpreviousContext.addAll(liveContext.findStatements(e, Variable.ANY, Variable.ANY));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// not needed anymore, closing...\n\t\tnewData.close();\n\t\t\n\t\t// makes changes to live context (add/remove statements)\n\t\tliveContext.removeAll(toRemove.iterator());\n\t\tliveContext.addAll(toAdd.iterator());\n\t}", "signature": "void update(List<Statement> toAdd, List<Statement> toRemove)", "full_signature": "@Override public void update(List<Statement> toAdd, List<Statement> toRemove)", "class_method_signature": "ElementBasedStrategy.update(List<Statement> toAdd, List<Statement> toRemove)", "testcase": false, "constructor": false, "invocations": ["open", "createModel", "getModelFactory", "addStatement", "addAll", "findElements", "addAll", "findElements", "debug", "join", "contains", "removeStatements", "removeStatements", "addAll", "findStatements", "addAll", "findStatements", "asURI", "getSubject", "next", "findStatements", "toSPARQL", "iterator", "sparqlSelect", "hasNext", "add", "asURI", "getValue", "next", "close", "contains", "addAll", "findStatements", "addAll", "findStatements", "close", "removeAll", "iterator", "addAll", "iterator"]}, "repository": {"repo_id": 10522064, "url": "https://github.com/dime-project/dime-server", "language": "Java", "is_fork": false, "fork_count": 4, "stargazer_count": 22, "size": 39337, "license": "licensed"}}