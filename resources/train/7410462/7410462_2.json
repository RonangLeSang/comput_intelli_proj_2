{"test_class": {"identifier": "SimpleParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private MorphAnalyzer morph;", "modifier": "private", "type": "MorphAnalyzer", "declarator": "morph", "var_name": "morph"}, {"original_string": "private Parser parser;", "modifier": "private", "type": "Parser", "declarator": "parser", "var_name": "parser"}, {"original_string": "private boolean initialized = false;", "modifier": "private", "type": "boolean", "declarator": "initialized = false", "var_name": "initialized"}, {"original_string": "private static final String TAGGER_RULES_RESOURCE = \"/tagger_rules.txt\";", "modifier": "private static final", "type": "String", "declarator": "TAGGER_RULES_RESOURCE = \"/tagger_rules.txt\"", "var_name": "TAGGER_RULES_RESOURCE"}, {"original_string": "private static final String PARSER_RULES_RESOURCE = \"/parser_rules.txt\";", "modifier": "private static final", "type": "String", "declarator": "PARSER_RULES_RESOURCE = \"/parser_rules.txt\"", "var_name": "PARSER_RULES_RESOURCE"}], "file": "jmorphy2-nlp/src/test/java/company/evo/jmorphy2/nlp/SimpleParserTest.java"}, "test_case": {"identifier": "testParser", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testParser() throws IOException {\n        assertEquals(\"(TOP \" +\n                       \"(NP,nomn,plur \" +\n                         \"(ADJF,nomn,plur \u0436\u0435\u043d\u0441\u043a\u0438\u0435) \" +\n                         \"(NOUN,inan,masc,nomn,plur \u0441\u0430\u043f\u043e\u0433\u0438)))\",\n                     parser.parse(\"\u0436\u0435\u043d\u0441\u043a\u0438\u0435 \u0441\u0430\u043f\u043e\u0433\u0438\".split(\" \")).toString());\n\n        assertEquals(\"(TOP \" +\n                       \"(NP,nomn,plur \" +\n                         \"(ADJF,nomn,plur \u0436\u0435\u043d\u0441\u043a\u0438\u0435) \" +\n                         \"(NOUN,inan,masc,nomn,plur \u0441\u0430\u043f\u043e\u0433\u0438) \" +\n                         \"(ADJF,Qual,nomn,plur \u043a\u043e\u0440\u0438\u0447\u043d\u0435\u0432\u044b\u0435)))\",\n                     parser.parse(\"\u0436\u0435\u043d\u0441\u043a\u0438\u0435 \u0441\u0430\u043f\u043e\u0433\u0438 \u043a\u043e\u0440\u0438\u0447\u043d\u0435\u0432\u044b\u0435\".split(\" \")).toString());\n\n        assertEquals(\"(TOP \" +\n                       \"(NP,nomn,sing \" +\n                         \"(NP,nomn,sing \" +\n                           \"(NP,nomn,sing \" +\n                             \"(NOUN,inan,neut,nomn,sing \u043f\u0440\u043e\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435)) \" +\n                           \"(NP,gent,plur \" +\n                             \"(NOUN,femn,gent,inan,plur \u0441\u0438\u0441\u0442\u0435\u043c))) \" +\n                         \"(NP,gent,sing \" +\n                           \"(NOUN,gent,inan,masc,sing \u043f\u043e\u043b\u0438\u0432\u0430))))\",\n                     parser.parse(\"\u043f\u0440\u043e\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0438\u0441\u0442\u0435\u043c \u043f\u043e\u043b\u0438\u0432\u0430\".split(\" \")).toString());\n\n        assertEquals(\"(TOP \" +\n                       \"(NP \" +\n                         \"(NP,nomn,sing (NOUN,inan,masc,nomn,sing \u0447\u0435\u0445\u043e\u043b)) \" +\n                         \"(PP \" +\n                           \"(PREP \u0434\u043b\u044f) \" +\n                           \"(NP,gent,sing (NOUN,gent,inan,masc,sing \u0442\u0435\u043b\u0435\u0444\u043e\u043d\u0430)))))\",\n                     parser.parse(new String[]{\"\u0447\u0435\u0445\u043e\u043b\", \"\u0434\u043b\u044f\", \"\u0442\u0435\u043b\u0435\u0444\u043e\u043d\u0430\"}).toString());\n\n        assertEquals(\"(TOP \" +\n                       \"(NP \" +\n                         \"(NP,nomn,sing \" +\n                           \"(NOUN,inan,masc,nomn,sing \u0447\u0435\u0445\u043e\u043b)) \" +\n                         \"(PP \" +\n                           \"(PREP \u0434\u043b\u044f) \" +\n                           \"(NP,gent,sing \" +\n                             \"(NOUN,gent,inan,masc,sing \u0442\u0435\u043b\u0435\u0444\u043e\u043d\u0430) \" +\n                             \"(LATN iphone)))))\",\n                     parser.parse(new String[]{\"\u0447\u0435\u0445\u043e\u043b\", \"\u0434\u043b\u044f\", \"\u0442\u0435\u043b\u0435\u0444\u043e\u043d\u0430\", \"iphone\"}).toString());\n\n        assertEquals(\"(TOP \" +\n                       \"(NP \" +\n                         \"(NP,nomn,sing (NOUN,inan,masc,nomn,sing \u0447\u0435\u0445\u043e\u043b)) \" +\n                         \"(PP \" +\n                           \"(PREP \u0434\u043b\u044f) \" +\n                           \"(NP,nomn,sing \" +\n                             \"(LATN iphone) \" +\n                             \"(NUMB,intg 5)))))\",\n                     parser.parse(new String[]{\"\u0447\u0435\u0445\u043e\u043b\", \"\u0434\u043b\u044f\", \"iphone\", \"5\"}).toString());\n\n        assertEquals(\"(TOP \" +\n                       \"(NP,nomn,sing \" +\n                         \"(LATN iphone) \" +\n                         \"(NUMB,intg 5)))\",\n                     parser.parse(new String[]{\"iphone\", \"5\"}).toString());\n\n        assertEquals(\"(TOP \" +\n                       \"(NP,nomn,sing \" +\n                         \"(NP,nomn,sing \" +\n                           \"(NP,nomn,sing \" +\n                             \"(NOUN,femn,inan,nomn,sing \u0443\u0431\u043e\u0440\u043a\u0430)) \" +\n                           \"(CONJ \u0438) \" +\n                           \"(NP,nomn,sing \" +\n                             \"(NOUN,inan,masc,nomn,sing \u0432\u044b\u0432\u043e\u0437))) \" +\n                         \"(NP,gent,sing \" +\n                           \"(NP,gent,sing \" +\n                             \"(NOUN,gent,inan,masc,sing \u0441\u043d\u0435\u0433\u0430)) \" +\n                           \"(CONJ \u0438) \" +\n                           \"(NP,gent,sing \" +\n                             \"(NOUN,gent,inan,masc,sing \u043b\u044c\u0434\u0430)))))\",\n                     parser.parse(new String[]{\"\u0443\u0431\u043e\u0440\u043a\u0430\", \"\u0438\", \"\u0432\u044b\u0432\u043e\u0437\", \"\u0441\u043d\u0435\u0433\u0430\", \"\u0438\", \"\u043b\u044c\u0434\u0430\"}).toString());\n\n        assertEquals(\"(TOP \" +\n                       \"(NP,nomn,sing \" +\n                         \"(NP,nomn,sing \" +\n                           \"(NP,nomn,sing \" +\n                             \"(NOUN,femn,inan,nomn,sing \u0443\u0431\u043e\u0440\u043a\u0430)) \" +\n                           \"(NP,gent,sing \" +\n                             \"(NOUN,gent,inan,masc,sing \u0441\u043d\u0435\u0433\u0430))) \" +\n                         \"(CONJ \u0438) \" +\n                         \"(NP,nomn,sing \" +\n                           \"(NP,nomn,sing \" +\n                             \"(NOUN,inan,masc,nomn,sing \u0432\u044b\u0432\u043e\u0437)) \" +\n                           \"(NP,gent,sing \" +\n                             \"(NOUN,gent,inan,masc,sing \u043b\u044c\u0434\u0430)))))\",\n                     parser.parse(new String[]{\"\u0443\u0431\u043e\u0440\u043a\u0430\", \"\u0441\u043d\u0435\u0433\u0430\", \"\u0438\", \"\u0432\u044b\u0432\u043e\u0437\", \"\u043b\u044c\u0434\u0430\"}).toString());\n    }", "signature": "void testParser()", "full_signature": "@Test public void testParser()", "class_method_signature": "SimpleParserTest.testParser()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "", "parse", "oStri", "assertEquals", "", "parse", ";", "assertEquals", "", "parse", "", "assertEquals", "", "parse", "assertEquals", "", "parse", "assertEquals", "());", "parse", "assertEquals", "toString", "parse", "assertEquals", "", "parse", "assertEquals", "", "parse"]}, "focal_class": {"identifier": "SimpleParser", "superclass": "extends Parser", "interfaces": "", "fields": [{"original_string": "protected final Ruleset rules;", "modifier": "protected final", "type": "Ruleset", "declarator": "rules", "var_name": "rules"}, {"original_string": "private final int threshold;", "modifier": "private final", "type": "int", "declarator": "threshold", "var_name": "threshold"}, {"original_string": "protected final Set<String> allowedGrammemeValues;", "modifier": "protected final", "type": "Set<String>", "declarator": "allowedGrammemeValues", "var_name": "allowedGrammemeValues"}, {"original_string": "public static final int DEFAULT_THRESHOLD = 100;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_THRESHOLD = 100", "var_name": "DEFAULT_THRESHOLD"}, {"original_string": "protected static final Ruleset defaultRules = new Ruleset();", "modifier": "protected static final", "type": "Ruleset", "declarator": "defaultRules = new Ruleset()", "var_name": "defaultRules"}], "methods": [{"identifier": "SimpleParser", "parameters": "(MorphAnalyzer morph, Tagger tagger)", "modifiers": "public", "return": "", "signature": " SimpleParser(MorphAnalyzer morph, Tagger tagger)", "full_signature": "public  SimpleParser(MorphAnalyzer morph, Tagger tagger)", "class_method_signature": "SimpleParser.SimpleParser(MorphAnalyzer morph, Tagger tagger)", "testcase": false, "constructor": true}, {"identifier": "SimpleParser", "parameters": "(MorphAnalyzer morph, Tagger tagger, Ruleset rules)", "modifiers": "public", "return": "", "signature": " SimpleParser(MorphAnalyzer morph, Tagger tagger, Ruleset rules)", "full_signature": "public  SimpleParser(MorphAnalyzer morph, Tagger tagger, Ruleset rules)", "class_method_signature": "SimpleParser.SimpleParser(MorphAnalyzer morph, Tagger tagger, Ruleset rules)", "testcase": false, "constructor": true}, {"identifier": "SimpleParser", "parameters": "(MorphAnalyzer morph, Tagger tagger, int threshold)", "modifiers": "public", "return": "", "signature": " SimpleParser(MorphAnalyzer morph, Tagger tagger, int threshold)", "full_signature": "public  SimpleParser(MorphAnalyzer morph, Tagger tagger, int threshold)", "class_method_signature": "SimpleParser.SimpleParser(MorphAnalyzer morph, Tagger tagger, int threshold)", "testcase": false, "constructor": true}, {"identifier": "SimpleParser", "parameters": "(MorphAnalyzer morph, Tagger tagger, Ruleset rules, int threshold)", "modifiers": "public", "return": "", "signature": " SimpleParser(MorphAnalyzer morph, Tagger tagger, Ruleset rules, int threshold)", "full_signature": "public  SimpleParser(MorphAnalyzer morph, Tagger tagger, Ruleset rules, int threshold)", "class_method_signature": "SimpleParser.SimpleParser(MorphAnalyzer morph, Tagger tagger, Ruleset rules, int threshold)", "testcase": false, "constructor": true}, {"identifier": "getGrammemeValuesFor", "parameters": "(String rootValue)", "modifiers": "private", "return": "Set<String>", "signature": "Set<String> getGrammemeValuesFor(String rootValue)", "full_signature": "private Set<String> getGrammemeValuesFor(String rootValue)", "class_method_signature": "SimpleParser.getGrammemeValuesFor(String rootValue)", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(List<Node.Top> sentences)", "modifiers": "public", "return": "Node.Top", "signature": "Node.Top parse(List<Node.Top> sentences)", "full_signature": "public Node.Top parse(List<Node.Top> sentences)", "class_method_signature": "SimpleParser.parse(List<Node.Top> sentences)", "testcase": false, "constructor": false}, {"identifier": "parseAll", "parameters": "(List<Node.Top> sentences)", "modifiers": "public", "return": "List<Node.Top>", "signature": "List<Node.Top> parseAll(List<Node.Top> sentences)", "full_signature": "public List<Node.Top> parseAll(List<Node.Top> sentences)", "class_method_signature": "SimpleParser.parseAll(List<Node.Top> sentences)", "testcase": false, "constructor": false}, {"identifier": "reduce", "parameters": "(Rule rule, ImmutableList<Node> nodes, int offset)", "modifiers": "private", "return": "ImmutableList<Node>", "signature": "ImmutableList<Node> reduce(Rule rule, ImmutableList<Node> nodes, int offset)", "full_signature": "private ImmutableList<Node> reduce(Rule rule, ImmutableList<Node> nodes, int offset)", "class_method_signature": "SimpleParser.reduce(Rule rule, ImmutableList<Node> nodes, int offset)", "testcase": false, "constructor": false}], "file": "jmorphy2-nlp/src/main/java/company/evo/jmorphy2/nlp/SimpleParser.java"}, "focal_method": {"identifier": "parse", "parameters": "(List<Node.Top> sentences)", "modifiers": "public", "return": "Node.Top", "body": "public Node.Top parse(List<Node.Top> sentences) {\n        List<Node.Top> tops = parseAll(sentences);\n        if (tops.isEmpty()) {\n            return new Node.Top(ImmutableList.of(), 0.0f);\n        }\n        return tops.get(0);\n    }", "signature": "Node.Top parse(List<Node.Top> sentences)", "full_signature": "public Node.Top parse(List<Node.Top> sentences)", "class_method_signature": "SimpleParser.parse(List<Node.Top> sentences)", "testcase": false, "constructor": false, "invocations": ["parseAll", "isEmpty", "of", "get"]}, "repository": {"repo_id": 7410462, "url": "https://github.com/anti-social/jmorphy2", "stars": 25, "created": "1/2/2013 5:28:23 PM +00:00", "updates": "2019-12-05T15:39:47+00:00", "fork": "False", "license": "licensed"}}