{"test_class": {"identifier": "TestAvroUtils", "superclass": "extends KijiClientTest", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(TestAvroUtils.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(TestAvroUtils.class)", "var_name": "LOG"}, {"original_string": "private static final Schema NULL_SCHEMA = Schema.create(Schema.Type.NULL);", "modifier": "private static final", "type": "Schema", "declarator": "NULL_SCHEMA = Schema.create(Schema.Type.NULL)", "var_name": "NULL_SCHEMA"}, {"original_string": "private static final Schema BOOLEAN_SCHEMA = Schema.create(Schema.Type.BOOLEAN);", "modifier": "private static final", "type": "Schema", "declarator": "BOOLEAN_SCHEMA = Schema.create(Schema.Type.BOOLEAN)", "var_name": "BOOLEAN_SCHEMA"}, {"original_string": "private static final Schema INT_SCHEMA = Schema.create(Schema.Type.INT);", "modifier": "private static final", "type": "Schema", "declarator": "INT_SCHEMA = Schema.create(Schema.Type.INT)", "var_name": "INT_SCHEMA"}, {"original_string": "private static final Schema LONG_SCHEMA = Schema.create(Schema.Type.LONG);", "modifier": "private static final", "type": "Schema", "declarator": "LONG_SCHEMA = Schema.create(Schema.Type.LONG)", "var_name": "LONG_SCHEMA"}, {"original_string": "private static final Schema FLOAT_SCHEMA = Schema.create(Schema.Type.FLOAT);", "modifier": "private static final", "type": "Schema", "declarator": "FLOAT_SCHEMA = Schema.create(Schema.Type.FLOAT)", "var_name": "FLOAT_SCHEMA"}, {"original_string": "private static final Schema DOUBLE_SCHEMA = Schema.create(Schema.Type.DOUBLE);", "modifier": "private static final", "type": "Schema", "declarator": "DOUBLE_SCHEMA = Schema.create(Schema.Type.DOUBLE)", "var_name": "DOUBLE_SCHEMA"}, {"original_string": "private static final Schema STRING_SCHEMA = Schema.create(Schema.Type.STRING);", "modifier": "private static final", "type": "Schema", "declarator": "STRING_SCHEMA = Schema.create(Schema.Type.STRING)", "var_name": "STRING_SCHEMA"}, {"original_string": "private static final Schema BYTES_SCHEMA = Schema.create(Schema.Type.BYTES);", "modifier": "private static final", "type": "Schema", "declarator": "BYTES_SCHEMA = Schema.create(Schema.Type.BYTES)", "var_name": "BYTES_SCHEMA"}, {"original_string": "private static final Schema INT_ARRAY_SCHEMA = Schema.createArray(INT_SCHEMA);", "modifier": "private static final", "type": "Schema", "declarator": "INT_ARRAY_SCHEMA = Schema.createArray(INT_SCHEMA)", "var_name": "INT_ARRAY_SCHEMA"}, {"original_string": "private static final Schema LONG_ARRAY_SCHEMA = Schema.createArray(LONG_SCHEMA);", "modifier": "private static final", "type": "Schema", "declarator": "LONG_ARRAY_SCHEMA = Schema.createArray(LONG_SCHEMA)", "var_name": "LONG_ARRAY_SCHEMA"}, {"original_string": "private static final Schema STRING_ARRAY_SCHEMA = Schema.createArray(STRING_SCHEMA);", "modifier": "private static final", "type": "Schema", "declarator": "STRING_ARRAY_SCHEMA = Schema.createArray(STRING_SCHEMA)", "var_name": "STRING_ARRAY_SCHEMA"}, {"original_string": "private static final Schema INT_MAP_SCHEMA = Schema.createMap(INT_SCHEMA);", "modifier": "private static final", "type": "Schema", "declarator": "INT_MAP_SCHEMA = Schema.createMap(INT_SCHEMA)", "var_name": "INT_MAP_SCHEMA"}, {"original_string": "private static final Schema LONG_MAP_SCHEMA = Schema.createMap(LONG_SCHEMA);", "modifier": "private static final", "type": "Schema", "declarator": "LONG_MAP_SCHEMA = Schema.createMap(LONG_SCHEMA)", "var_name": "LONG_MAP_SCHEMA"}, {"original_string": "private static final Schema STRING_MAP_SCHEMA = Schema.createMap(STRING_SCHEMA);", "modifier": "private static final", "type": "Schema", "declarator": "STRING_MAP_SCHEMA = Schema.createMap(STRING_SCHEMA)", "var_name": "STRING_MAP_SCHEMA"}, {"original_string": "private static final Schema ENUM1_AB_SCHEMA =\n      Schema.createEnum(\"Enum1\", null, null, ImmutableList.of(\"A\", \"B\"));", "modifier": "private static final", "type": "Schema", "declarator": "ENUM1_AB_SCHEMA =\n      Schema.createEnum(\"Enum1\", null, null, ImmutableList.of(\"A\", \"B\"))", "var_name": "ENUM1_AB_SCHEMA"}, {"original_string": "private static final Schema ENUM1_ABC_SCHEMA =\n      Schema.createEnum(\"Enum1\", null, null, ImmutableList.of(\"A\", \"B\", \"C\"));", "modifier": "private static final", "type": "Schema", "declarator": "ENUM1_ABC_SCHEMA =\n      Schema.createEnum(\"Enum1\", null, null, ImmutableList.of(\"A\", \"B\", \"C\"))", "var_name": "ENUM1_ABC_SCHEMA"}, {"original_string": "private static final Schema ENUM1_BC_SCHEMA =\n      Schema.createEnum(\"Enum1\", null, null, ImmutableList.of(\"B\", \"C\"));", "modifier": "private static final", "type": "Schema", "declarator": "ENUM1_BC_SCHEMA =\n      Schema.createEnum(\"Enum1\", null, null, ImmutableList.of(\"B\", \"C\"))", "var_name": "ENUM1_BC_SCHEMA"}, {"original_string": "private static final Schema ENUM2_AB_SCHEMA =\n      Schema.createEnum(\"Enum2\", null, null, ImmutableList.of(\"A\", \"B\"));", "modifier": "private static final", "type": "Schema", "declarator": "ENUM2_AB_SCHEMA =\n      Schema.createEnum(\"Enum2\", null, null, ImmutableList.of(\"A\", \"B\"))", "var_name": "ENUM2_AB_SCHEMA"}, {"original_string": "private static final Schema EMPTY_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.<Schema>of());", "modifier": "private static final", "type": "Schema", "declarator": "EMPTY_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.<Schema>of())", "var_name": "EMPTY_UNION_SCHEMA"}, {"original_string": "private static final Schema NULL_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(NULL_SCHEMA));", "modifier": "private static final", "type": "Schema", "declarator": "NULL_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(NULL_SCHEMA))", "var_name": "NULL_UNION_SCHEMA"}, {"original_string": "private static final Schema INT_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(INT_SCHEMA));", "modifier": "private static final", "type": "Schema", "declarator": "INT_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(INT_SCHEMA))", "var_name": "INT_UNION_SCHEMA"}, {"original_string": "private static final Schema LONG_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(LONG_SCHEMA));", "modifier": "private static final", "type": "Schema", "declarator": "LONG_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(LONG_SCHEMA))", "var_name": "LONG_UNION_SCHEMA"}, {"original_string": "private static final Schema STRING_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(STRING_SCHEMA));", "modifier": "private static final", "type": "Schema", "declarator": "STRING_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(STRING_SCHEMA))", "var_name": "STRING_UNION_SCHEMA"}, {"original_string": "private static final Schema INT_STRING_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(INT_SCHEMA, STRING_SCHEMA));", "modifier": "private static final", "type": "Schema", "declarator": "INT_STRING_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(INT_SCHEMA, STRING_SCHEMA))", "var_name": "INT_STRING_UNION_SCHEMA"}, {"original_string": "private static final Schema STRING_INT_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(STRING_SCHEMA, INT_SCHEMA));", "modifier": "private static final", "type": "Schema", "declarator": "STRING_INT_UNION_SCHEMA =\n      Schema.createUnion(ImmutableList.of(STRING_SCHEMA, INT_SCHEMA))", "var_name": "STRING_INT_UNION_SCHEMA"}, {"original_string": "private static final Schema EMPTY_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false);", "modifier": "private static final", "type": "Schema", "declarator": "EMPTY_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false)", "var_name": "EMPTY_RECORD1"}, {"original_string": "private static final Schema EMPTY_RECORD2 =\n      Schema.createRecord(\"Record2\", null, null, false);", "modifier": "private static final", "type": "Schema", "declarator": "EMPTY_RECORD2 =\n      Schema.createRecord(\"Record2\", null, null, false)", "var_name": "EMPTY_RECORD2"}, {"original_string": "private static final Schema A_INT_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false);", "modifier": "private static final", "type": "Schema", "declarator": "A_INT_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false)", "var_name": "A_INT_RECORD1"}, {"original_string": "private static final Schema A_LONG_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false);", "modifier": "private static final", "type": "Schema", "declarator": "A_LONG_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false)", "var_name": "A_LONG_RECORD1"}, {"original_string": "private static final Schema A_INT_B_INT_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false);", "modifier": "private static final", "type": "Schema", "declarator": "A_INT_B_INT_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false)", "var_name": "A_INT_B_INT_RECORD1"}, {"original_string": "private static final Schema A_DINT_RECORD1 =  // DTYPE means TYPE with default value\n      Schema.createRecord(\"Record1\", null, null, false);", "modifier": "private static final", "type": "Schema", "declarator": "A_DINT_RECORD1 =  // DTYPE means TYPE with default value\n      Schema.createRecord(\"Record1\", null, null, false)", "var_name": "A_DINT_RECORD1"}, {"original_string": "private static final Schema A_INT_B_DINT_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false);", "modifier": "private static final", "type": "Schema", "declarator": "A_INT_B_DINT_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false)", "var_name": "A_INT_B_DINT_RECORD1"}, {"original_string": "private static final Schema A_DINT_B_DINT_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false);", "modifier": "private static final", "type": "Schema", "declarator": "A_DINT_B_DINT_RECORD1 =\n      Schema.createRecord(\"Record1\", null, null, false)", "var_name": "A_DINT_B_DINT_RECORD1"}, {"original_string": "private static final Schema INT_LIST_RECORD =\n      Schema.createRecord(\"List\", null, null, false);", "modifier": "private static final", "type": "Schema", "declarator": "INT_LIST_RECORD =\n      Schema.createRecord(\"List\", null, null, false)", "var_name": "INT_LIST_RECORD"}, {"original_string": "private static final Schema LONG_LIST_RECORD =\n      Schema.createRecord(\"List\", null, null, false);", "modifier": "private static final", "type": "Schema", "declarator": "LONG_LIST_RECORD =\n      Schema.createRecord(\"List\", null, null, false)", "var_name": "LONG_LIST_RECORD"}, {"original_string": "private static final Schema WRITER_SCHEMA = Schema.createRecord(Lists.newArrayList(\n      new Schema.Field(\"oldfield1\", INT_SCHEMA, null, null),\n      new Schema.Field(\"oldfield2\", STRING_SCHEMA, null, null)));", "modifier": "private static final", "type": "Schema", "declarator": "WRITER_SCHEMA = Schema.createRecord(Lists.newArrayList(\n      new Schema.Field(\"oldfield1\", INT_SCHEMA, null, null),\n      new Schema.Field(\"oldfield2\", STRING_SCHEMA, null, null)))", "var_name": "WRITER_SCHEMA"}, {"original_string": "public static final List<ReaderWriter> COMPATIBLE_READER_WRITER_TEST_CASES = ImmutableList.of(\n      new ReaderWriter(BOOLEAN_SCHEMA, BOOLEAN_SCHEMA),\n\n      new ReaderWriter(INT_SCHEMA, INT_SCHEMA),\n\n      new ReaderWriter(LONG_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(LONG_SCHEMA, LONG_SCHEMA),\n\n      // Avro spec says INT/LONG can be promoted to FLOAT/DOUBLE.\n      // This is arguable as this causes a loss of precision.\n      new ReaderWriter(FLOAT_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(FLOAT_SCHEMA, LONG_SCHEMA),\n      new ReaderWriter(DOUBLE_SCHEMA, LONG_SCHEMA),\n\n      new ReaderWriter(DOUBLE_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(DOUBLE_SCHEMA, FLOAT_SCHEMA),\n\n      new ReaderWriter(STRING_SCHEMA, STRING_SCHEMA),\n\n      new ReaderWriter(BYTES_SCHEMA, BYTES_SCHEMA),\n\n      new ReaderWriter(INT_ARRAY_SCHEMA, INT_ARRAY_SCHEMA),\n      new ReaderWriter(LONG_ARRAY_SCHEMA, INT_ARRAY_SCHEMA),\n      new ReaderWriter(INT_MAP_SCHEMA, INT_MAP_SCHEMA),\n      new ReaderWriter(LONG_MAP_SCHEMA, INT_MAP_SCHEMA),\n\n      new ReaderWriter(ENUM1_AB_SCHEMA, ENUM1_AB_SCHEMA),\n      new ReaderWriter(ENUM1_ABC_SCHEMA, ENUM1_AB_SCHEMA),\n\n      // Tests involving unions:\n      new ReaderWriter(EMPTY_UNION_SCHEMA, EMPTY_UNION_SCHEMA),\n      new ReaderWriter(INT_UNION_SCHEMA, INT_UNION_SCHEMA),\n      new ReaderWriter(INT_STRING_UNION_SCHEMA, STRING_INT_UNION_SCHEMA),\n      new ReaderWriter(INT_UNION_SCHEMA, EMPTY_UNION_SCHEMA),\n      new ReaderWriter(LONG_UNION_SCHEMA, INT_UNION_SCHEMA),\n\n      // Special case of singleton unions:\n      new ReaderWriter(INT_UNION_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, INT_UNION_SCHEMA),\n\n      // Tests involving records:\n      new ReaderWriter(EMPTY_RECORD1, EMPTY_RECORD1),\n      new ReaderWriter(EMPTY_RECORD1, A_INT_RECORD1),\n\n      new ReaderWriter(A_INT_RECORD1, A_INT_RECORD1),\n      new ReaderWriter(A_DINT_RECORD1, A_INT_RECORD1),\n      new ReaderWriter(A_DINT_RECORD1, A_DINT_RECORD1),\n      new ReaderWriter(A_INT_RECORD1, A_DINT_RECORD1),\n\n      new ReaderWriter(A_LONG_RECORD1, A_INT_RECORD1),\n\n      new ReaderWriter(A_INT_RECORD1, A_INT_B_INT_RECORD1),\n      new ReaderWriter(A_DINT_RECORD1, A_INT_B_INT_RECORD1),\n\n      new ReaderWriter(A_INT_B_DINT_RECORD1, A_INT_RECORD1),\n      new ReaderWriter(A_DINT_B_DINT_RECORD1, EMPTY_RECORD1),\n      new ReaderWriter(A_DINT_B_DINT_RECORD1, A_INT_RECORD1),\n      new ReaderWriter(A_INT_B_INT_RECORD1, A_DINT_B_DINT_RECORD1),\n\n      new ReaderWriter(INT_LIST_RECORD, INT_LIST_RECORD),\n      new ReaderWriter(LONG_LIST_RECORD, LONG_LIST_RECORD),\n      new ReaderWriter(LONG_LIST_RECORD, INT_LIST_RECORD),\n\n      new ReaderWriter(NULL_SCHEMA, NULL_SCHEMA)\n  );", "modifier": "public static final", "type": "List<ReaderWriter>", "declarator": "COMPATIBLE_READER_WRITER_TEST_CASES = ImmutableList.of(\n      new ReaderWriter(BOOLEAN_SCHEMA, BOOLEAN_SCHEMA),\n\n      new ReaderWriter(INT_SCHEMA, INT_SCHEMA),\n\n      new ReaderWriter(LONG_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(LONG_SCHEMA, LONG_SCHEMA),\n\n      // Avro spec says INT/LONG can be promoted to FLOAT/DOUBLE.\n      // This is arguable as this causes a loss of precision.\n      new ReaderWriter(FLOAT_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(FLOAT_SCHEMA, LONG_SCHEMA),\n      new ReaderWriter(DOUBLE_SCHEMA, LONG_SCHEMA),\n\n      new ReaderWriter(DOUBLE_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(DOUBLE_SCHEMA, FLOAT_SCHEMA),\n\n      new ReaderWriter(STRING_SCHEMA, STRING_SCHEMA),\n\n      new ReaderWriter(BYTES_SCHEMA, BYTES_SCHEMA),\n\n      new ReaderWriter(INT_ARRAY_SCHEMA, INT_ARRAY_SCHEMA),\n      new ReaderWriter(LONG_ARRAY_SCHEMA, INT_ARRAY_SCHEMA),\n      new ReaderWriter(INT_MAP_SCHEMA, INT_MAP_SCHEMA),\n      new ReaderWriter(LONG_MAP_SCHEMA, INT_MAP_SCHEMA),\n\n      new ReaderWriter(ENUM1_AB_SCHEMA, ENUM1_AB_SCHEMA),\n      new ReaderWriter(ENUM1_ABC_SCHEMA, ENUM1_AB_SCHEMA),\n\n      // Tests involving unions:\n      new ReaderWriter(EMPTY_UNION_SCHEMA, EMPTY_UNION_SCHEMA),\n      new ReaderWriter(INT_UNION_SCHEMA, INT_UNION_SCHEMA),\n      new ReaderWriter(INT_STRING_UNION_SCHEMA, STRING_INT_UNION_SCHEMA),\n      new ReaderWriter(INT_UNION_SCHEMA, EMPTY_UNION_SCHEMA),\n      new ReaderWriter(LONG_UNION_SCHEMA, INT_UNION_SCHEMA),\n\n      // Special case of singleton unions:\n      new ReaderWriter(INT_UNION_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, INT_UNION_SCHEMA),\n\n      // Tests involving records:\n      new ReaderWriter(EMPTY_RECORD1, EMPTY_RECORD1),\n      new ReaderWriter(EMPTY_RECORD1, A_INT_RECORD1),\n\n      new ReaderWriter(A_INT_RECORD1, A_INT_RECORD1),\n      new ReaderWriter(A_DINT_RECORD1, A_INT_RECORD1),\n      new ReaderWriter(A_DINT_RECORD1, A_DINT_RECORD1),\n      new ReaderWriter(A_INT_RECORD1, A_DINT_RECORD1),\n\n      new ReaderWriter(A_LONG_RECORD1, A_INT_RECORD1),\n\n      new ReaderWriter(A_INT_RECORD1, A_INT_B_INT_RECORD1),\n      new ReaderWriter(A_DINT_RECORD1, A_INT_B_INT_RECORD1),\n\n      new ReaderWriter(A_INT_B_DINT_RECORD1, A_INT_RECORD1),\n      new ReaderWriter(A_DINT_B_DINT_RECORD1, EMPTY_RECORD1),\n      new ReaderWriter(A_DINT_B_DINT_RECORD1, A_INT_RECORD1),\n      new ReaderWriter(A_INT_B_INT_RECORD1, A_DINT_B_DINT_RECORD1),\n\n      new ReaderWriter(INT_LIST_RECORD, INT_LIST_RECORD),\n      new ReaderWriter(LONG_LIST_RECORD, LONG_LIST_RECORD),\n      new ReaderWriter(LONG_LIST_RECORD, INT_LIST_RECORD),\n\n      new ReaderWriter(NULL_SCHEMA, NULL_SCHEMA)\n  )", "var_name": "COMPATIBLE_READER_WRITER_TEST_CASES"}, {"original_string": "public static final List<ReaderWriter> INCOMPATIBLE_READER_WRITER_TEST_CASES = ImmutableList.of(\n      new ReaderWriter(NULL_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(NULL_SCHEMA, LONG_SCHEMA),\n\n      new ReaderWriter(BOOLEAN_SCHEMA, INT_SCHEMA),\n\n      new ReaderWriter(INT_SCHEMA, NULL_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, BOOLEAN_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, LONG_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, FLOAT_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, DOUBLE_SCHEMA),\n\n      new ReaderWriter(LONG_SCHEMA, FLOAT_SCHEMA),\n      new ReaderWriter(LONG_SCHEMA, DOUBLE_SCHEMA),\n\n      new ReaderWriter(FLOAT_SCHEMA, DOUBLE_SCHEMA),\n\n      new ReaderWriter(STRING_SCHEMA, BOOLEAN_SCHEMA),\n      new ReaderWriter(STRING_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(STRING_SCHEMA, BYTES_SCHEMA),\n\n      new ReaderWriter(BYTES_SCHEMA, NULL_SCHEMA),\n      new ReaderWriter(BYTES_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(BYTES_SCHEMA, STRING_SCHEMA),\n\n      new ReaderWriter(INT_ARRAY_SCHEMA, LONG_ARRAY_SCHEMA),\n      new ReaderWriter(INT_MAP_SCHEMA, INT_ARRAY_SCHEMA),\n      new ReaderWriter(INT_ARRAY_SCHEMA, INT_MAP_SCHEMA),\n      new ReaderWriter(INT_MAP_SCHEMA, LONG_MAP_SCHEMA),\n\n      new ReaderWriter(ENUM1_AB_SCHEMA, ENUM1_ABC_SCHEMA),\n      new ReaderWriter(ENUM1_BC_SCHEMA, ENUM1_ABC_SCHEMA),\n\n      new ReaderWriter(ENUM1_AB_SCHEMA, ENUM2_AB_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, ENUM2_AB_SCHEMA),\n      new ReaderWriter(ENUM2_AB_SCHEMA, INT_SCHEMA),\n\n      // Tests involving unions:\n      new ReaderWriter(INT_UNION_SCHEMA, INT_STRING_UNION_SCHEMA),\n      new ReaderWriter(STRING_UNION_SCHEMA, INT_STRING_UNION_SCHEMA),\n\n      new ReaderWriter(EMPTY_RECORD2, EMPTY_RECORD1),\n      new ReaderWriter(A_INT_RECORD1, EMPTY_RECORD1),\n      new ReaderWriter(A_INT_B_DINT_RECORD1, EMPTY_RECORD1),\n\n      new ReaderWriter(INT_LIST_RECORD, LONG_LIST_RECORD),\n\n      // Last check:\n      new ReaderWriter(NULL_SCHEMA, INT_SCHEMA)\n  );", "modifier": "public static final", "type": "List<ReaderWriter>", "declarator": "INCOMPATIBLE_READER_WRITER_TEST_CASES = ImmutableList.of(\n      new ReaderWriter(NULL_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(NULL_SCHEMA, LONG_SCHEMA),\n\n      new ReaderWriter(BOOLEAN_SCHEMA, INT_SCHEMA),\n\n      new ReaderWriter(INT_SCHEMA, NULL_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, BOOLEAN_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, LONG_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, FLOAT_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, DOUBLE_SCHEMA),\n\n      new ReaderWriter(LONG_SCHEMA, FLOAT_SCHEMA),\n      new ReaderWriter(LONG_SCHEMA, DOUBLE_SCHEMA),\n\n      new ReaderWriter(FLOAT_SCHEMA, DOUBLE_SCHEMA),\n\n      new ReaderWriter(STRING_SCHEMA, BOOLEAN_SCHEMA),\n      new ReaderWriter(STRING_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(STRING_SCHEMA, BYTES_SCHEMA),\n\n      new ReaderWriter(BYTES_SCHEMA, NULL_SCHEMA),\n      new ReaderWriter(BYTES_SCHEMA, INT_SCHEMA),\n      new ReaderWriter(BYTES_SCHEMA, STRING_SCHEMA),\n\n      new ReaderWriter(INT_ARRAY_SCHEMA, LONG_ARRAY_SCHEMA),\n      new ReaderWriter(INT_MAP_SCHEMA, INT_ARRAY_SCHEMA),\n      new ReaderWriter(INT_ARRAY_SCHEMA, INT_MAP_SCHEMA),\n      new ReaderWriter(INT_MAP_SCHEMA, LONG_MAP_SCHEMA),\n\n      new ReaderWriter(ENUM1_AB_SCHEMA, ENUM1_ABC_SCHEMA),\n      new ReaderWriter(ENUM1_BC_SCHEMA, ENUM1_ABC_SCHEMA),\n\n      new ReaderWriter(ENUM1_AB_SCHEMA, ENUM2_AB_SCHEMA),\n      new ReaderWriter(INT_SCHEMA, ENUM2_AB_SCHEMA),\n      new ReaderWriter(ENUM2_AB_SCHEMA, INT_SCHEMA),\n\n      // Tests involving unions:\n      new ReaderWriter(INT_UNION_SCHEMA, INT_STRING_UNION_SCHEMA),\n      new ReaderWriter(STRING_UNION_SCHEMA, INT_STRING_UNION_SCHEMA),\n\n      new ReaderWriter(EMPTY_RECORD2, EMPTY_RECORD1),\n      new ReaderWriter(A_INT_RECORD1, EMPTY_RECORD1),\n      new ReaderWriter(A_INT_B_DINT_RECORD1, EMPTY_RECORD1),\n\n      new ReaderWriter(INT_LIST_RECORD, LONG_LIST_RECORD),\n\n      // Last check:\n      new ReaderWriter(NULL_SCHEMA, INT_SCHEMA)\n  )", "var_name": "INCOMPATIBLE_READER_WRITER_TEST_CASES"}, {"original_string": "public static final List<DecodingTestCase> DECODING_COMPATIBILITY_TEST_CASES = ImmutableList.of(\n      new DecodingTestCase(INT_SCHEMA, 1, INT_SCHEMA, 1),\n      new DecodingTestCase(INT_SCHEMA, 1, LONG_SCHEMA, 1L),\n      new DecodingTestCase(INT_SCHEMA, 1, FLOAT_SCHEMA, 1.0f),\n      new DecodingTestCase(INT_SCHEMA, 1, DOUBLE_SCHEMA, 1.0d),\n\n      // This is currently accepted but causes a precision loss:\n      // IEEE 754 floats have 24 bits signed mantissa\n      new DecodingTestCase(INT_SCHEMA, (1 << 24) + 1, FLOAT_SCHEMA, (float) ((1 << 24) + 1)),\n\n      // new DecodingTestCase(LONG_SCHEMA, 1L, INT_SCHEMA, 1),  // should work in best-effort!\n\n      new DecodingTestCase(\n          ENUM1_AB_SCHEMA, \"A\",\n          ENUM1_ABC_SCHEMA, new EnumSymbol(ENUM1_ABC_SCHEMA, \"A\")),\n\n      new DecodingTestCase(\n          ENUM1_ABC_SCHEMA, \"A\",\n          ENUM1_AB_SCHEMA, new EnumSymbol(ENUM1_AB_SCHEMA, \"A\")),\n\n      new DecodingTestCase(\n          ENUM1_ABC_SCHEMA, \"B\",\n          ENUM1_BC_SCHEMA, new EnumSymbol(ENUM1_BC_SCHEMA, \"B\")),\n\n      new DecodingTestCase(\n          INT_STRING_UNION_SCHEMA, \"the string\",\n          STRING_SCHEMA, new Utf8(\"the string\")),\n\n      new DecodingTestCase(\n          INT_STRING_UNION_SCHEMA, \"the string\",\n          STRING_UNION_SCHEMA, new Utf8(\"the string\"))\n);", "modifier": "public static final", "type": "List<DecodingTestCase>", "declarator": "DECODING_COMPATIBILITY_TEST_CASES = ImmutableList.of(\n      new DecodingTestCase(INT_SCHEMA, 1, INT_SCHEMA, 1),\n      new DecodingTestCase(INT_SCHEMA, 1, LONG_SCHEMA, 1L),\n      new DecodingTestCase(INT_SCHEMA, 1, FLOAT_SCHEMA, 1.0f),\n      new DecodingTestCase(INT_SCHEMA, 1, DOUBLE_SCHEMA, 1.0d),\n\n      // This is currently accepted but causes a precision loss:\n      // IEEE 754 floats have 24 bits signed mantissa\n      new DecodingTestCase(INT_SCHEMA, (1 << 24) + 1, FLOAT_SCHEMA, (float) ((1 << 24) + 1)),\n\n      // new DecodingTestCase(LONG_SCHEMA, 1L, INT_SCHEMA, 1),  // should work in best-effort!\n\n      new DecodingTestCase(\n          ENUM1_AB_SCHEMA, \"A\",\n          ENUM1_ABC_SCHEMA, new EnumSymbol(ENUM1_ABC_SCHEMA, \"A\")),\n\n      new DecodingTestCase(\n          ENUM1_ABC_SCHEMA, \"A\",\n          ENUM1_AB_SCHEMA, new EnumSymbol(ENUM1_AB_SCHEMA, \"A\")),\n\n      new DecodingTestCase(\n          ENUM1_ABC_SCHEMA, \"B\",\n          ENUM1_BC_SCHEMA, new EnumSymbol(ENUM1_BC_SCHEMA, \"B\")),\n\n      new DecodingTestCase(\n          INT_STRING_UNION_SCHEMA, \"the string\",\n          STRING_SCHEMA, new Utf8(\"the string\")),\n\n      new DecodingTestCase(\n          INT_STRING_UNION_SCHEMA, \"the string\",\n          STRING_UNION_SCHEMA, new Utf8(\"the string\"))\n)", "var_name": "DECODING_COMPATIBILITY_TEST_CASES"}], "file": "kiji-schema/src/test/java/org/kiji/schema/util/TestAvroUtils.java"}, "test_case": {"identifier": "testGetOptionalType", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testGetOptionalType() throws Exception {\n    final List<Schema> unionSchemas = Lists.newArrayList(\n        INT_SCHEMA,\n        NULL_SCHEMA);\n    final Schema optionalSchema = Schema.createUnion(unionSchemas);\n    final Schema optionalReverseSchema = Schema.createUnion(Lists.reverse(unionSchemas));\n\n    // Ensure that the optional type is retrievable.\n    assertEquals(INT_SCHEMA, AvroUtils.getOptionalType(optionalSchema));\n    assertEquals(INT_SCHEMA, AvroUtils.getOptionalType(optionalReverseSchema));\n  }", "signature": "void testGetOptionalType()", "full_signature": "@Test public void testGetOptionalType()", "class_method_signature": "TestAvroUtils.testGetOptionalType()", "testcase": true, "constructor": false, "invocations": ["newArrayList", "createUnion", "createUnion", "reverse", "assertEquals", "getOptionalType", "assertEquals", "getOptionalType"]}, "focal_class": {"identifier": "AvroUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(AvroUtils.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(AvroUtils.class)", "var_name": "LOG"}, {"original_string": "public static final String READER_WRITER_COMPATIBLE_MESSAGE =\n      \"Reader schema can always successfully decode data written using the writer schema.\";", "modifier": "public static final", "type": "String", "declarator": "READER_WRITER_COMPATIBLE_MESSAGE =\n      \"Reader schema can always successfully decode data written using the writer schema.\"", "var_name": "READER_WRITER_COMPATIBLE_MESSAGE"}], "methods": [{"identifier": "AvroUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " AvroUtils()", "full_signature": "private  AvroUtils()", "class_method_signature": "AvroUtils.AvroUtils()", "testcase": false, "constructor": true}, {"identifier": "avroSchemaEquals", "parameters": "(\n      final KijiSchemaTable schemaTable,\n      final AvroSchema first,\n      final AvroSchema second\n  )", "modifiers": "public static", "return": "boolean", "signature": "boolean avroSchemaEquals(\n      final KijiSchemaTable schemaTable,\n      final AvroSchema first,\n      final AvroSchema second\n  )", "full_signature": "public static boolean avroSchemaEquals(\n      final KijiSchemaTable schemaTable,\n      final AvroSchema first,\n      final AvroSchema second\n  )", "class_method_signature": "AvroUtils.avroSchemaEquals(\n      final KijiSchemaTable schemaTable,\n      final AvroSchema first,\n      final AvroSchema second\n  )", "testcase": false, "constructor": false}, {"identifier": "avroSchemaCollectionContains", "parameters": "(\n      final KijiSchemaTable schemaTable,\n      final Collection<AvroSchema> schemaCollection,\n      final AvroSchema element\n  )", "modifiers": "public static", "return": "boolean", "signature": "boolean avroSchemaCollectionContains(\n      final KijiSchemaTable schemaTable,\n      final Collection<AvroSchema> schemaCollection,\n      final AvroSchema element\n  )", "full_signature": "public static boolean avroSchemaCollectionContains(\n      final KijiSchemaTable schemaTable,\n      final Collection<AvroSchema> schemaCollection,\n      final AvroSchema element\n  )", "class_method_signature": "AvroUtils.avroSchemaCollectionContains(\n      final KijiSchemaTable schemaTable,\n      final Collection<AvroSchema> schemaCollection,\n      final AvroSchema element\n  )", "testcase": false, "constructor": false}, {"identifier": "getOptionalType", "parameters": "(Schema schema)", "modifiers": "public static", "return": "Schema", "signature": "Schema getOptionalType(Schema schema)", "full_signature": "public static Schema getOptionalType(Schema schema)", "class_method_signature": "AvroUtils.getOptionalType(Schema schema)", "testcase": false, "constructor": false}, {"identifier": "checkWriterCompatibility", "parameters": "(\n      Iterator<Schema> readers,\n      Schema writer)", "modifiers": "public static", "return": "SchemaSetCompatibility", "signature": "SchemaSetCompatibility checkWriterCompatibility(\n      Iterator<Schema> readers,\n      Schema writer)", "full_signature": "public static SchemaSetCompatibility checkWriterCompatibility(\n      Iterator<Schema> readers,\n      Schema writer)", "class_method_signature": "AvroUtils.checkWriterCompatibility(\n      Iterator<Schema> readers,\n      Schema writer)", "testcase": false, "constructor": false}, {"identifier": "checkReaderCompatibility", "parameters": "(\n      Schema reader,\n      Iterator<Schema> writers)", "modifiers": "public static", "return": "SchemaSetCompatibility", "signature": "SchemaSetCompatibility checkReaderCompatibility(\n      Schema reader,\n      Iterator<Schema> writers)", "full_signature": "public static SchemaSetCompatibility checkReaderCompatibility(\n      Schema reader,\n      Iterator<Schema> writers)", "class_method_signature": "AvroUtils.checkReaderCompatibility(\n      Schema reader,\n      Iterator<Schema> writers)", "testcase": false, "constructor": false}, {"identifier": "checkReaderWriterCompatibility", "parameters": "(\n      final Schema reader,\n      final Schema writer\n  )", "modifiers": "public static", "return": "SchemaPairCompatibility", "signature": "SchemaPairCompatibility checkReaderWriterCompatibility(\n      final Schema reader,\n      final Schema writer\n  )", "full_signature": "public static SchemaPairCompatibility checkReaderWriterCompatibility(\n      final Schema reader,\n      final Schema writer\n  )", "class_method_signature": "AvroUtils.checkReaderWriterCompatibility(\n      final Schema reader,\n      final Schema writer\n  )", "testcase": false, "constructor": false}, {"identifier": "schemaNameEquals", "parameters": "(final Schema reader, final Schema writer)", "modifiers": "public static", "return": "boolean", "signature": "boolean schemaNameEquals(final Schema reader, final Schema writer)", "full_signature": "public static boolean schemaNameEquals(final Schema reader, final Schema writer)", "class_method_signature": "AvroUtils.schemaNameEquals(final Schema reader, final Schema writer)", "testcase": false, "constructor": false}, {"identifier": "lookupWriterField", "parameters": "(final Schema writerSchema, final Field readerField)", "modifiers": "public static", "return": "Field", "signature": "Field lookupWriterField(final Schema writerSchema, final Field readerField)", "full_signature": "public static Field lookupWriterField(final Schema writerSchema, final Field readerField)", "class_method_signature": "AvroUtils.lookupWriterField(final Schema writerSchema, final Field readerField)", "testcase": false, "constructor": false}], "file": "kiji-schema/src/main/java/org/kiji/schema/util/AvroUtils.java"}, "focal_method": {"identifier": "getOptionalType", "parameters": "(Schema schema)", "modifiers": "public static", "return": "Schema", "body": "public static Schema getOptionalType(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == Schema.Type.UNION);\n    final List<Schema> types = schema.getTypes();\n    if (types.size() != 2) {\n      return null;\n    }\n    if (types.get(0).getType() == Schema.Type.NULL) {\n      return types.get(1);\n    } else if (types.get(1).getType() == Schema.Type.NULL) {\n      return types.get(0);\n    } else {\n      return null;\n    }\n  }", "signature": "Schema getOptionalType(Schema schema)", "full_signature": "public static Schema getOptionalType(Schema schema)", "class_method_signature": "AvroUtils.getOptionalType(Schema schema)", "testcase": false, "constructor": false, "invocations": ["checkArgument", "getType", "getTypes", "size", "getType", "get", "get", "getType", "get", "get"]}, "repository": {"repo_id": 6682280, "url": "https://github.com/kijiproject/kiji-schema", "language": "Java", "is_fork": false, "fork_count": 44, "stargazer_count": 55, "size": 11689, "license": "licensed"}}