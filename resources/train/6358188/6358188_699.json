{"test_class": {"identifier": "HashTableUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "processing/src/test/java/org/apache/druid/query/groupby/epinephelinae/collection/HashTableUtilsTest.java"}, "test_case": {"identifier": "test_hashMemory_allByteLengthsUpTo128", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void test_hashMemory_allByteLengthsUpTo128()\n  {\n    // This test validates that we *can* hash any amount of memory up to 128 bytes, and that if any bit is flipped\n    // in the memory then the hash changes. It doesn't validate that the hash function is actually good at dispersion.\n    // That also has a big impact on performance and needs to be checked separately if the hash function is changed.\n\n    final int maxBytes = 128;\n    final WritableMemory randomMemory = generateRandomButNotReallyRandomMemory(maxBytes);\n\n    for (int numBytes = 0; numBytes < maxBytes; numBytes++) {\n      // Grab \"numBytes\" bytes from the end of randomMemory.\n      final Memory regionToHash = randomMemory.region(maxBytes - numBytes, numBytes);\n\n      // Validate that hashing regionAtEnd is equivalent to hashing the end of a region. This helps validate\n      // that using a nonzero position is effective.\n      Assert.assertEquals(\n          StringUtils.format(\"numBytes[%s] nonzero position check\", numBytes),\n          HashTableUtils.hashMemory(regionToHash, 0, numBytes),\n          HashTableUtils.hashMemory(randomMemory, maxBytes - numBytes, numBytes)\n      );\n\n      // Copy the memory and make sure we did it right.\n      final WritableMemory copyOfRegion = WritableMemory.allocate(numBytes);\n      regionToHash.copyTo(0, copyOfRegion, 0, numBytes);\n      Assert.assertTrue(\n          StringUtils.format(\"numBytes[%s] copy equality check\", numBytes),\n          regionToHash.equalTo(0, copyOfRegion, 0, numBytes)\n      );\n\n      // Validate that flipping any bit affects the hash.\n      for (int bit = 0; bit < numBytes * Byte.SIZE; bit++) {\n        final int bytePosition = bit / Byte.SIZE;\n        final byte mask = (byte) (1 << (bit % Byte.SIZE));\n\n        copyOfRegion.putByte(\n            bytePosition,\n            (byte) (copyOfRegion.getByte(bytePosition) ^ mask)\n        );\n\n        Assert.assertNotEquals(\n            StringUtils.format(\"numBytes[%s] bit[%s] flip check\", numBytes, bit),\n            HashTableUtils.hashMemory(regionToHash, 0, numBytes),\n            HashTableUtils.hashMemory(copyOfRegion, 0, numBytes)\n        );\n\n        // Set it back and make sure we did it right.\n        copyOfRegion.putByte(\n            bytePosition,\n            (byte) (copyOfRegion.getByte(bytePosition) ^ mask)\n        );\n\n        Assert.assertTrue(\n            StringUtils.format(\"numBytes[%s] bit[%s] reset check\", numBytes, bit),\n            regionToHash.equalTo(0, copyOfRegion, 0, numBytes)\n        );\n      }\n    }\n  }", "signature": "void test_hashMemory_allByteLengthsUpTo128()", "full_signature": "@Test public void test_hashMemory_allByteLengthsUpTo128()", "class_method_signature": "HashTableUtilsTest.test_hashMemory_allByteLengthsUpTo128()", "testcase": true, "constructor": false, "invocations": ["generateRandomButNotReallyRandomMemory", "region", "assertEquals", "format", "hashMemory", "hashMemory", "allocate", "copyTo", "assertTrue", "format", "equalTo", "putByte", "getByte", "assertNotEquals", "format", "hashMemory", "hashMemory", "putByte", "getByte", "assertTrue", "format", "equalTo"]}, "focal_class": {"identifier": "HashTableUtils", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "HashTableUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " HashTableUtils()", "full_signature": "private  HashTableUtils()", "class_method_signature": "HashTableUtils.HashTableUtils()", "testcase": false, "constructor": true}, {"identifier": "previousPowerOfTwo", "parameters": "(final int n)", "modifiers": "public static", "return": "int", "signature": "int previousPowerOfTwo(final int n)", "full_signature": "public static int previousPowerOfTwo(final int n)", "class_method_signature": "HashTableUtils.previousPowerOfTwo(final int n)", "testcase": false, "constructor": false}, {"identifier": "hashMemory", "parameters": "(final Memory memory, final long position, final int length)", "modifiers": "public static", "return": "int", "signature": "int hashMemory(final Memory memory, final long position, final int length)", "full_signature": "public static int hashMemory(final Memory memory, final long position, final int length)", "class_method_signature": "HashTableUtils.hashMemory(final Memory memory, final long position, final int length)", "testcase": false, "constructor": false}, {"identifier": "memoryEquals", "parameters": "(\n      final Memory memory1,\n      final long offset1,\n      final Memory memory2,\n      final long offset2,\n      final int length\n  )", "modifiers": "public static", "return": "boolean", "signature": "boolean memoryEquals(\n      final Memory memory1,\n      final long offset1,\n      final Memory memory2,\n      final long offset2,\n      final int length\n  )", "full_signature": "public static boolean memoryEquals(\n      final Memory memory1,\n      final long offset1,\n      final Memory memory2,\n      final long offset2,\n      final int length\n  )", "class_method_signature": "HashTableUtils.memoryEquals(\n      final Memory memory1,\n      final long offset1,\n      final Memory memory2,\n      final long offset2,\n      final int length\n  )", "testcase": false, "constructor": false}], "file": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/collection/HashTableUtils.java"}, "focal_method": {"identifier": "hashMemory", "parameters": "(final Memory memory, final long position, final int length)", "modifiers": "public static", "return": "int", "body": "public static int hashMemory(final Memory memory, final long position, final int length)\n  {\n    // Special cases for small, common key sizes to speed them up: e.g. one int key, two int keys, one long key, etc.\n    // The plus-one sizes (9, 13) are for nullable dimensions. The specific choices of special cases were chosen based\n    // on benchmarking (see MemoryBenchmark) on a Skylake-based cloud instance.\n\n    switch (length) {\n      case 4:\n        return memory.getInt(position);\n\n      case 8:\n        return 31 * (31 + memory.getInt(position)) + memory.getInt(position + Integer.BYTES);\n\n      case 9:\n        return 31 * (31 * (31 + memory.getInt(position)) + memory.getInt(position + Integer.BYTES))\n               + memory.getByte(position + 2L * Integer.BYTES);\n\n      case 12:\n        return 31 * (31 * (31 + memory.getInt(position)) + memory.getInt(position + Integer.BYTES))\n               + memory.getInt(position + 2L * Integer.BYTES);\n\n      case 13:\n        return 31 * (31 * (31 * (31 + memory.getInt(position)) + memory.getInt(position + Integer.BYTES))\n                     + memory.getInt(position + 2L * Integer.BYTES)) + memory.getByte(position + 3L * Integer.BYTES);\n\n      case 16:\n        return 31 * (31 * (31 * (31 + memory.getInt(position)) + memory.getInt(position + Integer.BYTES))\n                     + memory.getInt(position + 2L * Integer.BYTES)) + memory.getInt(position + 3L * Integer.BYTES);\n\n      default:\n        int hashCode = 1;\n        int remainingBytes = length;\n        long pos = position;\n\n        while (remainingBytes >= Integer.BYTES) {\n          hashCode = 31 * hashCode + memory.getInt(pos);\n          remainingBytes -= Integer.BYTES;\n          pos += Integer.BYTES;\n        }\n\n        if (remainingBytes == 1) {\n          hashCode = 31 * hashCode + memory.getByte(pos);\n        } else if (remainingBytes == 2) {\n          hashCode = 31 * hashCode + memory.getByte(pos);\n          hashCode = 31 * hashCode + memory.getByte(pos + 1);\n        } else if (remainingBytes == 3) {\n          hashCode = 31 * hashCode + memory.getByte(pos);\n          hashCode = 31 * hashCode + memory.getByte(pos + 1);\n          hashCode = 31 * hashCode + memory.getByte(pos + 2);\n        }\n\n        return hashCode;\n    }\n  }", "signature": "int hashMemory(final Memory memory, final long position, final int length)", "full_signature": "public static int hashMemory(final Memory memory, final long position, final int length)", "class_method_signature": "HashTableUtils.hashMemory(final Memory memory, final long position, final int length)", "testcase": false, "constructor": false, "invocations": ["getInt", "getInt", "getInt", "getInt", "getInt", "getByte", "getInt", "getInt", "getInt", "getInt", "getInt", "getInt", "getByte", "getInt", "getInt", "getInt", "getInt", "getInt", "getByte", "getByte", "getByte", "getByte", "getByte", "getByte"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}