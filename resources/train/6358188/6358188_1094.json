{"test_class": {"identifier": "IncrementalIndexStorageAdapterTest", "superclass": "extends InitializedNullHandlingTest", "interfaces": "", "fields": [{"original_string": "private final IndexCreator indexCreator;", "modifier": "private final", "type": "IndexCreator", "declarator": "indexCreator", "var_name": "indexCreator"}], "file": "processing/src/test/java/org/apache/druid/segment/incremental/IncrementalIndexStorageAdapterTest.java"}, "test_case": {"identifier": "testCursoringAndIndexUpdationInterleaving", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testCursoringAndIndexUpdationInterleaving() throws Exception\n  {\n    final IncrementalIndex index = indexCreator.createIndex();\n    final long timestamp = System.currentTimeMillis();\n\n    for (int i = 0; i < 2; i++) {\n      index.add(\n          new MapBasedInputRow(\n              timestamp,\n              Collections.singletonList(\"billy\"),\n              ImmutableMap.of(\"billy\", \"v1\" + i)\n          )\n      );\n    }\n\n    final StorageAdapter sa = new IncrementalIndexStorageAdapter(index);\n\n    Sequence<Cursor> cursors = sa.makeCursors(\n        null,\n        Intervals.utc(timestamp - 60_000, timestamp + 60_000),\n        VirtualColumns.EMPTY,\n        Granularities.ALL,\n        false,\n        null\n    );\n    final AtomicInteger assertCursorsNotEmpty = new AtomicInteger(0);\n\n    cursors\n        .map(cursor -> {\n          DimensionSelector dimSelector = cursor\n              .getColumnSelectorFactory()\n              .makeDimensionSelector(new DefaultDimensionSpec(\"billy\", \"billy\"));\n          int cardinality = dimSelector.getValueCardinality();\n\n          //index gets more rows at this point, while other thread is iterating over the cursor\n          try {\n            for (int i = 0; i < 1; i++) {\n              index.add(new MapBasedInputRow(timestamp, Collections.singletonList(\"billy\"), ImmutableMap.of(\"billy\", \"v2\" + i)));\n            }\n          }\n          catch (Exception ex) {\n            throw new RuntimeException(ex);\n          }\n\n          int rowNumInCursor = 0;\n          // and then, cursoring continues in the other thread\n          while (!cursor.isDone()) {\n            IndexedInts row = dimSelector.getRow();\n            row.forEach(i -> Assert.assertTrue(i < cardinality));\n            cursor.advance();\n            rowNumInCursor++;\n          }\n          Assert.assertEquals(2, rowNumInCursor);\n          assertCursorsNotEmpty.incrementAndGet();\n\n          return null;\n        })\n        .toList();\n    Assert.assertEquals(1, assertCursorsNotEmpty.get());\n  }", "signature": "void testCursoringAndIndexUpdationInterleaving()", "full_signature": "@Test public void testCursoringAndIndexUpdationInterleaving()", "class_method_signature": "IncrementalIndexStorageAdapterTest.testCursoringAndIndexUpdationInterleaving()", "testcase": true, "constructor": false, "invocations": ["createIndex", "currentTimeMillis", "add", "singletonList", "of", "makeCursors", "utc", "toList", "map", "makeDimensionSelector", "getColumnSelectorFactory", "getValueCardinality", "add", "singletonList", "of", "isDone", "getRow", "forEach", "assertTrue", "advance", "assertEquals", "incrementAndGet", "assertEquals", "get"]}, "focal_class": {"identifier": "IncrementalIndexStorageAdapter", "superclass": "", "interfaces": "implements StorageAdapter", "fields": [{"original_string": "private static final ColumnCapabilities.CoercionLogic STORAGE_ADAPTER_CAPABILITIES_COERCE_LOGIC =\n      new ColumnCapabilities.CoercionLogic()\n      {\n        @Override\n        public boolean dictionaryEncoded()\n        {\n          return false;\n        }\n\n        @Override\n        public boolean dictionaryValuesSorted()\n        {\n          return false;\n        }\n\n        @Override\n        public boolean dictionaryValuesUnique()\n        {\n          return true;\n        }\n\n        @Override\n        public boolean multipleValues()\n        {\n          return true;\n        }\n\n        @Override\n        public boolean hasNulls()\n        {\n          return true;\n        }\n      };", "modifier": "private static final", "type": "ColumnCapabilities.CoercionLogic", "declarator": "STORAGE_ADAPTER_CAPABILITIES_COERCE_LOGIC =\n      new ColumnCapabilities.CoercionLogic()\n      {\n        @Override\n        public boolean dictionaryEncoded()\n        {\n          return false;\n        }\n\n        @Override\n        public boolean dictionaryValuesSorted()\n        {\n          return false;\n        }\n\n        @Override\n        public boolean dictionaryValuesUnique()\n        {\n          return true;\n        }\n\n        @Override\n        public boolean multipleValues()\n        {\n          return true;\n        }\n\n        @Override\n        public boolean hasNulls()\n        {\n          return true;\n        }\n      }", "var_name": "STORAGE_ADAPTER_CAPABILITIES_COERCE_LOGIC"}, {"original_string": "private static final ColumnCapabilities.CoercionLogic SNAPSHOT_STORAGE_ADAPTER_CAPABILITIES_COERCE_LOGIC =\n      new ColumnCapabilities.CoercionLogic()\n      {\n        @Override\n        public boolean dictionaryEncoded()\n        {\n          return true;\n        }\n\n        @Override\n        public boolean dictionaryValuesSorted()\n        {\n          return true;\n        }\n\n        @Override\n        public boolean dictionaryValuesUnique()\n        {\n          return true;\n        }\n\n        @Override\n        public boolean multipleValues()\n        {\n          return false;\n        }\n\n        @Override\n        public boolean hasNulls()\n        {\n          return false;\n        }\n      };", "modifier": "private static final", "type": "ColumnCapabilities.CoercionLogic", "declarator": "SNAPSHOT_STORAGE_ADAPTER_CAPABILITIES_COERCE_LOGIC =\n      new ColumnCapabilities.CoercionLogic()\n      {\n        @Override\n        public boolean dictionaryEncoded()\n        {\n          return true;\n        }\n\n        @Override\n        public boolean dictionaryValuesSorted()\n        {\n          return true;\n        }\n\n        @Override\n        public boolean dictionaryValuesUnique()\n        {\n          return true;\n        }\n\n        @Override\n        public boolean multipleValues()\n        {\n          return false;\n        }\n\n        @Override\n        public boolean hasNulls()\n        {\n          return false;\n        }\n      }", "var_name": "SNAPSHOT_STORAGE_ADAPTER_CAPABILITIES_COERCE_LOGIC"}, {"original_string": "final IncrementalIndex<?> index;", "modifier": "final", "type": "IncrementalIndex<?>", "declarator": "index", "var_name": "index"}], "methods": [{"identifier": "IncrementalIndexStorageAdapter", "parameters": "(IncrementalIndex<?> index)", "modifiers": "public", "return": "", "signature": " IncrementalIndexStorageAdapter(IncrementalIndex<?> index)", "full_signature": "public  IncrementalIndexStorageAdapter(IncrementalIndex<?> index)", "class_method_signature": "IncrementalIndexStorageAdapter.IncrementalIndexStorageAdapter(IncrementalIndex<?> index)", "testcase": false, "constructor": true}, {"identifier": "getInterval", "parameters": "()", "modifiers": "@Override public", "return": "Interval", "signature": "Interval getInterval()", "full_signature": "@Override public Interval getInterval()", "class_method_signature": "IncrementalIndexStorageAdapter.getInterval()", "testcase": false, "constructor": false}, {"identifier": "getAvailableDimensions", "parameters": "()", "modifiers": "@Override public", "return": "Indexed<String>", "signature": "Indexed<String> getAvailableDimensions()", "full_signature": "@Override public Indexed<String> getAvailableDimensions()", "class_method_signature": "IncrementalIndexStorageAdapter.getAvailableDimensions()", "testcase": false, "constructor": false}, {"identifier": "getAvailableMetrics", "parameters": "()", "modifiers": "@Override public", "return": "Iterable<String>", "signature": "Iterable<String> getAvailableMetrics()", "full_signature": "@Override public Iterable<String> getAvailableMetrics()", "class_method_signature": "IncrementalIndexStorageAdapter.getAvailableMetrics()", "testcase": false, "constructor": false}, {"identifier": "getDimensionCardinality", "parameters": "(String dimension)", "modifiers": "@Override public", "return": "int", "signature": "int getDimensionCardinality(String dimension)", "full_signature": "@Override public int getDimensionCardinality(String dimension)", "class_method_signature": "IncrementalIndexStorageAdapter.getDimensionCardinality(String dimension)", "testcase": false, "constructor": false}, {"identifier": "getNumRows", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getNumRows()", "full_signature": "@Override public int getNumRows()", "class_method_signature": "IncrementalIndexStorageAdapter.getNumRows()", "testcase": false, "constructor": false}, {"identifier": "getMinTime", "parameters": "()", "modifiers": "@Override public", "return": "DateTime", "signature": "DateTime getMinTime()", "full_signature": "@Override public DateTime getMinTime()", "class_method_signature": "IncrementalIndexStorageAdapter.getMinTime()", "testcase": false, "constructor": false}, {"identifier": "getMaxTime", "parameters": "()", "modifiers": "@Override public", "return": "DateTime", "signature": "DateTime getMaxTime()", "full_signature": "@Override public DateTime getMaxTime()", "class_method_signature": "IncrementalIndexStorageAdapter.getMaxTime()", "testcase": false, "constructor": false}, {"identifier": "getMinValue", "parameters": "(String column)", "modifiers": "@Nullable @Override public", "return": "Comparable", "signature": "Comparable getMinValue(String column)", "full_signature": "@Nullable @Override public Comparable getMinValue(String column)", "class_method_signature": "IncrementalIndexStorageAdapter.getMinValue(String column)", "testcase": false, "constructor": false}, {"identifier": "getMaxValue", "parameters": "(String column)", "modifiers": "@Nullable @Override public", "return": "Comparable", "signature": "Comparable getMaxValue(String column)", "full_signature": "@Nullable @Override public Comparable getMaxValue(String column)", "class_method_signature": "IncrementalIndexStorageAdapter.getMaxValue(String column)", "testcase": false, "constructor": false}, {"identifier": "getColumnCapabilities", "parameters": "(String column)", "modifiers": "@Override public", "return": "ColumnCapabilities", "signature": "ColumnCapabilities getColumnCapabilities(String column)", "full_signature": "@Override public ColumnCapabilities getColumnCapabilities(String column)", "class_method_signature": "IncrementalIndexStorageAdapter.getColumnCapabilities(String column)", "testcase": false, "constructor": false}, {"identifier": "getSnapshotColumnCapabilities", "parameters": "(String column)", "modifiers": "public", "return": "ColumnCapabilities", "signature": "ColumnCapabilities getSnapshotColumnCapabilities(String column)", "full_signature": "public ColumnCapabilities getSnapshotColumnCapabilities(String column)", "class_method_signature": "IncrementalIndexStorageAdapter.getSnapshotColumnCapabilities(String column)", "testcase": false, "constructor": false}, {"identifier": "getColumnTypeName", "parameters": "(String column)", "modifiers": "@Override public", "return": "String", "signature": "String getColumnTypeName(String column)", "full_signature": "@Override public String getColumnTypeName(String column)", "class_method_signature": "IncrementalIndexStorageAdapter.getColumnTypeName(String column)", "testcase": false, "constructor": false}, {"identifier": "getMaxIngestedEventTime", "parameters": "()", "modifiers": "@Override public", "return": "DateTime", "signature": "DateTime getMaxIngestedEventTime()", "full_signature": "@Override public DateTime getMaxIngestedEventTime()", "class_method_signature": "IncrementalIndexStorageAdapter.getMaxIngestedEventTime()", "testcase": false, "constructor": false}, {"identifier": "makeCursors", "parameters": "(\n      @Nullable final Filter filter,\n      final Interval interval,\n      final VirtualColumns virtualColumns,\n      final Granularity gran,\n      final boolean descending,\n      @Nullable QueryMetrics<?> queryMetrics\n  )", "modifiers": "@Override public", "return": "Sequence<Cursor>", "signature": "Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      final Interval interval,\n      final VirtualColumns virtualColumns,\n      final Granularity gran,\n      final boolean descending,\n      @Nullable QueryMetrics<?> queryMetrics\n  )", "full_signature": "@Override public Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      final Interval interval,\n      final VirtualColumns virtualColumns,\n      final Granularity gran,\n      final boolean descending,\n      @Nullable QueryMetrics<?> queryMetrics\n  )", "class_method_signature": "IncrementalIndexStorageAdapter.makeCursors(\n      @Nullable final Filter filter,\n      final Interval interval,\n      final VirtualColumns virtualColumns,\n      final Granularity gran,\n      final boolean descending,\n      @Nullable QueryMetrics<?> queryMetrics\n  )", "testcase": false, "constructor": false}, {"identifier": "getMetadata", "parameters": "()", "modifiers": "@Override public", "return": "Metadata", "signature": "Metadata getMetadata()", "full_signature": "@Override public Metadata getMetadata()", "class_method_signature": "IncrementalIndexStorageAdapter.getMetadata()", "testcase": false, "constructor": false}], "file": "processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndexStorageAdapter.java"}, "focal_method": {"identifier": "makeCursors", "parameters": "(\n      @Nullable final Filter filter,\n      final Interval interval,\n      final VirtualColumns virtualColumns,\n      final Granularity gran,\n      final boolean descending,\n      @Nullable QueryMetrics<?> queryMetrics\n  )", "modifiers": "@Override public", "return": "Sequence<Cursor>", "body": "@Override\n  public Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      final Interval interval,\n      final VirtualColumns virtualColumns,\n      final Granularity gran,\n      final boolean descending,\n      @Nullable QueryMetrics<?> queryMetrics\n  )\n  {\n    if (index.isEmpty()) {\n      return Sequences.empty();\n    }\n\n    final Interval dataInterval = new Interval(getMinTime(), gran.bucketEnd(getMaxTime()));\n\n    if (!interval.overlaps(dataInterval)) {\n      return Sequences.empty();\n    }\n    final Interval actualInterval = interval.overlap(dataInterval);\n    Iterable<Interval> intervals = gran.getIterable(actualInterval);\n    if (descending) {\n      intervals = Lists.reverse(ImmutableList.copyOf(intervals));\n    }\n\n    return Sequences\n        .simple(intervals)\n        .map(i -> new IncrementalIndexCursor(virtualColumns, descending, filter, i, actualInterval, gran));\n  }", "signature": "Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      final Interval interval,\n      final VirtualColumns virtualColumns,\n      final Granularity gran,\n      final boolean descending,\n      @Nullable QueryMetrics<?> queryMetrics\n  )", "full_signature": "@Override public Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      final Interval interval,\n      final VirtualColumns virtualColumns,\n      final Granularity gran,\n      final boolean descending,\n      @Nullable QueryMetrics<?> queryMetrics\n  )", "class_method_signature": "IncrementalIndexStorageAdapter.makeCursors(\n      @Nullable final Filter filter,\n      final Interval interval,\n      final VirtualColumns virtualColumns,\n      final Granularity gran,\n      final boolean descending,\n      @Nullable QueryMetrics<?> queryMetrics\n  )", "testcase": false, "constructor": false, "invocations": ["isEmpty", "empty", "getMinTime", "bucketEnd", "getMaxTime", "overlaps", "empty", "overlap", "getIterable", "reverse", "copyOf", "map", "simple"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}