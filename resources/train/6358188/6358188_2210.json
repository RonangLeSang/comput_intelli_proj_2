{"test_class": {"identifier": "IndexerSQLMetadataStorageCoordinatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n  public final TestDerbyConnector.DerbyConnectorRule derbyConnectorRule = new TestDerbyConnector.DerbyConnectorRule();", "modifier": "@Rule\n  public final", "type": "TestDerbyConnector.DerbyConnectorRule", "declarator": "derbyConnectorRule = new TestDerbyConnector.DerbyConnectorRule()", "var_name": "derbyConnectorRule"}, {"original_string": "@Rule\n  public final ExpectedException expectedException = ExpectedException.none();", "modifier": "@Rule\n  public final", "type": "ExpectedException", "declarator": "expectedException = ExpectedException.none()", "var_name": "expectedException"}, {"original_string": "private final ObjectMapper mapper = TestHelper.makeJsonMapper();", "modifier": "private final", "type": "ObjectMapper", "declarator": "mapper = TestHelper.makeJsonMapper()", "var_name": "mapper"}, {"original_string": "private final DataSegment defaultSegment = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"version\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new LinearShardSpec(0),\n      9,\n      100\n  );", "modifier": "private final", "type": "DataSegment", "declarator": "defaultSegment = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"version\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new LinearShardSpec(0),\n      9,\n      100\n  )", "var_name": "defaultSegment"}, {"original_string": "private final DataSegment defaultSegment2 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"version\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new LinearShardSpec(1),\n      9,\n      100\n  );", "modifier": "private final", "type": "DataSegment", "declarator": "defaultSegment2 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"version\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new LinearShardSpec(1),\n      9,\n      100\n  )", "var_name": "defaultSegment2"}, {"original_string": "private final DataSegment defaultSegment3 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-03T00Z/2015-01-04T00Z\"),\n      \"version\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      NoneShardSpec.instance(),\n      9,\n      100\n  );", "modifier": "private final", "type": "DataSegment", "declarator": "defaultSegment3 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-03T00Z/2015-01-04T00Z\"),\n      \"version\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      NoneShardSpec.instance(),\n      9,\n      100\n  )", "var_name": "defaultSegment3"}, {"original_string": "private final DataSegment defaultSegment4 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new LinearShardSpec(0),\n      9,\n      100\n  );", "modifier": "private final", "type": "DataSegment", "declarator": "defaultSegment4 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new LinearShardSpec(0),\n      9,\n      100\n  )", "var_name": "defaultSegment4"}, {"original_string": "private final DataSegment numberedSegment0of0 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new NumberedShardSpec(0, 0),\n      9,\n      100\n  );", "modifier": "private final", "type": "DataSegment", "declarator": "numberedSegment0of0 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new NumberedShardSpec(0, 0),\n      9,\n      100\n  )", "var_name": "numberedSegment0of0"}, {"original_string": "private final DataSegment numberedSegment1of0 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new NumberedShardSpec(1, 0),\n      9,\n      100\n  );", "modifier": "private final", "type": "DataSegment", "declarator": "numberedSegment1of0 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new NumberedShardSpec(1, 0),\n      9,\n      100\n  )", "var_name": "numberedSegment1of0"}, {"original_string": "private final DataSegment numberedSegment2of0 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new NumberedShardSpec(2, 0),\n      9,\n      100\n  );", "modifier": "private final", "type": "DataSegment", "declarator": "numberedSegment2of0 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new NumberedShardSpec(2, 0),\n      9,\n      100\n  )", "var_name": "numberedSegment2of0"}, {"original_string": "private final DataSegment numberedSegment2of1 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new NumberedShardSpec(2, 1),\n      9,\n      100\n  );", "modifier": "private final", "type": "DataSegment", "declarator": "numberedSegment2of1 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new NumberedShardSpec(2, 1),\n      9,\n      100\n  )", "var_name": "numberedSegment2of1"}, {"original_string": "private final DataSegment numberedSegment3of1 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new NumberedShardSpec(3, 1),\n      9,\n      100\n  );", "modifier": "private final", "type": "DataSegment", "declarator": "numberedSegment3of1 = new DataSegment(\n      \"fooDataSource\",\n      Intervals.of(\"2015-01-01T00Z/2015-01-02T00Z\"),\n      \"zversion\",\n      ImmutableMap.of(),\n      ImmutableList.of(\"dim1\"),\n      ImmutableList.of(\"m1\"),\n      new NumberedShardSpec(3, 1),\n      9,\n      100\n  )", "var_name": "numberedSegment3of1"}, {"original_string": "private final Set<DataSegment> SEGMENTS = ImmutableSet.of(defaultSegment, defaultSegment2);", "modifier": "private final", "type": "Set<DataSegment>", "declarator": "SEGMENTS = ImmutableSet.of(defaultSegment, defaultSegment2)", "var_name": "SEGMENTS"}, {"original_string": "private final AtomicLong metadataUpdateCounter = new AtomicLong();", "modifier": "private final", "type": "AtomicLong", "declarator": "metadataUpdateCounter = new AtomicLong()", "var_name": "metadataUpdateCounter"}, {"original_string": "private IndexerSQLMetadataStorageCoordinator coordinator;", "modifier": "private", "type": "IndexerSQLMetadataStorageCoordinator", "declarator": "coordinator", "var_name": "coordinator"}, {"original_string": "private TestDerbyConnector derbyConnector;", "modifier": "private", "type": "TestDerbyConnector", "declarator": "derbyConnector", "var_name": "derbyConnector"}], "file": "server/src/test/java/org/apache/druid/metadata/IndexerSQLMetadataStorageCoordinatorTest.java"}, "test_case": {"identifier": "testDeleteDataSourceMetadata", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testDeleteDataSourceMetadata() throws IOException\n  {\n    coordinator.announceHistoricalSegments(\n        ImmutableSet.of(defaultSegment),\n        new ObjectMetadata(null),\n        new ObjectMetadata(ImmutableMap.of(\"foo\", \"bar\"))\n    );\n\n    Assert.assertEquals(\n        new ObjectMetadata(ImmutableMap.of(\"foo\", \"bar\")),\n        coordinator.retrieveDataSourceMetadata(\"fooDataSource\")\n    );\n\n    Assert.assertFalse(\"deleteInvalidDataSourceMetadata\", coordinator.deleteDataSourceMetadata(\"nonExistentDS\"));\n    Assert.assertTrue(\"deleteValidDataSourceMetadata\", coordinator.deleteDataSourceMetadata(\"fooDataSource\"));\n\n    Assert.assertNull(\"getDataSourceMetadataNullAfterDelete\", coordinator.retrieveDataSourceMetadata(\"fooDataSource\"));\n  }", "signature": "void testDeleteDataSourceMetadata()", "full_signature": "@Test public void testDeleteDataSourceMetadata()", "class_method_signature": "IndexerSQLMetadataStorageCoordinatorTest.testDeleteDataSourceMetadata()", "testcase": true, "constructor": false, "invocations": ["announceHistoricalSegments", "of", "of", "assertEquals", "of", "retrieveDataSourceMetadata", "assertFalse", "deleteDataSourceMetadata", "assertTrue", "deleteDataSourceMetadata", "assertNull", "retrieveDataSourceMetadata"]}, "focal_class": {"identifier": "IndexerSQLMetadataStorageCoordinator", "superclass": "", "interfaces": "implements IndexerMetadataStorageCoordinator", "fields": [{"original_string": "private static final Logger log = new Logger(IndexerSQLMetadataStorageCoordinator.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = new Logger(IndexerSQLMetadataStorageCoordinator.class)", "var_name": "log"}, {"original_string": "private static final int MAX_NUM_SEGMENTS_TO_ANNOUNCE_AT_ONCE = 100;", "modifier": "private static final", "type": "int", "declarator": "MAX_NUM_SEGMENTS_TO_ANNOUNCE_AT_ONCE = 100", "var_name": "MAX_NUM_SEGMENTS_TO_ANNOUNCE_AT_ONCE"}, {"original_string": "private final ObjectMapper jsonMapper;", "modifier": "private final", "type": "ObjectMapper", "declarator": "jsonMapper", "var_name": "jsonMapper"}, {"original_string": "private final MetadataStorageTablesConfig dbTables;", "modifier": "private final", "type": "MetadataStorageTablesConfig", "declarator": "dbTables", "var_name": "dbTables"}, {"original_string": "private final SQLMetadataConnector connector;", "modifier": "private final", "type": "SQLMetadataConnector", "declarator": "connector", "var_name": "connector"}], "methods": [{"identifier": "IndexerSQLMetadataStorageCoordinator", "parameters": "(\n      ObjectMapper jsonMapper,\n      MetadataStorageTablesConfig dbTables,\n      SQLMetadataConnector connector\n  )", "modifiers": "@Inject public", "return": "", "signature": " IndexerSQLMetadataStorageCoordinator(\n      ObjectMapper jsonMapper,\n      MetadataStorageTablesConfig dbTables,\n      SQLMetadataConnector connector\n  )", "full_signature": "@Inject public  IndexerSQLMetadataStorageCoordinator(\n      ObjectMapper jsonMapper,\n      MetadataStorageTablesConfig dbTables,\n      SQLMetadataConnector connector\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.IndexerSQLMetadataStorageCoordinator(\n      ObjectMapper jsonMapper,\n      MetadataStorageTablesConfig dbTables,\n      SQLMetadataConnector connector\n  )", "testcase": false, "constructor": true}, {"identifier": "start", "parameters": "()", "modifiers": "@LifecycleStart public", "return": "void", "signature": "void start()", "full_signature": "@LifecycleStart public void start()", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.start()", "testcase": false, "constructor": false}, {"identifier": "retrieveUsedSegmentsForIntervals", "parameters": "(\n      final String dataSource,\n      final List<Interval> intervals,\n      final Segments visibility\n  )", "modifiers": "@Override public", "return": "Collection<DataSegment>", "signature": "Collection<DataSegment> retrieveUsedSegmentsForIntervals(\n      final String dataSource,\n      final List<Interval> intervals,\n      final Segments visibility\n  )", "full_signature": "@Override public Collection<DataSegment> retrieveUsedSegmentsForIntervals(\n      final String dataSource,\n      final List<Interval> intervals,\n      final Segments visibility\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.retrieveUsedSegmentsForIntervals(\n      final String dataSource,\n      final List<Interval> intervals,\n      final Segments visibility\n  )", "testcase": false, "constructor": false}, {"identifier": "retrieveAllUsedSegments", "parameters": "(String dataSource, Segments visibility)", "modifiers": "@Override public", "return": "Collection<DataSegment>", "signature": "Collection<DataSegment> retrieveAllUsedSegments(String dataSource, Segments visibility)", "full_signature": "@Override public Collection<DataSegment> retrieveAllUsedSegments(String dataSource, Segments visibility)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.retrieveAllUsedSegments(String dataSource, Segments visibility)", "testcase": false, "constructor": false}, {"identifier": "doRetrieveUsedSegments", "parameters": "(\n      final String dataSource,\n      final List<Interval> intervals,\n      final Segments visibility\n  )", "modifiers": "private", "return": "Collection<DataSegment>", "signature": "Collection<DataSegment> doRetrieveUsedSegments(\n      final String dataSource,\n      final List<Interval> intervals,\n      final Segments visibility\n  )", "full_signature": "private Collection<DataSegment> doRetrieveUsedSegments(\n      final String dataSource,\n      final List<Interval> intervals,\n      final Segments visibility\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.doRetrieveUsedSegments(\n      final String dataSource,\n      final List<Interval> intervals,\n      final Segments visibility\n  )", "testcase": false, "constructor": false}, {"identifier": "retrieveUsedSegmentsAndCreatedDates", "parameters": "(String dataSource)", "modifiers": "@Override public", "return": "List<Pair<DataSegment, String>>", "signature": "List<Pair<DataSegment, String>> retrieveUsedSegmentsAndCreatedDates(String dataSource)", "full_signature": "@Override public List<Pair<DataSegment, String>> retrieveUsedSegmentsAndCreatedDates(String dataSource)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.retrieveUsedSegmentsAndCreatedDates(String dataSource)", "testcase": false, "constructor": false}, {"identifier": "retrieveUnusedSegmentsForInterval", "parameters": "(final String dataSource, final Interval interval)", "modifiers": "@Override public", "return": "List<DataSegment>", "signature": "List<DataSegment> retrieveUnusedSegmentsForInterval(final String dataSource, final Interval interval)", "full_signature": "@Override public List<DataSegment> retrieveUnusedSegmentsForInterval(final String dataSource, final Interval interval)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.retrieveUnusedSegmentsForInterval(final String dataSource, final Interval interval)", "testcase": false, "constructor": false}, {"identifier": "getPendingSegmentsForIntervalWithHandle", "parameters": "(\n      final Handle handle,\n      final String dataSource,\n      final Interval interval\n  )", "modifiers": "private", "return": "List<SegmentIdWithShardSpec>", "signature": "List<SegmentIdWithShardSpec> getPendingSegmentsForIntervalWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final Interval interval\n  )", "full_signature": "private List<SegmentIdWithShardSpec> getPendingSegmentsForIntervalWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final Interval interval\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.getPendingSegmentsForIntervalWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final Interval interval\n  )", "testcase": false, "constructor": false}, {"identifier": "getTimelineForIntervalsWithHandle", "parameters": "(\n      final Handle handle,\n      final String dataSource,\n      final List<Interval> intervals\n  )", "modifiers": "private", "return": "VersionedIntervalTimeline<String, DataSegment>", "signature": "VersionedIntervalTimeline<String, DataSegment> getTimelineForIntervalsWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final List<Interval> intervals\n  )", "full_signature": "private VersionedIntervalTimeline<String, DataSegment> getTimelineForIntervalsWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final List<Interval> intervals\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.getTimelineForIntervalsWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final List<Interval> intervals\n  )", "testcase": false, "constructor": false}, {"identifier": "retrieveAllUsedSegmentsForIntervalsWithHandle", "parameters": "(\n      final Handle handle,\n      final String dataSource,\n      final List<Interval> intervals\n  )", "modifiers": "private", "return": "Collection<DataSegment>", "signature": "Collection<DataSegment> retrieveAllUsedSegmentsForIntervalsWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final List<Interval> intervals\n  )", "full_signature": "private Collection<DataSegment> retrieveAllUsedSegmentsForIntervalsWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final List<Interval> intervals\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.retrieveAllUsedSegmentsForIntervalsWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final List<Interval> intervals\n  )", "testcase": false, "constructor": false}, {"identifier": "createUsedSegmentsSqlQueryForIntervals", "parameters": "(\n      Handle handle,\n      String dataSource,\n      List<Interval> intervals\n  )", "modifiers": "private", "return": "Query<Map<String, Object>>", "signature": "Query<Map<String, Object>> createUsedSegmentsSqlQueryForIntervals(\n      Handle handle,\n      String dataSource,\n      List<Interval> intervals\n  )", "full_signature": "private Query<Map<String, Object>> createUsedSegmentsSqlQueryForIntervals(\n      Handle handle,\n      String dataSource,\n      List<Interval> intervals\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.createUsedSegmentsSqlQueryForIntervals(\n      Handle handle,\n      String dataSource,\n      List<Interval> intervals\n  )", "testcase": false, "constructor": false}, {"identifier": "announceHistoricalSegments", "parameters": "(final Set<DataSegment> segments)", "modifiers": "@Override public", "return": "Set<DataSegment>", "signature": "Set<DataSegment> announceHistoricalSegments(final Set<DataSegment> segments)", "full_signature": "@Override public Set<DataSegment> announceHistoricalSegments(final Set<DataSegment> segments)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.announceHistoricalSegments(final Set<DataSegment> segments)", "testcase": false, "constructor": false}, {"identifier": "announceHistoricalSegments", "parameters": "(\n      final Set<DataSegment> segments,\n      @Nullable final DataSourceMetadata startMetadata,\n      @Nullable final DataSourceMetadata endMetadata\n  )", "modifiers": "@Override public", "return": "SegmentPublishResult", "signature": "SegmentPublishResult announceHistoricalSegments(\n      final Set<DataSegment> segments,\n      @Nullable final DataSourceMetadata startMetadata,\n      @Nullable final DataSourceMetadata endMetadata\n  )", "full_signature": "@Override public SegmentPublishResult announceHistoricalSegments(\n      final Set<DataSegment> segments,\n      @Nullable final DataSourceMetadata startMetadata,\n      @Nullable final DataSourceMetadata endMetadata\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.announceHistoricalSegments(\n      final Set<DataSegment> segments,\n      @Nullable final DataSourceMetadata startMetadata,\n      @Nullable final DataSourceMetadata endMetadata\n  )", "testcase": false, "constructor": false}, {"identifier": "commitMetadataOnly", "parameters": "(\n      String dataSource,\n      DataSourceMetadata startMetadata,\n      DataSourceMetadata endMetadata\n  )", "modifiers": "@Override public", "return": "SegmentPublishResult", "signature": "SegmentPublishResult commitMetadataOnly(\n      String dataSource,\n      DataSourceMetadata startMetadata,\n      DataSourceMetadata endMetadata\n  )", "full_signature": "@Override public SegmentPublishResult commitMetadataOnly(\n      String dataSource,\n      DataSourceMetadata startMetadata,\n      DataSourceMetadata endMetadata\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.commitMetadataOnly(\n      String dataSource,\n      DataSourceMetadata startMetadata,\n      DataSourceMetadata endMetadata\n  )", "testcase": false, "constructor": false}, {"identifier": "allocatePendingSegment", "parameters": "(\n      final String dataSource,\n      final String sequenceName,\n      @Nullable final String previousSegmentId,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion,\n      final boolean skipSegmentLineageCheck\n  )", "modifiers": "@Override public", "return": "SegmentIdWithShardSpec", "signature": "SegmentIdWithShardSpec allocatePendingSegment(\n      final String dataSource,\n      final String sequenceName,\n      @Nullable final String previousSegmentId,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion,\n      final boolean skipSegmentLineageCheck\n  )", "full_signature": "@Override public SegmentIdWithShardSpec allocatePendingSegment(\n      final String dataSource,\n      final String sequenceName,\n      @Nullable final String previousSegmentId,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion,\n      final boolean skipSegmentLineageCheck\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.allocatePendingSegment(\n      final String dataSource,\n      final String sequenceName,\n      @Nullable final String previousSegmentId,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion,\n      final boolean skipSegmentLineageCheck\n  )", "testcase": false, "constructor": false}, {"identifier": "allocatePendingSegmentWithSegmentLineageCheck", "parameters": "(\n      final Handle handle,\n      final String dataSource,\n      final String sequenceName,\n      @Nullable final String previousSegmentId,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "modifiers": "@Nullable private", "return": "SegmentIdWithShardSpec", "signature": "SegmentIdWithShardSpec allocatePendingSegmentWithSegmentLineageCheck(\n      final Handle handle,\n      final String dataSource,\n      final String sequenceName,\n      @Nullable final String previousSegmentId,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "full_signature": "@Nullable private SegmentIdWithShardSpec allocatePendingSegmentWithSegmentLineageCheck(\n      final Handle handle,\n      final String dataSource,\n      final String sequenceName,\n      @Nullable final String previousSegmentId,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.allocatePendingSegmentWithSegmentLineageCheck(\n      final Handle handle,\n      final String dataSource,\n      final String sequenceName,\n      @Nullable final String previousSegmentId,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "testcase": false, "constructor": false}, {"identifier": "allocatePendingSegment", "parameters": "(\n      final Handle handle,\n      final String dataSource,\n      final String sequenceName,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "modifiers": "@Nullable private", "return": "SegmentIdWithShardSpec", "signature": "SegmentIdWithShardSpec allocatePendingSegment(\n      final Handle handle,\n      final String dataSource,\n      final String sequenceName,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "full_signature": "@Nullable private SegmentIdWithShardSpec allocatePendingSegment(\n      final Handle handle,\n      final String dataSource,\n      final String sequenceName,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.allocatePendingSegment(\n      final Handle handle,\n      final String dataSource,\n      final String sequenceName,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "testcase": false, "constructor": false}, {"identifier": "checkAndGetExistingSegmentId", "parameters": "(\n      final Query<Map<String, Object>> query,\n      final Interval interval,\n      final String sequenceName,\n      final @Nullable String previousSegmentId,\n      final Pair<String, String>... queryVars\n  )", "modifiers": "private", "return": "CheckExistingSegmentIdResult", "signature": "CheckExistingSegmentIdResult checkAndGetExistingSegmentId(\n      final Query<Map<String, Object>> query,\n      final Interval interval,\n      final String sequenceName,\n      final @Nullable String previousSegmentId,\n      final Pair<String, String>... queryVars\n  )", "full_signature": "private CheckExistingSegmentIdResult checkAndGetExistingSegmentId(\n      final Query<Map<String, Object>> query,\n      final Interval interval,\n      final String sequenceName,\n      final @Nullable String previousSegmentId,\n      final Pair<String, String>... queryVars\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.checkAndGetExistingSegmentId(\n      final Query<Map<String, Object>> query,\n      final Interval interval,\n      final String sequenceName,\n      final @Nullable String previousSegmentId,\n      final Pair<String, String>... queryVars\n  )", "testcase": false, "constructor": false}, {"identifier": "insertToMetastore", "parameters": "(\n      Handle handle,\n      SegmentIdWithShardSpec newIdentifier,\n      String dataSource,\n      Interval interval,\n      String previousSegmentId,\n      String sequenceName,\n      String sequenceNamePrevIdSha1\n  )", "modifiers": "private", "return": "void", "signature": "void insertToMetastore(\n      Handle handle,\n      SegmentIdWithShardSpec newIdentifier,\n      String dataSource,\n      Interval interval,\n      String previousSegmentId,\n      String sequenceName,\n      String sequenceNamePrevIdSha1\n  )", "full_signature": "private void insertToMetastore(\n      Handle handle,\n      SegmentIdWithShardSpec newIdentifier,\n      String dataSource,\n      Interval interval,\n      String previousSegmentId,\n      String sequenceName,\n      String sequenceNamePrevIdSha1\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.insertToMetastore(\n      Handle handle,\n      SegmentIdWithShardSpec newIdentifier,\n      String dataSource,\n      Interval interval,\n      String previousSegmentId,\n      String sequenceName,\n      String sequenceNamePrevIdSha1\n  )", "testcase": false, "constructor": false}, {"identifier": "createNewSegment", "parameters": "(\n      final Handle handle,\n      final String dataSource,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "modifiers": "@Nullable private", "return": "SegmentIdWithShardSpec", "signature": "SegmentIdWithShardSpec createNewSegment(\n      final Handle handle,\n      final String dataSource,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "full_signature": "@Nullable private SegmentIdWithShardSpec createNewSegment(\n      final Handle handle,\n      final String dataSource,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.createNewSegment(\n      final Handle handle,\n      final String dataSource,\n      final Interval interval,\n      final PartialShardSpec partialShardSpec,\n      final String maxVersion\n  )", "testcase": false, "constructor": false}, {"identifier": "deletePendingSegmentsCreatedInInterval", "parameters": "(String dataSource, Interval deleteInterval)", "modifiers": "@Override public", "return": "int", "signature": "int deletePendingSegmentsCreatedInInterval(String dataSource, Interval deleteInterval)", "full_signature": "@Override public int deletePendingSegmentsCreatedInInterval(String dataSource, Interval deleteInterval)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.deletePendingSegmentsCreatedInInterval(String dataSource, Interval deleteInterval)", "testcase": false, "constructor": false}, {"identifier": "deletePendingSegments", "parameters": "(String dataSource)", "modifiers": "@Override public", "return": "int", "signature": "int deletePendingSegments(String dataSource)", "full_signature": "@Override public int deletePendingSegments(String dataSource)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.deletePendingSegments(String dataSource)", "testcase": false, "constructor": false}, {"identifier": "announceHistoricalSegmentBatch", "parameters": "(\n      final Handle handle,\n      final Set<DataSegment> segments,\n      final Set<DataSegment> usedSegments\n  )", "modifiers": "private", "return": "Set<DataSegment>", "signature": "Set<DataSegment> announceHistoricalSegmentBatch(\n      final Handle handle,\n      final Set<DataSegment> segments,\n      final Set<DataSegment> usedSegments\n  )", "full_signature": "private Set<DataSegment> announceHistoricalSegmentBatch(\n      final Handle handle,\n      final Set<DataSegment> segments,\n      final Set<DataSegment> usedSegments\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.announceHistoricalSegmentBatch(\n      final Handle handle,\n      final Set<DataSegment> segments,\n      final Set<DataSegment> usedSegments\n  )", "testcase": false, "constructor": false}, {"identifier": "segmentExistsBatch", "parameters": "(final Handle handle, final Set<DataSegment> segments)", "modifiers": "private", "return": "Set<String>", "signature": "Set<String> segmentExistsBatch(final Handle handle, final Set<DataSegment> segments)", "full_signature": "private Set<String> segmentExistsBatch(final Handle handle, final Set<DataSegment> segments)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.segmentExistsBatch(final Handle handle, final Set<DataSegment> segments)", "testcase": false, "constructor": false}, {"identifier": "retrieveDataSourceMetadata", "parameters": "(final String dataSource)", "modifiers": "@Override public @Nullable", "return": "DataSourceMetadata", "signature": "DataSourceMetadata retrieveDataSourceMetadata(final String dataSource)", "full_signature": "@Override public @Nullable DataSourceMetadata retrieveDataSourceMetadata(final String dataSource)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.retrieveDataSourceMetadata(final String dataSource)", "testcase": false, "constructor": false}, {"identifier": "retrieveDataSourceMetadataWithHandleAsBytes", "parameters": "(\n      final Handle handle,\n      final String dataSource\n  )", "modifiers": "private @Nullable", "return": "byte[]", "signature": "byte[] retrieveDataSourceMetadataWithHandleAsBytes(\n      final Handle handle,\n      final String dataSource\n  )", "full_signature": "private @Nullable byte[] retrieveDataSourceMetadataWithHandleAsBytes(\n      final Handle handle,\n      final String dataSource\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.retrieveDataSourceMetadataWithHandleAsBytes(\n      final Handle handle,\n      final String dataSource\n  )", "testcase": false, "constructor": false}, {"identifier": "updateDataSourceMetadataWithHandle", "parameters": "(\n      final Handle handle,\n      final String dataSource,\n      final DataSourceMetadata startMetadata,\n      final DataSourceMetadata endMetadata\n  )", "modifiers": "protected", "return": "DataSourceMetadataUpdateResult", "signature": "DataSourceMetadataUpdateResult updateDataSourceMetadataWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final DataSourceMetadata startMetadata,\n      final DataSourceMetadata endMetadata\n  )", "full_signature": "protected DataSourceMetadataUpdateResult updateDataSourceMetadataWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final DataSourceMetadata startMetadata,\n      final DataSourceMetadata endMetadata\n  )", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.updateDataSourceMetadataWithHandle(\n      final Handle handle,\n      final String dataSource,\n      final DataSourceMetadata startMetadata,\n      final DataSourceMetadata endMetadata\n  )", "testcase": false, "constructor": false}, {"identifier": "deleteDataSourceMetadata", "parameters": "(final String dataSource)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean deleteDataSourceMetadata(final String dataSource)", "full_signature": "@Override public boolean deleteDataSourceMetadata(final String dataSource)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.deleteDataSourceMetadata(final String dataSource)", "testcase": false, "constructor": false}, {"identifier": "resetDataSourceMetadata", "parameters": "(final String dataSource, final DataSourceMetadata dataSourceMetadata)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean resetDataSourceMetadata(final String dataSource, final DataSourceMetadata dataSourceMetadata)", "full_signature": "@Override public boolean resetDataSourceMetadata(final String dataSource, final DataSourceMetadata dataSourceMetadata)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.resetDataSourceMetadata(final String dataSource, final DataSourceMetadata dataSourceMetadata)", "testcase": false, "constructor": false}, {"identifier": "updateSegmentMetadata", "parameters": "(final Set<DataSegment> segments)", "modifiers": "@Override public", "return": "void", "signature": "void updateSegmentMetadata(final Set<DataSegment> segments)", "full_signature": "@Override public void updateSegmentMetadata(final Set<DataSegment> segments)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.updateSegmentMetadata(final Set<DataSegment> segments)", "testcase": false, "constructor": false}, {"identifier": "deleteSegments", "parameters": "(final Set<DataSegment> segments)", "modifiers": "@Override public", "return": "void", "signature": "void deleteSegments(final Set<DataSegment> segments)", "full_signature": "@Override public void deleteSegments(final Set<DataSegment> segments)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.deleteSegments(final Set<DataSegment> segments)", "testcase": false, "constructor": false}, {"identifier": "deleteSegment", "parameters": "(final Handle handle, final DataSegment segment)", "modifiers": "private", "return": "void", "signature": "void deleteSegment(final Handle handle, final DataSegment segment)", "full_signature": "private void deleteSegment(final Handle handle, final DataSegment segment)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.deleteSegment(final Handle handle, final DataSegment segment)", "testcase": false, "constructor": false}, {"identifier": "updatePayload", "parameters": "(final Handle handle, final DataSegment segment)", "modifiers": "private", "return": "void", "signature": "void updatePayload(final Handle handle, final DataSegment segment)", "full_signature": "private void updatePayload(final Handle handle, final DataSegment segment)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.updatePayload(final Handle handle, final DataSegment segment)", "testcase": false, "constructor": false}, {"identifier": "insertDataSourceMetadata", "parameters": "(String dataSource, DataSourceMetadata metadata)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean insertDataSourceMetadata(String dataSource, DataSourceMetadata metadata)", "full_signature": "@Override public boolean insertDataSourceMetadata(String dataSource, DataSourceMetadata metadata)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.insertDataSourceMetadata(String dataSource, DataSourceMetadata metadata)", "testcase": false, "constructor": false}], "file": "server/src/main/java/org/apache/druid/metadata/IndexerSQLMetadataStorageCoordinator.java"}, "focal_method": {"identifier": "deleteDataSourceMetadata", "parameters": "(final String dataSource)", "modifiers": "@Override public", "return": "boolean", "body": "@Override\n  public boolean deleteDataSourceMetadata(final String dataSource)\n  {\n    return connector.retryWithHandle(\n        new HandleCallback<Boolean>()\n        {\n          @Override\n          public Boolean withHandle(Handle handle)\n          {\n            int rows = handle.createStatement(\n                StringUtils.format(\"DELETE from %s WHERE dataSource = :dataSource\", dbTables.getDataSourceTable())\n            )\n                             .bind(\"dataSource\", dataSource)\n                             .execute();\n\n            return rows > 0;\n          }\n        }\n    );\n  }", "signature": "boolean deleteDataSourceMetadata(final String dataSource)", "full_signature": "@Override public boolean deleteDataSourceMetadata(final String dataSource)", "class_method_signature": "IndexerSQLMetadataStorageCoordinator.deleteDataSourceMetadata(final String dataSource)", "testcase": false, "constructor": false, "invocations": ["retryWithHandle", "execute", "bind", "createStatement", "format", "getDataSourceTable"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}