{"test_class": {"identifier": "TimeBoundaryQueryQueryToolChestTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final TimeBoundaryQuery TIME_BOUNDARY_QUERY = new TimeBoundaryQuery(\n      new TableDataSource(\"test\"),\n      null,\n      null,\n      null,\n      null\n  );", "modifier": "private static final", "type": "TimeBoundaryQuery", "declarator": "TIME_BOUNDARY_QUERY = new TimeBoundaryQuery(\n      new TableDataSource(\"test\"),\n      null,\n      null,\n      null,\n      null\n  )", "var_name": "TIME_BOUNDARY_QUERY"}, {"original_string": "private static final TimeBoundaryQuery MAXTIME_BOUNDARY_QUERY = new TimeBoundaryQuery(\n      new TableDataSource(\"test\"),\n      null,\n      TimeBoundaryQuery.MAX_TIME,\n      null,\n      null\n  );", "modifier": "private static final", "type": "TimeBoundaryQuery", "declarator": "MAXTIME_BOUNDARY_QUERY = new TimeBoundaryQuery(\n      new TableDataSource(\"test\"),\n      null,\n      TimeBoundaryQuery.MAX_TIME,\n      null,\n      null\n  )", "var_name": "MAXTIME_BOUNDARY_QUERY"}, {"original_string": "private static final TimeBoundaryQuery MINTIME_BOUNDARY_QUERY = new TimeBoundaryQuery(\n      new TableDataSource(\"test\"),\n      null,\n      TimeBoundaryQuery.MIN_TIME,\n      null,\n      null\n  );", "modifier": "private static final", "type": "TimeBoundaryQuery", "declarator": "MINTIME_BOUNDARY_QUERY = new TimeBoundaryQuery(\n      new TableDataSource(\"test\"),\n      null,\n      TimeBoundaryQuery.MIN_TIME,\n      null,\n      null\n  )", "var_name": "MINTIME_BOUNDARY_QUERY"}, {"original_string": "private static final TimeBoundaryQuery FILTERED_BOUNDARY_QUERY = Druids.newTimeBoundaryQueryBuilder()\n                                                                         .dataSource(\"testing\")\n                                                                         .filters(\"foo\", \"bar\")\n                                                                         .build();", "modifier": "private static final", "type": "TimeBoundaryQuery", "declarator": "FILTERED_BOUNDARY_QUERY = Druids.newTimeBoundaryQueryBuilder()\n                                                                         .dataSource(\"testing\")\n                                                                         .filters(\"foo\", \"bar\")\n                                                                         .build()", "var_name": "FILTERED_BOUNDARY_QUERY"}], "file": "processing/src/test/java/org/apache/druid/query/timeboundary/TimeBoundaryQueryQueryToolChestTest.java"}, "test_case": {"identifier": "testMaxTimeFilterSegments", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testMaxTimeFilterSegments()\n  {\n    List<LogicalSegment> segments = new TimeBoundaryQueryQueryToolChest().filterSegments(\n        MAXTIME_BOUNDARY_QUERY,\n        Arrays.asList(\n            createLogicalSegment(Intervals.of(\"2013-01-01/P1D\")),\n            createLogicalSegment(Intervals.of(\"2013-01-01T01/PT1H\")),\n            createLogicalSegment(Intervals.of(\"2013-01-01T02/PT1H\")),\n            createLogicalSegment(Intervals.of(\"2013-01-02/P1D\")),\n            createLogicalSegment(Intervals.of(\"2013-01-03T01/PT1H\")),\n            createLogicalSegment(Intervals.of(\"2013-01-03T02/PT1H\")),\n            createLogicalSegment(Intervals.of(\"2013-01-03/P1D\"))\n        )\n    );\n\n    Assert.assertEquals(3, segments.size());\n\n    List<LogicalSegment> expected = Arrays.asList(\n        createLogicalSegment(Intervals.of(\"2013-01-03T01/PT1H\")),\n        createLogicalSegment(Intervals.of(\"2013-01-03T02/PT1H\")),\n        createLogicalSegment(Intervals.of(\"2013-01-03/P1D\"))\n    );\n\n    for (int i = 0; i < segments.size(); i++) {\n      Assert.assertEquals(segments.get(i).getInterval(), expected.get(i).getInterval());\n    }\n  }", "signature": "void testMaxTimeFilterSegments()", "full_signature": "@Test public void testMaxTimeFilterSegments()", "class_method_signature": "TimeBoundaryQueryQueryToolChestTest.testMaxTimeFilterSegments()", "testcase": true, "constructor": false, "invocations": ["filterSegments", "asList", "createLogicalSegment", "of", "createLogicalSegment", "of", "createLogicalSegment", "of", "createLogicalSegment", "of", "createLogicalSegment", "of", "createLogicalSegment", "of", "createLogicalSegment", "of", "assertEquals", "size", "asList", "createLogicalSegment", "of", "createLogicalSegment", "of", "createLogicalSegment", "of", "size", "assertEquals", "getInterval", "get", "getInterval", "get"]}, "focal_class": {"identifier": "TimeBoundaryQueryQueryToolChest", "superclass": "extends QueryToolChest<Result<TimeBoundaryResultValue>, TimeBoundaryQuery>", "interfaces": "", "fields": [{"original_string": "private static final byte TIMEBOUNDARY_QUERY = 0x3;", "modifier": "private static final", "type": "byte", "declarator": "TIMEBOUNDARY_QUERY = 0x3", "var_name": "TIMEBOUNDARY_QUERY"}, {"original_string": "private static final TypeReference<Result<TimeBoundaryResultValue>> TYPE_REFERENCE = new TypeReference<Result<TimeBoundaryResultValue>>()\n  {\n  };", "modifier": "private static final", "type": "TypeReference<Result<TimeBoundaryResultValue>>", "declarator": "TYPE_REFERENCE = new TypeReference<Result<TimeBoundaryResultValue>>()\n  {\n  }", "var_name": "TYPE_REFERENCE"}, {"original_string": "private static final TypeReference<Object> OBJECT_TYPE_REFERENCE = new TypeReference<Object>()\n  {\n  };", "modifier": "private static final", "type": "TypeReference<Object>", "declarator": "OBJECT_TYPE_REFERENCE = new TypeReference<Object>()\n  {\n  }", "var_name": "OBJECT_TYPE_REFERENCE"}, {"original_string": "private final GenericQueryMetricsFactory queryMetricsFactory;", "modifier": "private final", "type": "GenericQueryMetricsFactory", "declarator": "queryMetricsFactory", "var_name": "queryMetricsFactory"}], "methods": [{"identifier": "TimeBoundaryQueryQueryToolChest", "parameters": "()", "modifiers": "@VisibleForTesting public", "return": "", "signature": " TimeBoundaryQueryQueryToolChest()", "full_signature": "@VisibleForTesting public  TimeBoundaryQueryQueryToolChest()", "class_method_signature": "TimeBoundaryQueryQueryToolChest.TimeBoundaryQueryQueryToolChest()", "testcase": false, "constructor": true}, {"identifier": "TimeBoundaryQueryQueryToolChest", "parameters": "(GenericQueryMetricsFactory queryMetricsFactory)", "modifiers": "@Inject public", "return": "", "signature": " TimeBoundaryQueryQueryToolChest(GenericQueryMetricsFactory queryMetricsFactory)", "full_signature": "@Inject public  TimeBoundaryQueryQueryToolChest(GenericQueryMetricsFactory queryMetricsFactory)", "class_method_signature": "TimeBoundaryQueryQueryToolChest.TimeBoundaryQueryQueryToolChest(GenericQueryMetricsFactory queryMetricsFactory)", "testcase": false, "constructor": true}, {"identifier": "filterSegments", "parameters": "(TimeBoundaryQuery query, List<T> segments)", "modifiers": "@Override public", "return": "List<T>", "signature": "List<T> filterSegments(TimeBoundaryQuery query, List<T> segments)", "full_signature": "@Override public List<T> filterSegments(TimeBoundaryQuery query, List<T> segments)", "class_method_signature": "TimeBoundaryQueryQueryToolChest.filterSegments(TimeBoundaryQuery query, List<T> segments)", "testcase": false, "constructor": false}, {"identifier": "mergeResults", "parameters": "(\n      final QueryRunner<Result<TimeBoundaryResultValue>> runner\n  )", "modifiers": "@Override public", "return": "QueryRunner<Result<TimeBoundaryResultValue>>", "signature": "QueryRunner<Result<TimeBoundaryResultValue>> mergeResults(\n      final QueryRunner<Result<TimeBoundaryResultValue>> runner\n  )", "full_signature": "@Override public QueryRunner<Result<TimeBoundaryResultValue>> mergeResults(\n      final QueryRunner<Result<TimeBoundaryResultValue>> runner\n  )", "class_method_signature": "TimeBoundaryQueryQueryToolChest.mergeResults(\n      final QueryRunner<Result<TimeBoundaryResultValue>> runner\n  )", "testcase": false, "constructor": false}, {"identifier": "createMergeFn", "parameters": "(Query<Result<TimeBoundaryResultValue>> query)", "modifiers": "@Override public", "return": "BinaryOperator<Result<TimeBoundaryResultValue>>", "signature": "BinaryOperator<Result<TimeBoundaryResultValue>> createMergeFn(Query<Result<TimeBoundaryResultValue>> query)", "full_signature": "@Override public BinaryOperator<Result<TimeBoundaryResultValue>> createMergeFn(Query<Result<TimeBoundaryResultValue>> query)", "class_method_signature": "TimeBoundaryQueryQueryToolChest.createMergeFn(Query<Result<TimeBoundaryResultValue>> query)", "testcase": false, "constructor": false}, {"identifier": "createResultComparator", "parameters": "(Query<Result<TimeBoundaryResultValue>> query)", "modifiers": "@Override public", "return": "Comparator<Result<TimeBoundaryResultValue>>", "signature": "Comparator<Result<TimeBoundaryResultValue>> createResultComparator(Query<Result<TimeBoundaryResultValue>> query)", "full_signature": "@Override public Comparator<Result<TimeBoundaryResultValue>> createResultComparator(Query<Result<TimeBoundaryResultValue>> query)", "class_method_signature": "TimeBoundaryQueryQueryToolChest.createResultComparator(Query<Result<TimeBoundaryResultValue>> query)", "testcase": false, "constructor": false}, {"identifier": "makeMetrics", "parameters": "(TimeBoundaryQuery query)", "modifiers": "@Override public", "return": "QueryMetrics<Query<?>>", "signature": "QueryMetrics<Query<?>> makeMetrics(TimeBoundaryQuery query)", "full_signature": "@Override public QueryMetrics<Query<?>> makeMetrics(TimeBoundaryQuery query)", "class_method_signature": "TimeBoundaryQueryQueryToolChest.makeMetrics(TimeBoundaryQuery query)", "testcase": false, "constructor": false}, {"identifier": "makePreComputeManipulatorFn", "parameters": "(\n      TimeBoundaryQuery query,\n      MetricManipulationFn fn\n  )", "modifiers": "@Override public", "return": "Function<Result<TimeBoundaryResultValue>, Result<TimeBoundaryResultValue>>", "signature": "Function<Result<TimeBoundaryResultValue>, Result<TimeBoundaryResultValue>> makePreComputeManipulatorFn(\n      TimeBoundaryQuery query,\n      MetricManipulationFn fn\n  )", "full_signature": "@Override public Function<Result<TimeBoundaryResultValue>, Result<TimeBoundaryResultValue>> makePreComputeManipulatorFn(\n      TimeBoundaryQuery query,\n      MetricManipulationFn fn\n  )", "class_method_signature": "TimeBoundaryQueryQueryToolChest.makePreComputeManipulatorFn(\n      TimeBoundaryQuery query,\n      MetricManipulationFn fn\n  )", "testcase": false, "constructor": false}, {"identifier": "getResultTypeReference", "parameters": "()", "modifiers": "@Override public", "return": "TypeReference<Result<TimeBoundaryResultValue>>", "signature": "TypeReference<Result<TimeBoundaryResultValue>> getResultTypeReference()", "full_signature": "@Override public TypeReference<Result<TimeBoundaryResultValue>> getResultTypeReference()", "class_method_signature": "TimeBoundaryQueryQueryToolChest.getResultTypeReference()", "testcase": false, "constructor": false}, {"identifier": "getCacheStrategy", "parameters": "(final TimeBoundaryQuery query)", "modifiers": "@Override public", "return": "CacheStrategy<Result<TimeBoundaryResultValue>, Object, TimeBoundaryQuery>", "signature": "CacheStrategy<Result<TimeBoundaryResultValue>, Object, TimeBoundaryQuery> getCacheStrategy(final TimeBoundaryQuery query)", "full_signature": "@Override public CacheStrategy<Result<TimeBoundaryResultValue>, Object, TimeBoundaryQuery> getCacheStrategy(final TimeBoundaryQuery query)", "class_method_signature": "TimeBoundaryQueryQueryToolChest.getCacheStrategy(final TimeBoundaryQuery query)", "testcase": false, "constructor": false}], "file": "processing/src/main/java/org/apache/druid/query/timeboundary/TimeBoundaryQueryQueryToolChest.java"}, "focal_method": {"identifier": "filterSegments", "parameters": "(TimeBoundaryQuery query, List<T> segments)", "modifiers": "@Override public", "return": "List<T>", "body": "@Override\n  public <T extends LogicalSegment> List<T> filterSegments(TimeBoundaryQuery query, List<T> segments)\n  {\n    if (segments.size() <= 1 || query.hasFilters()) {\n      return segments;\n    }\n\n    final T min = query.isMaxTime() ? null : segments.get(0);\n    final T max = query.isMinTime() ? null : segments.get(segments.size() - 1);\n\n    return segments.stream()\n                   .filter(input -> (min != null && input.getInterval().overlaps(min.getTrueInterval())) ||\n                                    (max != null && input.getInterval().overlaps(max.getTrueInterval())))\n                   .collect(Collectors.toList());\n  }", "signature": "List<T> filterSegments(TimeBoundaryQuery query, List<T> segments)", "full_signature": "@Override public List<T> filterSegments(TimeBoundaryQuery query, List<T> segments)", "class_method_signature": "TimeBoundaryQueryQueryToolChest.filterSegments(TimeBoundaryQuery query, List<T> segments)", "testcase": false, "constructor": false, "invocations": ["size", "hasFilters", "isMaxTime", "get", "isMinTime", "get", "size", "collect", "filter", "stream", "overlaps", "getInterval", "getTrueInterval", "overlaps", "getInterval", "getTrueInterval", "toList"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}