{"test_class": {"identifier": "RetryUtilsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Predicate<Throwable> IS_TRANSIENT = new Predicate<Throwable>()\n  {\n    @Override\n    public boolean apply(Throwable e)\n    {\n      return e instanceof IOException && e.getMessage().equals(\"what\");\n    }\n  };", "modifier": "private static final", "type": "Predicate<Throwable>", "declarator": "IS_TRANSIENT = new Predicate<Throwable>()\n  {\n    @Override\n    public boolean apply(Throwable e)\n    {\n      return e instanceof IOException && e.getMessage().equals(\"what\");\n    }\n  }", "var_name": "IS_TRANSIENT"}], "file": "core/src/test/java/org/apache/druid/java/util/common/RetryUtilsTest.java"}, "test_case": {"identifier": "testEventualFailure", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testEventualFailure() throws Exception\n  {\n    final AtomicInteger count = new AtomicInteger();\n    boolean threwExpectedException = false;\n    try {\n      RetryUtils.retry(\n          () -> {\n            count.incrementAndGet();\n            throw new IOException(\"what\");\n          },\n          IS_TRANSIENT,\n          2\n      );\n    }\n    catch (IOException e) {\n      threwExpectedException = e.getMessage().equals(\"what\");\n    }\n    Assert.assertTrue(\"threw expected exception\", threwExpectedException);\n    Assert.assertEquals(\"count\", 2, count.get());\n  }", "signature": "void testEventualFailure()", "full_signature": "@Test public void testEventualFailure()", "class_method_signature": "RetryUtilsTest.testEventualFailure()", "testcase": true, "constructor": false, "invocations": ["retry", "incrementAndGet", "equals", "getMessage", "assertTrue", "assertEquals", "get"]}, "focal_class": {"identifier": "RetryUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Logger log = new Logger(RetryUtils.class);", "modifier": "public static final", "type": "Logger", "declarator": "log = new Logger(RetryUtils.class)", "var_name": "log"}, {"original_string": "public static final long MAX_SLEEP_MILLIS = 60000;", "modifier": "public static final", "type": "long", "declarator": "MAX_SLEEP_MILLIS = 60000", "var_name": "MAX_SLEEP_MILLIS"}, {"original_string": "public static final long BASE_SLEEP_MILLIS = 1000;", "modifier": "public static final", "type": "long", "declarator": "BASE_SLEEP_MILLIS = 1000", "var_name": "BASE_SLEEP_MILLIS"}, {"original_string": "public static final int DEFAULT_MAX_TRIES = 10;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_MAX_TRIES = 10", "var_name": "DEFAULT_MAX_TRIES"}], "methods": [{"identifier": "retry", "parameters": "(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries,\n      @Nullable final CleanupAfterFailure cleanupAfterFailure,\n      @Nullable final String messageOnRetry\n  )", "modifiers": "public static", "return": "T", "signature": "T retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries,\n      @Nullable final CleanupAfterFailure cleanupAfterFailure,\n      @Nullable final String messageOnRetry\n  )", "full_signature": "public static T retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries,\n      @Nullable final CleanupAfterFailure cleanupAfterFailure,\n      @Nullable final String messageOnRetry\n  )", "class_method_signature": "RetryUtils.retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries,\n      @Nullable final CleanupAfterFailure cleanupAfterFailure,\n      @Nullable final String messageOnRetry\n  )", "testcase": false, "constructor": false}, {"identifier": "retry", "parameters": "(final Task<T> f, Predicate<Throwable> shouldRetry, final int maxTries)", "modifiers": "public static", "return": "T", "signature": "T retry(final Task<T> f, Predicate<Throwable> shouldRetry, final int maxTries)", "full_signature": "public static T retry(final Task<T> f, Predicate<Throwable> shouldRetry, final int maxTries)", "class_method_signature": "RetryUtils.retry(final Task<T> f, Predicate<Throwable> shouldRetry, final int maxTries)", "testcase": false, "constructor": false}, {"identifier": "retry", "parameters": "(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries\n  )", "modifiers": "public static", "return": "T", "signature": "T retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries\n  )", "full_signature": "public static T retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries\n  )", "class_method_signature": "RetryUtils.retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries\n  )", "testcase": false, "constructor": false}, {"identifier": "retry", "parameters": "(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final CleanupAfterFailure onEachFailure,\n      final int maxTries,\n      final String messageOnRetry\n  )", "modifiers": "public static", "return": "T", "signature": "T retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final CleanupAfterFailure onEachFailure,\n      final int maxTries,\n      final String messageOnRetry\n  )", "full_signature": "public static T retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final CleanupAfterFailure onEachFailure,\n      final int maxTries,\n      final String messageOnRetry\n  )", "class_method_signature": "RetryUtils.retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final CleanupAfterFailure onEachFailure,\n      final int maxTries,\n      final String messageOnRetry\n  )", "testcase": false, "constructor": false}, {"identifier": "awaitNextRetry", "parameters": "(\n      final Throwable e,\n      @Nullable final String messageOnRetry,\n      final int nTry,\n      final int maxRetries,\n      final boolean quiet\n  )", "modifiers": "public static", "return": "void", "signature": "void awaitNextRetry(\n      final Throwable e,\n      @Nullable final String messageOnRetry,\n      final int nTry,\n      final int maxRetries,\n      final boolean quiet\n  )", "full_signature": "public static void awaitNextRetry(\n      final Throwable e,\n      @Nullable final String messageOnRetry,\n      final int nTry,\n      final int maxRetries,\n      final boolean quiet\n  )", "class_method_signature": "RetryUtils.awaitNextRetry(\n      final Throwable e,\n      @Nullable final String messageOnRetry,\n      final int nTry,\n      final int maxRetries,\n      final boolean quiet\n  )", "testcase": false, "constructor": false}, {"identifier": "nextRetrySleepMillis", "parameters": "(final int nTry)", "modifiers": "public static", "return": "long", "signature": "long nextRetrySleepMillis(final int nTry)", "full_signature": "public static long nextRetrySleepMillis(final int nTry)", "class_method_signature": "RetryUtils.nextRetrySleepMillis(final int nTry)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/apache/druid/java/util/common/RetryUtils.java"}, "focal_method": {"identifier": "retry", "parameters": "(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries,\n      @Nullable final CleanupAfterFailure cleanupAfterFailure,\n      @Nullable final String messageOnRetry\n  )", "modifiers": "public static", "return": "T", "body": "public static <T> T retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries,\n      @Nullable final CleanupAfterFailure cleanupAfterFailure,\n      @Nullable final String messageOnRetry\n  ) throws Exception\n  {\n    Preconditions.checkArgument(maxTries > 0, \"maxTries > 0\");\n    Preconditions.checkArgument(quietTries >= 0, \"quietTries >= 0\");\n    int nTry = 0;\n    final int maxRetries = maxTries - 1;\n    while (true) {\n      try {\n        nTry++;\n        return f.perform();\n      }\n      catch (Throwable e) {\n        if (cleanupAfterFailure != null) {\n          cleanupAfterFailure.cleanup();\n        }\n        if (nTry < maxTries && shouldRetry.apply(e)) {\n          awaitNextRetry(e, messageOnRetry, nTry, maxRetries, nTry <= quietTries);\n        } else {\n          Throwables.propagateIfInstanceOf(e, Exception.class);\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }", "signature": "T retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries,\n      @Nullable final CleanupAfterFailure cleanupAfterFailure,\n      @Nullable final String messageOnRetry\n  )", "full_signature": "public static T retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries,\n      @Nullable final CleanupAfterFailure cleanupAfterFailure,\n      @Nullable final String messageOnRetry\n  )", "class_method_signature": "RetryUtils.retry(\n      final Task<T> f,\n      final Predicate<Throwable> shouldRetry,\n      final int quietTries,\n      final int maxTries,\n      @Nullable final CleanupAfterFailure cleanupAfterFailure,\n      @Nullable final String messageOnRetry\n  )", "testcase": false, "constructor": false, "invocations": ["checkArgument", "checkArgument", "perform", "cleanup", "apply", "awaitNextRetry", "propagateIfInstanceOf"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}