{"test_class": {"identifier": "DruidSchemaTest", "superclass": "extends CalciteTestBase", "interfaces": "", "fields": [{"original_string": "private static final PlannerConfig PLANNER_CONFIG_DEFAULT = new PlannerConfig()\n  {\n    @Override\n    public Period getMetadataRefreshPeriod()\n    {\n      return new Period(\"PT1S\");\n    }\n  };", "modifier": "private static final", "type": "PlannerConfig", "declarator": "PLANNER_CONFIG_DEFAULT = new PlannerConfig()\n  {\n    @Override\n    public Period getMetadataRefreshPeriod()\n    {\n      return new Period(\"PT1S\");\n    }\n  }", "var_name": "PLANNER_CONFIG_DEFAULT"}, {"original_string": "private static final List<InputRow> ROWS1 = ImmutableList.of(\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2000-01-01\", \"m1\", \"1.0\", \"dim1\", \"\")),\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2000-01-02\", \"m1\", \"2.0\", \"dim1\", \"10.1\")),\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2000-01-03\", \"m1\", \"3.0\", \"dim1\", \"2\"))\n  );", "modifier": "private static final", "type": "List<InputRow>", "declarator": "ROWS1 = ImmutableList.of(\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2000-01-01\", \"m1\", \"1.0\", \"dim1\", \"\")),\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2000-01-02\", \"m1\", \"2.0\", \"dim1\", \"10.1\")),\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2000-01-03\", \"m1\", \"3.0\", \"dim1\", \"2\"))\n  )", "var_name": "ROWS1"}, {"original_string": "private static final List<InputRow> ROWS2 = ImmutableList.of(\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2001-01-01\", \"m1\", \"4.0\", \"dim2\", ImmutableList.of(\"a\"))),\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2001-01-02\", \"m1\", \"5.0\", \"dim2\", ImmutableList.of(\"abc\"))),\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2001-01-03\", \"m1\", \"6.0\"))\n  );", "modifier": "private static final", "type": "List<InputRow>", "declarator": "ROWS2 = ImmutableList.of(\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2001-01-01\", \"m1\", \"4.0\", \"dim2\", ImmutableList.of(\"a\"))),\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2001-01-02\", \"m1\", \"5.0\", \"dim2\", ImmutableList.of(\"abc\"))),\n      CalciteTests.createRow(ImmutableMap.of(\"t\", \"2001-01-03\", \"m1\", \"6.0\"))\n  )", "var_name": "ROWS2"}, {"original_string": "private static QueryRunnerFactoryConglomerate conglomerate;", "modifier": "private static", "type": "QueryRunnerFactoryConglomerate", "declarator": "conglomerate", "var_name": "conglomerate"}, {"original_string": "private static Closer resourceCloser;", "modifier": "private static", "type": "Closer", "declarator": "resourceCloser", "var_name": "resourceCloser"}, {"original_string": "private TestServerInventoryView serverView;", "modifier": "private", "type": "TestServerInventoryView", "declarator": "serverView", "var_name": "serverView"}, {"original_string": "private List<ImmutableDruidServer> druidServers;", "modifier": "private", "type": "List<ImmutableDruidServer>", "declarator": "druidServers", "var_name": "druidServers"}, {"original_string": "private CountDownLatch getDatasourcesLatch = new CountDownLatch(1);", "modifier": "private", "type": "CountDownLatch", "declarator": "getDatasourcesLatch = new CountDownLatch(1)", "var_name": "getDatasourcesLatch"}, {"original_string": "private CountDownLatch buildTableLatch = new CountDownLatch(1);", "modifier": "private", "type": "CountDownLatch", "declarator": "buildTableLatch = new CountDownLatch(1)", "var_name": "buildTableLatch"}, {"original_string": "@Rule\n  public TemporaryFolder temporaryFolder = new TemporaryFolder();", "modifier": "@Rule\n  public", "type": "TemporaryFolder", "declarator": "temporaryFolder = new TemporaryFolder()", "var_name": "temporaryFolder"}, {"original_string": "private SpecificSegmentsQuerySegmentWalker walker = null;", "modifier": "private", "type": "SpecificSegmentsQuerySegmentWalker", "declarator": "walker = null", "var_name": "walker"}, {"original_string": "private DruidSchema schema = null;", "modifier": "private", "type": "DruidSchema", "declarator": "schema = null", "var_name": "schema"}, {"original_string": "private SegmentManager segmentManager;", "modifier": "private", "type": "SegmentManager", "declarator": "segmentManager", "var_name": "segmentManager"}, {"original_string": "private Set<String> segmentDataSourceNames;", "modifier": "private", "type": "Set<String>", "declarator": "segmentDataSourceNames", "var_name": "segmentDataSourceNames"}, {"original_string": "private Set<String> joinableDataSourceNames;", "modifier": "private", "type": "Set<String>", "declarator": "joinableDataSourceNames", "var_name": "joinableDataSourceNames"}], "file": "sql/src/test/java/org/apache/druid/sql/calcite/schema/DruidSchemaTest.java"}, "test_case": {"identifier": "testGetTableMapFoo", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testGetTableMapFoo()\n  {\n    final DruidTable fooTable = (DruidTable) schema.getTableMap().get(\"foo\");\n    final RelDataType rowType = fooTable.getRowType(new JavaTypeFactoryImpl());\n    final List<RelDataTypeField> fields = rowType.getFieldList();\n\n    Assert.assertEquals(6, fields.size());\n\n    Assert.assertEquals(\"__time\", fields.get(0).getName());\n    Assert.assertEquals(SqlTypeName.TIMESTAMP, fields.get(0).getType().getSqlTypeName());\n\n    Assert.assertEquals(\"cnt\", fields.get(1).getName());\n    Assert.assertEquals(SqlTypeName.BIGINT, fields.get(1).getType().getSqlTypeName());\n\n    Assert.assertEquals(\"dim1\", fields.get(2).getName());\n    Assert.assertEquals(SqlTypeName.VARCHAR, fields.get(2).getType().getSqlTypeName());\n\n    Assert.assertEquals(\"dim2\", fields.get(3).getName());\n    Assert.assertEquals(SqlTypeName.VARCHAR, fields.get(3).getType().getSqlTypeName());\n\n    Assert.assertEquals(\"m1\", fields.get(4).getName());\n    Assert.assertEquals(SqlTypeName.BIGINT, fields.get(4).getType().getSqlTypeName());\n\n    Assert.assertEquals(\"unique_dim1\", fields.get(5).getName());\n    Assert.assertEquals(SqlTypeName.OTHER, fields.get(5).getType().getSqlTypeName());\n  }", "signature": "void testGetTableMapFoo()", "full_signature": "@Test public void testGetTableMapFoo()", "class_method_signature": "DruidSchemaTest.testGetTableMapFoo()", "testcase": true, "constructor": false, "invocations": ["get", "getTableMap", "getRowType", "getFieldList", "assertEquals", "size", "assertEquals", "getName", "get", "assertEquals", "getSqlTypeName", "getType", "get", "assertEquals", "getName", "get", "assertEquals", "getSqlTypeName", "getType", "get", "assertEquals", "getName", "get", "assertEquals", "getSqlTypeName", "getType", "get", "assertEquals", "getName", "get", "assertEquals", "getSqlTypeName", "getType", "get", "assertEquals", "getName", "get", "assertEquals", "getSqlTypeName", "getType", "get", "assertEquals", "getName", "get", "assertEquals", "getSqlTypeName", "getType", "get"]}, "focal_class": {"identifier": "DruidSchema", "superclass": "extends AbstractSchema", "interfaces": "", "fields": [{"original_string": "private static final Comparator<SegmentId> SEGMENT_ORDER = Comparator\n      .comparing((SegmentId segmentId) -> segmentId.getInterval().getStart())\n      .reversed()\n      .thenComparing(Function.identity());", "modifier": "private static final", "type": "Comparator<SegmentId>", "declarator": "SEGMENT_ORDER = Comparator\n      .comparing((SegmentId segmentId) -> segmentId.getInterval().getStart())\n      .reversed()\n      .thenComparing(Function.identity())", "var_name": "SEGMENT_ORDER"}, {"original_string": "private static final EmittingLogger log = new EmittingLogger(DruidSchema.class);", "modifier": "private static final", "type": "EmittingLogger", "declarator": "log = new EmittingLogger(DruidSchema.class)", "var_name": "log"}, {"original_string": "private static final int MAX_SEGMENTS_PER_QUERY = 15000;", "modifier": "private static final", "type": "int", "declarator": "MAX_SEGMENTS_PER_QUERY = 15000", "var_name": "MAX_SEGMENTS_PER_QUERY"}, {"original_string": "private static final long DEFAULT_NUM_ROWS = 0;", "modifier": "private static final", "type": "long", "declarator": "DEFAULT_NUM_ROWS = 0", "var_name": "DEFAULT_NUM_ROWS"}, {"original_string": "private final QueryLifecycleFactory queryLifecycleFactory;", "modifier": "private final", "type": "QueryLifecycleFactory", "declarator": "queryLifecycleFactory", "var_name": "queryLifecycleFactory"}, {"original_string": "private final PlannerConfig config;", "modifier": "private final", "type": "PlannerConfig", "declarator": "config", "var_name": "config"}, {"original_string": "private final SegmentManager segmentManager;", "modifier": "private final", "type": "SegmentManager", "declarator": "segmentManager", "var_name": "segmentManager"}, {"original_string": "private final ViewManager viewManager;", "modifier": "private final", "type": "ViewManager", "declarator": "viewManager", "var_name": "viewManager"}, {"original_string": "private final JoinableFactory joinableFactory;", "modifier": "private final", "type": "JoinableFactory", "declarator": "joinableFactory", "var_name": "joinableFactory"}, {"original_string": "private final ExecutorService cacheExec;", "modifier": "private final", "type": "ExecutorService", "declarator": "cacheExec", "var_name": "cacheExec"}, {"original_string": "private final ConcurrentMap<String, DruidTable> tables;", "modifier": "private final", "type": "ConcurrentMap<String, DruidTable>", "declarator": "tables", "var_name": "tables"}, {"original_string": "private final CountDownLatch initialized = new CountDownLatch(1);", "modifier": "private final", "type": "CountDownLatch", "declarator": "initialized = new CountDownLatch(1)", "var_name": "initialized"}, {"original_string": "private final Object lock = new Object();", "modifier": "private final", "type": "Object", "declarator": "lock = new Object()", "var_name": "lock"}, {"original_string": "@GuardedBy(\"lock\")\n  private final Map<String, TreeMap<SegmentId, AvailableSegmentMetadata>> segmentMetadataInfo = new HashMap<>();", "modifier": "@GuardedBy(\"lock\")\n  private final", "type": "Map<String, TreeMap<SegmentId, AvailableSegmentMetadata>>", "declarator": "segmentMetadataInfo = new HashMap<>()", "var_name": "segmentMetadataInfo"}, {"original_string": "private int totalSegments = 0;", "modifier": "private", "type": "int", "declarator": "totalSegments = 0", "var_name": "totalSegments"}, {"original_string": "@GuardedBy(\"lock\")\n  private final Set<SegmentId> mutableSegments = new TreeSet<>(SEGMENT_ORDER);", "modifier": "@GuardedBy(\"lock\")\n  private final", "type": "Set<SegmentId>", "declarator": "mutableSegments = new TreeSet<>(SEGMENT_ORDER)", "var_name": "mutableSegments"}, {"original_string": "@GuardedBy(\"lock\")\n  private final Set<String> dataSourcesNeedingRebuild = new HashSet<>();", "modifier": "@GuardedBy(\"lock\")\n  private final", "type": "Set<String>", "declarator": "dataSourcesNeedingRebuild = new HashSet<>()", "var_name": "dataSourcesNeedingRebuild"}, {"original_string": "@GuardedBy(\"lock\")\n  private final TreeSet<SegmentId> segmentsNeedingRefresh = new TreeSet<>(SEGMENT_ORDER);", "modifier": "@GuardedBy(\"lock\")\n  private final", "type": "TreeSet<SegmentId>", "declarator": "segmentsNeedingRefresh = new TreeSet<>(SEGMENT_ORDER)", "var_name": "segmentsNeedingRefresh"}, {"original_string": "private final Escalator escalator;", "modifier": "private final", "type": "Escalator", "declarator": "escalator", "var_name": "escalator"}, {"original_string": "@GuardedBy(\"lock\")\n  private boolean refreshImmediately = false;", "modifier": "@GuardedBy(\"lock\")\n  private", "type": "boolean", "declarator": "refreshImmediately = false", "var_name": "refreshImmediately"}, {"original_string": "@GuardedBy(\"lock\")\n  private long lastRefresh = 0L;", "modifier": "@GuardedBy(\"lock\")\n  private", "type": "long", "declarator": "lastRefresh = 0L", "var_name": "lastRefresh"}, {"original_string": "@GuardedBy(\"lock\")\n  private long lastFailure = 0L;", "modifier": "@GuardedBy(\"lock\")\n  private", "type": "long", "declarator": "lastFailure = 0L", "var_name": "lastFailure"}, {"original_string": "@GuardedBy(\"lock\")\n  private boolean isServerViewInitialized = false;", "modifier": "@GuardedBy(\"lock\")\n  private", "type": "boolean", "declarator": "isServerViewInitialized = false", "var_name": "isServerViewInitialized"}], "methods": [{"identifier": "DruidSchema", "parameters": "(\n      final QueryLifecycleFactory queryLifecycleFactory,\n      final TimelineServerView serverView,\n      final SegmentManager segmentManager,\n      final JoinableFactory joinableFactory,\n      final PlannerConfig config,\n      final ViewManager viewManager,\n      final Escalator escalator\n  )", "modifiers": "@Inject public", "return": "", "signature": " DruidSchema(\n      final QueryLifecycleFactory queryLifecycleFactory,\n      final TimelineServerView serverView,\n      final SegmentManager segmentManager,\n      final JoinableFactory joinableFactory,\n      final PlannerConfig config,\n      final ViewManager viewManager,\n      final Escalator escalator\n  )", "full_signature": "@Inject public  DruidSchema(\n      final QueryLifecycleFactory queryLifecycleFactory,\n      final TimelineServerView serverView,\n      final SegmentManager segmentManager,\n      final JoinableFactory joinableFactory,\n      final PlannerConfig config,\n      final ViewManager viewManager,\n      final Escalator escalator\n  )", "class_method_signature": "DruidSchema.DruidSchema(\n      final QueryLifecycleFactory queryLifecycleFactory,\n      final TimelineServerView serverView,\n      final SegmentManager segmentManager,\n      final JoinableFactory joinableFactory,\n      final PlannerConfig config,\n      final ViewManager viewManager,\n      final Escalator escalator\n  )", "testcase": false, "constructor": true}, {"identifier": "start", "parameters": "()", "modifiers": "@LifecycleStart public", "return": "void", "signature": "void start()", "full_signature": "@LifecycleStart public void start()", "class_method_signature": "DruidSchema.start()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "@LifecycleStop public", "return": "void", "signature": "void stop()", "full_signature": "@LifecycleStop public void stop()", "class_method_signature": "DruidSchema.stop()", "testcase": false, "constructor": false}, {"identifier": "awaitInitialization", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void awaitInitialization()", "full_signature": "public void awaitInitialization()", "class_method_signature": "DruidSchema.awaitInitialization()", "testcase": false, "constructor": false}, {"identifier": "getTableMap", "parameters": "()", "modifiers": "@Override protected", "return": "Map<String, Table>", "signature": "Map<String, Table> getTableMap()", "full_signature": "@Override protected Map<String, Table> getTableMap()", "class_method_signature": "DruidSchema.getTableMap()", "testcase": false, "constructor": false}, {"identifier": "getFunctionMultimap", "parameters": "()", "modifiers": "@Override protected", "return": "Multimap<String, org.apache.calcite.schema.Function>", "signature": "Multimap<String, org.apache.calcite.schema.Function> getFunctionMultimap()", "full_signature": "@Override protected Multimap<String, org.apache.calcite.schema.Function> getFunctionMultimap()", "class_method_signature": "DruidSchema.getFunctionMultimap()", "testcase": false, "constructor": false}, {"identifier": "addSegment", "parameters": "(final DruidServerMetadata server, final DataSegment segment)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void addSegment(final DruidServerMetadata server, final DataSegment segment)", "full_signature": "@VisibleForTesting void addSegment(final DruidServerMetadata server, final DataSegment segment)", "class_method_signature": "DruidSchema.addSegment(final DruidServerMetadata server, final DataSegment segment)", "testcase": false, "constructor": false}, {"identifier": "removeSegment", "parameters": "(final DataSegment segment)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void removeSegment(final DataSegment segment)", "full_signature": "@VisibleForTesting void removeSegment(final DataSegment segment)", "class_method_signature": "DruidSchema.removeSegment(final DataSegment segment)", "testcase": false, "constructor": false}, {"identifier": "removeServerSegment", "parameters": "(final DruidServerMetadata server, final DataSegment segment)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void removeServerSegment(final DruidServerMetadata server, final DataSegment segment)", "full_signature": "@VisibleForTesting void removeServerSegment(final DruidServerMetadata server, final DataSegment segment)", "class_method_signature": "DruidSchema.removeServerSegment(final DruidServerMetadata server, final DataSegment segment)", "testcase": false, "constructor": false}, {"identifier": "refreshSegments", "parameters": "(final Set<SegmentId> segments)", "modifiers": "@VisibleForTesting", "return": "Set<SegmentId>", "signature": "Set<SegmentId> refreshSegments(final Set<SegmentId> segments)", "full_signature": "@VisibleForTesting Set<SegmentId> refreshSegments(final Set<SegmentId> segments)", "class_method_signature": "DruidSchema.refreshSegments(final Set<SegmentId> segments)", "testcase": false, "constructor": false}, {"identifier": "recomputeIsRealtime", "parameters": "(ImmutableSet<DruidServerMetadata> servers)", "modifiers": "private", "return": "long", "signature": "long recomputeIsRealtime(ImmutableSet<DruidServerMetadata> servers)", "full_signature": "private long recomputeIsRealtime(ImmutableSet<DruidServerMetadata> servers)", "class_method_signature": "DruidSchema.recomputeIsRealtime(ImmutableSet<DruidServerMetadata> servers)", "testcase": false, "constructor": false}, {"identifier": "refreshSegmentsForDataSource", "parameters": "(final String dataSource, final Set<SegmentId> segments)", "modifiers": "private", "return": "Set<SegmentId>", "signature": "Set<SegmentId> refreshSegmentsForDataSource(final String dataSource, final Set<SegmentId> segments)", "full_signature": "private Set<SegmentId> refreshSegmentsForDataSource(final String dataSource, final Set<SegmentId> segments)", "class_method_signature": "DruidSchema.refreshSegmentsForDataSource(final String dataSource, final Set<SegmentId> segments)", "testcase": false, "constructor": false}, {"identifier": "setAvailableSegmentMetadata", "parameters": "(final SegmentId segmentId, final AvailableSegmentMetadata availableSegmentMetadata)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void setAvailableSegmentMetadata(final SegmentId segmentId, final AvailableSegmentMetadata availableSegmentMetadata)", "full_signature": "@VisibleForTesting void setAvailableSegmentMetadata(final SegmentId segmentId, final AvailableSegmentMetadata availableSegmentMetadata)", "class_method_signature": "DruidSchema.setAvailableSegmentMetadata(final SegmentId segmentId, final AvailableSegmentMetadata availableSegmentMetadata)", "testcase": false, "constructor": false}, {"identifier": "buildDruidTable", "parameters": "(final String dataSource)", "modifiers": "protected", "return": "DruidTable", "signature": "DruidTable buildDruidTable(final String dataSource)", "full_signature": "protected DruidTable buildDruidTable(final String dataSource)", "class_method_signature": "DruidSchema.buildDruidTable(final String dataSource)", "testcase": false, "constructor": false}, {"identifier": "runSegmentMetadataQuery", "parameters": "(\n      final QueryLifecycleFactory queryLifecycleFactory,\n      final Iterable<SegmentId> segments,\n      final AuthenticationResult authenticationResult\n  )", "modifiers": "private static", "return": "Sequence<SegmentAnalysis>", "signature": "Sequence<SegmentAnalysis> runSegmentMetadataQuery(\n      final QueryLifecycleFactory queryLifecycleFactory,\n      final Iterable<SegmentId> segments,\n      final AuthenticationResult authenticationResult\n  )", "full_signature": "private static Sequence<SegmentAnalysis> runSegmentMetadataQuery(\n      final QueryLifecycleFactory queryLifecycleFactory,\n      final Iterable<SegmentId> segments,\n      final AuthenticationResult authenticationResult\n  )", "class_method_signature": "DruidSchema.runSegmentMetadataQuery(\n      final QueryLifecycleFactory queryLifecycleFactory,\n      final Iterable<SegmentId> segments,\n      final AuthenticationResult authenticationResult\n  )", "testcase": false, "constructor": false}, {"identifier": "analysisToRowSignature", "parameters": "(final SegmentAnalysis analysis)", "modifiers": "private static", "return": "RowSignature", "signature": "RowSignature analysisToRowSignature(final SegmentAnalysis analysis)", "full_signature": "private static RowSignature analysisToRowSignature(final SegmentAnalysis analysis)", "class_method_signature": "DruidSchema.analysisToRowSignature(final SegmentAnalysis analysis)", "testcase": false, "constructor": false}, {"identifier": "getSegmentMetadataSnapshot", "parameters": "()", "modifiers": "", "return": "Map<SegmentId, AvailableSegmentMetadata>", "signature": "Map<SegmentId, AvailableSegmentMetadata> getSegmentMetadataSnapshot()", "full_signature": " Map<SegmentId, AvailableSegmentMetadata> getSegmentMetadataSnapshot()", "class_method_signature": "DruidSchema.getSegmentMetadataSnapshot()", "testcase": false, "constructor": false}, {"identifier": "getTotalSegments", "parameters": "()", "modifiers": "", "return": "int", "signature": "int getTotalSegments()", "full_signature": " int getTotalSegments()", "class_method_signature": "DruidSchema.getTotalSegments()", "testcase": false, "constructor": false}], "file": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java"}, "focal_method": {"identifier": "getTableMap", "parameters": "()", "modifiers": "@Override protected", "return": "Map<String, Table>", "body": "@Override\n  protected Map<String, Table> getTableMap()\n  {\n    return ImmutableMap.copyOf(tables);\n  }", "signature": "Map<String, Table> getTableMap()", "full_signature": "@Override protected Map<String, Table> getTableMap()", "class_method_signature": "DruidSchema.getTableMap()", "testcase": false, "constructor": false, "invocations": ["copyOf"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}