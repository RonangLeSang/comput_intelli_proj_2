{"test_class": {"identifier": "TaskLockboxTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n  public final TestDerbyConnector.DerbyConnectorRule derby = new TestDerbyConnector.DerbyConnectorRule();", "modifier": "@Rule\n  public final", "type": "TestDerbyConnector.DerbyConnectorRule", "declarator": "derby = new TestDerbyConnector.DerbyConnectorRule()", "var_name": "derby"}, {"original_string": "@Rule\n  public ExpectedException expectedException = ExpectedException.none();", "modifier": "@Rule\n  public", "type": "ExpectedException", "declarator": "expectedException = ExpectedException.none()", "var_name": "expectedException"}, {"original_string": "private ObjectMapper objectMapper;", "modifier": "private", "type": "ObjectMapper", "declarator": "objectMapper", "var_name": "objectMapper"}, {"original_string": "private TaskStorage taskStorage;", "modifier": "private", "type": "TaskStorage", "declarator": "taskStorage", "var_name": "taskStorage"}, {"original_string": "private IndexerMetadataStorageCoordinator metadataStorageCoordinator;", "modifier": "private", "type": "IndexerMetadataStorageCoordinator", "declarator": "metadataStorageCoordinator", "var_name": "metadataStorageCoordinator"}, {"original_string": "private TaskLockbox lockbox;", "modifier": "private", "type": "TaskLockbox", "declarator": "lockbox", "var_name": "lockbox"}, {"original_string": "@Rule\n  public final ExpectedException exception = ExpectedException.none();", "modifier": "@Rule\n  public final", "type": "ExpectedException", "declarator": "exception = ExpectedException.none()", "var_name": "exception"}, {"original_string": "private static String TASK_NAME = \"myModuleIsntLoadedTask\";", "modifier": "private static", "type": "String", "declarator": "TASK_NAME = \"myModuleIsntLoadedTask\"", "var_name": "TASK_NAME"}], "file": "indexing-service/src/test/java/org/apache/druid/indexing/overlord/TaskLockboxTest.java"}, "test_case": {"identifier": "testTimeoutForLock", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testTimeoutForLock() throws InterruptedException\n  {\n    Task task1 = NoopTask.create();\n    Task task2 = NoopTask.create();\n\n    lockbox.add(task1);\n    lockbox.add(task2);\n    Assert.assertTrue(acquireTimeChunkLock(TaskLockType.EXCLUSIVE, task1, Intervals.of(\"2015-01-01/2015-01-02\"), 5000).isOk());\n    Assert.assertFalse(acquireTimeChunkLock(TaskLockType.EXCLUSIVE, task2, Intervals.of(\"2015-01-01/2015-01-15\"), 1000).isOk());\n  }", "signature": "void testTimeoutForLock()", "full_signature": "@Test public void testTimeoutForLock()", "class_method_signature": "TaskLockboxTest.testTimeoutForLock()", "testcase": true, "constructor": false, "invocations": ["create", "create", "add", "add", "assertTrue", "isOk", "acquireTimeChunkLock", "of", "assertFalse", "isOk", "acquireTimeChunkLock", "of"]}, "focal_class": {"identifier": "TaskLockbox", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Map<String, NavigableMap<DateTime, SortedMap<Interval, List<TaskLockPosse>>>> running = new HashMap<>();", "modifier": "private final", "type": "Map<String, NavigableMap<DateTime, SortedMap<Interval, List<TaskLockPosse>>>>", "declarator": "running = new HashMap<>()", "var_name": "running"}, {"original_string": "private final TaskStorage taskStorage;", "modifier": "private final", "type": "TaskStorage", "declarator": "taskStorage", "var_name": "taskStorage"}, {"original_string": "private final IndexerMetadataStorageCoordinator metadataStorageCoordinator;", "modifier": "private final", "type": "IndexerMetadataStorageCoordinator", "declarator": "metadataStorageCoordinator", "var_name": "metadataStorageCoordinator"}, {"original_string": "private final ReentrantLock giant = new ReentrantLock(true);", "modifier": "private final", "type": "ReentrantLock", "declarator": "giant = new ReentrantLock(true)", "var_name": "giant"}, {"original_string": "private final Condition lockReleaseCondition = giant.newCondition();", "modifier": "private final", "type": "Condition", "declarator": "lockReleaseCondition = giant.newCondition()", "var_name": "lockReleaseCondition"}, {"original_string": "private static final EmittingLogger log = new EmittingLogger(TaskLockbox.class);", "modifier": "private static final", "type": "EmittingLogger", "declarator": "log = new EmittingLogger(TaskLockbox.class)", "var_name": "log"}, {"original_string": "private final Set<String> activeTasks = new HashSet<>();", "modifier": "private final", "type": "Set<String>", "declarator": "activeTasks = new HashSet<>()", "var_name": "activeTasks"}], "methods": [{"identifier": "TaskLockbox", "parameters": "(\n      TaskStorage taskStorage,\n      IndexerMetadataStorageCoordinator metadataStorageCoordinator\n  )", "modifiers": "@Inject public", "return": "", "signature": " TaskLockbox(\n      TaskStorage taskStorage,\n      IndexerMetadataStorageCoordinator metadataStorageCoordinator\n  )", "full_signature": "@Inject public  TaskLockbox(\n      TaskStorage taskStorage,\n      IndexerMetadataStorageCoordinator metadataStorageCoordinator\n  )", "class_method_signature": "TaskLockbox.TaskLockbox(\n      TaskStorage taskStorage,\n      IndexerMetadataStorageCoordinator metadataStorageCoordinator\n  )", "testcase": false, "constructor": true}, {"identifier": "syncFromStorage", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void syncFromStorage()", "full_signature": "public void syncFromStorage()", "class_method_signature": "TaskLockbox.syncFromStorage()", "testcase": false, "constructor": false}, {"identifier": "verifyAndCreateOrFindLockPosse", "parameters": "(Task task, TaskLock taskLock)", "modifiers": "private", "return": "TaskLockPosse", "signature": "TaskLockPosse verifyAndCreateOrFindLockPosse(Task task, TaskLock taskLock)", "full_signature": "private TaskLockPosse verifyAndCreateOrFindLockPosse(Task task, TaskLock taskLock)", "class_method_signature": "TaskLockbox.verifyAndCreateOrFindLockPosse(Task task, TaskLock taskLock)", "testcase": false, "constructor": false}, {"identifier": "lock", "parameters": "(final Task task, final LockRequest request)", "modifiers": "public", "return": "LockResult", "signature": "LockResult lock(final Task task, final LockRequest request)", "full_signature": "public LockResult lock(final Task task, final LockRequest request)", "class_method_signature": "TaskLockbox.lock(final Task task, final LockRequest request)", "testcase": false, "constructor": false}, {"identifier": "lock", "parameters": "(final Task task, final LockRequest request, long timeoutMs)", "modifiers": "public", "return": "LockResult", "signature": "LockResult lock(final Task task, final LockRequest request, long timeoutMs)", "full_signature": "public LockResult lock(final Task task, final LockRequest request, long timeoutMs)", "class_method_signature": "TaskLockbox.lock(final Task task, final LockRequest request, long timeoutMs)", "testcase": false, "constructor": false}, {"identifier": "tryLock", "parameters": "(final Task task, final LockRequest request)", "modifiers": "public", "return": "LockResult", "signature": "LockResult tryLock(final Task task, final LockRequest request)", "full_signature": "public LockResult tryLock(final Task task, final LockRequest request)", "class_method_signature": "TaskLockbox.tryLock(final Task task, final LockRequest request)", "testcase": false, "constructor": false}, {"identifier": "createOrFindLockPosse", "parameters": "(LockRequest request)", "modifiers": "private", "return": "TaskLockPosse", "signature": "TaskLockPosse createOrFindLockPosse(LockRequest request)", "full_signature": "private TaskLockPosse createOrFindLockPosse(LockRequest request)", "class_method_signature": "TaskLockbox.createOrFindLockPosse(LockRequest request)", "testcase": false, "constructor": false}, {"identifier": "createNewTaskLockPosse", "parameters": "(LockRequest request)", "modifiers": "private", "return": "TaskLockPosse", "signature": "TaskLockPosse createNewTaskLockPosse(LockRequest request)", "full_signature": "private TaskLockPosse createNewTaskLockPosse(LockRequest request)", "class_method_signature": "TaskLockbox.createNewTaskLockPosse(LockRequest request)", "testcase": false, "constructor": false}, {"identifier": "allocateSegmentId", "parameters": "(LockRequestForNewSegment request, String version)", "modifiers": "private", "return": "SegmentIdWithShardSpec", "signature": "SegmentIdWithShardSpec allocateSegmentId(LockRequestForNewSegment request, String version)", "full_signature": "private SegmentIdWithShardSpec allocateSegmentId(LockRequestForNewSegment request, String version)", "class_method_signature": "TaskLockbox.allocateSegmentId(LockRequestForNewSegment request, String version)", "testcase": false, "constructor": false}, {"identifier": "doInCriticalSection", "parameters": "(Task task, List<Interval> intervals, CriticalAction<T> action)", "modifiers": "public", "return": "T", "signature": "T doInCriticalSection(Task task, List<Interval> intervals, CriticalAction<T> action)", "full_signature": "public T doInCriticalSection(Task task, List<Interval> intervals, CriticalAction<T> action)", "class_method_signature": "TaskLockbox.doInCriticalSection(Task task, List<Interval> intervals, CriticalAction<T> action)", "testcase": false, "constructor": false}, {"identifier": "isTaskLocksValid", "parameters": "(Task task, List<Interval> intervals)", "modifiers": "private", "return": "boolean", "signature": "boolean isTaskLocksValid(Task task, List<Interval> intervals)", "full_signature": "private boolean isTaskLocksValid(Task task, List<Interval> intervals)", "class_method_signature": "TaskLockbox.isTaskLocksValid(Task task, List<Interval> intervals)", "testcase": false, "constructor": false}, {"identifier": "revokeLock", "parameters": "(TaskLockPosse lockPosse)", "modifiers": "private", "return": "void", "signature": "void revokeLock(TaskLockPosse lockPosse)", "full_signature": "private void revokeLock(TaskLockPosse lockPosse)", "class_method_signature": "TaskLockbox.revokeLock(TaskLockPosse lockPosse)", "testcase": false, "constructor": false}, {"identifier": "revokeLock", "parameters": "(String taskId, TaskLock lock)", "modifiers": "private", "return": "void", "signature": "void revokeLock(String taskId, TaskLock lock)", "full_signature": "private void revokeLock(String taskId, TaskLock lock)", "class_method_signature": "TaskLockbox.revokeLock(String taskId, TaskLock lock)", "testcase": false, "constructor": false}, {"identifier": "findLocksForTask", "parameters": "(final Task task)", "modifiers": "public", "return": "List<TaskLock>", "signature": "List<TaskLock> findLocksForTask(final Task task)", "full_signature": "public List<TaskLock> findLocksForTask(final Task task)", "class_method_signature": "TaskLockbox.findLocksForTask(final Task task)", "testcase": false, "constructor": false}, {"identifier": "unlock", "parameters": "(final Task task, final Interval interval)", "modifiers": "public", "return": "void", "signature": "void unlock(final Task task, final Interval interval)", "full_signature": "public void unlock(final Task task, final Interval interval)", "class_method_signature": "TaskLockbox.unlock(final Task task, final Interval interval)", "testcase": false, "constructor": false}, {"identifier": "unlock", "parameters": "(final Task task, final Interval interval, @Nullable Integer partitionId)", "modifiers": "public", "return": "void", "signature": "void unlock(final Task task, final Interval interval, @Nullable Integer partitionId)", "full_signature": "public void unlock(final Task task, final Interval interval, @Nullable Integer partitionId)", "class_method_signature": "TaskLockbox.unlock(final Task task, final Interval interval, @Nullable Integer partitionId)", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(Task task)", "modifiers": "public", "return": "void", "signature": "void add(Task task)", "full_signature": "public void add(Task task)", "class_method_signature": "TaskLockbox.add(Task task)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(final Task task)", "modifiers": "public", "return": "void", "signature": "void remove(final Task task)", "full_signature": "public void remove(final Task task)", "class_method_signature": "TaskLockbox.remove(final Task task)", "testcase": false, "constructor": false}, {"identifier": "findLockPossesForTask", "parameters": "(final Task task)", "modifiers": "private", "return": "List<TaskLockPosse>", "signature": "List<TaskLockPosse> findLockPossesForTask(final Task task)", "full_signature": "private List<TaskLockPosse> findLockPossesForTask(final Task task)", "class_method_signature": "TaskLockbox.findLockPossesForTask(final Task task)", "testcase": false, "constructor": false}, {"identifier": "findLockPossesContainingInterval", "parameters": "(final String dataSource, final Interval interval)", "modifiers": "private", "return": "List<TaskLockPosse>", "signature": "List<TaskLockPosse> findLockPossesContainingInterval(final String dataSource, final Interval interval)", "full_signature": "private List<TaskLockPosse> findLockPossesContainingInterval(final String dataSource, final Interval interval)", "class_method_signature": "TaskLockbox.findLockPossesContainingInterval(final String dataSource, final Interval interval)", "testcase": false, "constructor": false}, {"identifier": "findLockPossesOverlapsInterval", "parameters": "(final String dataSource, final Interval interval)", "modifiers": "private", "return": "List<TaskLockPosse>", "signature": "List<TaskLockPosse> findLockPossesOverlapsInterval(final String dataSource, final Interval interval)", "full_signature": "private List<TaskLockPosse> findLockPossesOverlapsInterval(final String dataSource, final Interval interval)", "class_method_signature": "TaskLockbox.findLockPossesOverlapsInterval(final String dataSource, final Interval interval)", "testcase": false, "constructor": false}, {"identifier": "getOnlyTaskLockPosseContainingInterval", "parameters": "(Task task, Interval interval)", "modifiers": "@VisibleForTesting", "return": "List<TaskLockPosse>", "signature": "List<TaskLockPosse> getOnlyTaskLockPosseContainingInterval(Task task, Interval interval)", "full_signature": "@VisibleForTesting List<TaskLockPosse> getOnlyTaskLockPosseContainingInterval(Task task, Interval interval)", "class_method_signature": "TaskLockbox.getOnlyTaskLockPosseContainingInterval(Task task, Interval interval)", "testcase": false, "constructor": false}, {"identifier": "getOnlyTaskLockPosseContainingInterval", "parameters": "(Task task, Interval interval, Set<Integer> partitionIds)", "modifiers": "@VisibleForTesting", "return": "List<TaskLockPosse>", "signature": "List<TaskLockPosse> getOnlyTaskLockPosseContainingInterval(Task task, Interval interval, Set<Integer> partitionIds)", "full_signature": "@VisibleForTesting List<TaskLockPosse> getOnlyTaskLockPosseContainingInterval(Task task, Interval interval, Set<Integer> partitionIds)", "class_method_signature": "TaskLockbox.getOnlyTaskLockPosseContainingInterval(Task task, Interval interval, Set<Integer> partitionIds)", "testcase": false, "constructor": false}, {"identifier": "getActiveTasks", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "Set<String>", "signature": "Set<String> getActiveTasks()", "full_signature": "@VisibleForTesting Set<String> getActiveTasks()", "class_method_signature": "TaskLockbox.getActiveTasks()", "testcase": false, "constructor": false}, {"identifier": "getAllLocks", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "Map<String, NavigableMap<DateTime, SortedMap<Interval, List<TaskLockPosse>>>>", "signature": "Map<String, NavigableMap<DateTime, SortedMap<Interval, List<TaskLockPosse>>>> getAllLocks()", "full_signature": "@VisibleForTesting Map<String, NavigableMap<DateTime, SortedMap<Interval, List<TaskLockPosse>>>> getAllLocks()", "class_method_signature": "TaskLockbox.getAllLocks()", "testcase": false, "constructor": false}, {"identifier": "isAllSharedLocks", "parameters": "(List<TaskLockPosse> lockPosses)", "modifiers": "private static", "return": "boolean", "signature": "boolean isAllSharedLocks(List<TaskLockPosse> lockPosses)", "full_signature": "private static boolean isAllSharedLocks(List<TaskLockPosse> lockPosses)", "class_method_signature": "TaskLockbox.isAllSharedLocks(List<TaskLockPosse> lockPosses)", "testcase": false, "constructor": false}, {"identifier": "isAllRevocable", "parameters": "(List<TaskLockPosse> lockPosses, int tryLockPriority)", "modifiers": "private static", "return": "boolean", "signature": "boolean isAllRevocable(List<TaskLockPosse> lockPosses, int tryLockPriority)", "full_signature": "private static boolean isAllRevocable(List<TaskLockPosse> lockPosses, int tryLockPriority)", "class_method_signature": "TaskLockbox.isAllRevocable(List<TaskLockPosse> lockPosses, int tryLockPriority)", "testcase": false, "constructor": false}, {"identifier": "isRevocable", "parameters": "(TaskLockPosse lockPosse, int tryLockPriority)", "modifiers": "private static", "return": "boolean", "signature": "boolean isRevocable(TaskLockPosse lockPosse, int tryLockPriority)", "full_signature": "private static boolean isRevocable(TaskLockPosse lockPosse, int tryLockPriority)", "class_method_signature": "TaskLockbox.isRevocable(TaskLockPosse lockPosse, int tryLockPriority)", "testcase": false, "constructor": false}], "file": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/TaskLockbox.java"}, "focal_method": {"identifier": "add", "parameters": "(Task task)", "modifiers": "public", "return": "void", "body": "public void add(Task task)\n  {\n    giant.lock();\n    try {\n      log.info(\"Adding task[%s] to activeTasks\", task.getId());\n      activeTasks.add(task.getId());\n    }\n    finally {\n      giant.unlock();\n    }\n  }", "signature": "void add(Task task)", "full_signature": "public void add(Task task)", "class_method_signature": "TaskLockbox.add(Task task)", "testcase": false, "constructor": false, "invocations": ["lock", "info", "getId", "add", "getId", "unlock"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}