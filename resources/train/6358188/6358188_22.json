{"test_class": {"identifier": "ImmutableConciseSetTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int NO_COMPLEMENT_LENGTH = -1;", "modifier": "public static final", "type": "int", "declarator": "NO_COMPLEMENT_LENGTH = -1", "var_name": "NO_COMPLEMENT_LENGTH"}], "file": "extendedset/src/test/java/org/apache/druid/extendedset/intset/ImmutableConciseSetTest.java"}, "test_case": {"identifier": "testComplement1", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testComplement1()\n  {\n    final int[] ints = {1, 100};\n    List<Integer> expected = new ArrayList<>();\n\n    ConciseSet set = new ConciseSet();\n    for (int i : ints) {\n      set.add(i);\n    }\n\n    for (int i = 0; i <= 100; i++) {\n      if (i != 1 && i != 100) {\n        expected.add(i);\n      }\n    }\n\n    ImmutableConciseSet testSet = ImmutableConciseSet.newImmutableFromMutable(set);\n\n    verifyComplement(expected, testSet, NO_COMPLEMENT_LENGTH);\n  }", "signature": "void testComplement1()", "full_signature": "@Test public void testComplement1()", "class_method_signature": "ImmutableConciseSetTest.testComplement1()", "testcase": true, "constructor": false, "invocations": ["add", "add", "newImmutableFromMutable", "verifyComplement"]}, "focal_class": {"identifier": "ImmutableConciseSet", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int CHUNK_SIZE = 10000;", "modifier": "private static final", "type": "int", "declarator": "CHUNK_SIZE = 10000", "var_name": "CHUNK_SIZE"}, {"original_string": "private static final Comparator<WordIterator> UNION_COMPARATOR = new Comparator<WordIterator>()\n  {\n    // Comparison is first by index, then one fills < literals < zero fills\n    // one fills are sorted by length (longer one fills have priority)\n    // similarly, shorter zero fills have priority\n    @Override\n    public int compare(WordIterator i1, WordIterator i2)\n    {\n      int s1 = i1.startIndex;\n      int s2 = i2.startIndex;\n\n      if (s1 != s2) {\n        return Integer.compare(s1, s2);\n      }\n\n      int w1 = i1.getWord();\n      int w2 = i2.getWord();\n\n      if (ConciseSetUtils.isLiteral(w1)) {\n        if (ConciseSetUtils.isLiteral(w2)) {\n          return 0;\n        } else if (ConciseSetUtils.isZeroSequence(w2)) {\n          return -1;\n        } else {\n          assert ConciseSetUtils.isOneSequence(w2);\n          return 1;\n        }\n      } else if (ConciseSetUtils.isZeroSequence(w1)) {\n        if (!ConciseSetUtils.isZeroSequence(w2)) {\n          return 1;\n        }\n        return Integer.compare(ConciseSetUtils.getSequenceNumWords(w1), ConciseSetUtils.getSequenceNumWords(w2));\n      } else {\n        assert ConciseSetUtils.isOneSequence(w1);\n        if (ConciseSetUtils.isOneSequence(w2)) {\n          // reverse\n          return Integer.compare(ConciseSetUtils.getSequenceNumWords(w2), ConciseSetUtils.getSequenceNumWords(w1));\n        }\n        return -1;\n      }\n    }\n  };", "modifier": "private static final", "type": "Comparator<WordIterator>", "declarator": "UNION_COMPARATOR = new Comparator<WordIterator>()\n  {\n    // Comparison is first by index, then one fills < literals < zero fills\n    // one fills are sorted by length (longer one fills have priority)\n    // similarly, shorter zero fills have priority\n    @Override\n    public int compare(WordIterator i1, WordIterator i2)\n    {\n      int s1 = i1.startIndex;\n      int s2 = i2.startIndex;\n\n      if (s1 != s2) {\n        return Integer.compare(s1, s2);\n      }\n\n      int w1 = i1.getWord();\n      int w2 = i2.getWord();\n\n      if (ConciseSetUtils.isLiteral(w1)) {\n        if (ConciseSetUtils.isLiteral(w2)) {\n          return 0;\n        } else if (ConciseSetUtils.isZeroSequence(w2)) {\n          return -1;\n        } else {\n          assert ConciseSetUtils.isOneSequence(w2);\n          return 1;\n        }\n      } else if (ConciseSetUtils.isZeroSequence(w1)) {\n        if (!ConciseSetUtils.isZeroSequence(w2)) {\n          return 1;\n        }\n        return Integer.compare(ConciseSetUtils.getSequenceNumWords(w1), ConciseSetUtils.getSequenceNumWords(w2));\n      } else {\n        assert ConciseSetUtils.isOneSequence(w1);\n        if (ConciseSetUtils.isOneSequence(w2)) {\n          // reverse\n          return Integer.compare(ConciseSetUtils.getSequenceNumWords(w2), ConciseSetUtils.getSequenceNumWords(w1));\n        }\n        return -1;\n      }\n    }\n  }", "var_name": "UNION_COMPARATOR"}, {"original_string": "private static final Comparator<WordIterator> INTERSECTION_COMPARATOR = new Comparator<WordIterator>()\n  {\n    // Comparison is first by index, then zero fills < literals < one fills\n    // zero fills are sorted by length (longer zero fills have priority)\n    // similarly, shorter one fills have priority\n    @Override\n    public int compare(WordIterator i1, WordIterator i2)\n    {\n      int s1 = i1.startIndex;\n      int s2 = i2.startIndex;\n\n      if (s1 != s2) {\n        return Integer.compare(s1, s2);\n      }\n\n      int w1 = i1.getWord();\n      int w2 = i2.getWord();\n\n      if (ConciseSetUtils.isLiteral(w1)) {\n        if (ConciseSetUtils.isLiteral(w2)) {\n          return 0;\n        } else if (ConciseSetUtils.isZeroSequence(w2)) {\n          return 1;\n        } else {\n          assert ConciseSetUtils.isOneSequence(w2);\n          return -1;\n        }\n      } else if (ConciseSetUtils.isZeroSequence(w1)) {\n        if (ConciseSetUtils.isZeroSequence(w2)) {\n          // reverse\n          return Integer.compare(ConciseSetUtils.getSequenceNumWords(w2), ConciseSetUtils.getSequenceNumWords(w1));\n        }\n        return -1;\n      } else {\n        assert ConciseSetUtils.isOneSequence(w1);\n        if (!ConciseSetUtils.isOneSequence(w2)) {\n          return 1;\n        }\n        return Integer.compare(ConciseSetUtils.getSequenceNumWords(w1), ConciseSetUtils.getSequenceNumWords(w2));\n      }\n    }\n  };", "modifier": "private static final", "type": "Comparator<WordIterator>", "declarator": "INTERSECTION_COMPARATOR = new Comparator<WordIterator>()\n  {\n    // Comparison is first by index, then zero fills < literals < one fills\n    // zero fills are sorted by length (longer zero fills have priority)\n    // similarly, shorter one fills have priority\n    @Override\n    public int compare(WordIterator i1, WordIterator i2)\n    {\n      int s1 = i1.startIndex;\n      int s2 = i2.startIndex;\n\n      if (s1 != s2) {\n        return Integer.compare(s1, s2);\n      }\n\n      int w1 = i1.getWord();\n      int w2 = i2.getWord();\n\n      if (ConciseSetUtils.isLiteral(w1)) {\n        if (ConciseSetUtils.isLiteral(w2)) {\n          return 0;\n        } else if (ConciseSetUtils.isZeroSequence(w2)) {\n          return 1;\n        } else {\n          assert ConciseSetUtils.isOneSequence(w2);\n          return -1;\n        }\n      } else if (ConciseSetUtils.isZeroSequence(w1)) {\n        if (ConciseSetUtils.isZeroSequence(w2)) {\n          // reverse\n          return Integer.compare(ConciseSetUtils.getSequenceNumWords(w2), ConciseSetUtils.getSequenceNumWords(w1));\n        }\n        return -1;\n      } else {\n        assert ConciseSetUtils.isOneSequence(w1);\n        if (!ConciseSetUtils.isOneSequence(w2)) {\n          return 1;\n        }\n        return Integer.compare(ConciseSetUtils.getSequenceNumWords(w1), ConciseSetUtils.getSequenceNumWords(w2));\n      }\n    }\n  }", "var_name": "INTERSECTION_COMPARATOR"}, {"original_string": "final IntBuffer words;", "modifier": "final", "type": "IntBuffer", "declarator": "words", "var_name": "words"}, {"original_string": "final int lastWordIndex;", "modifier": "final", "type": "int", "declarator": "lastWordIndex", "var_name": "lastWordIndex"}, {"original_string": "private final int size;", "modifier": "private final", "type": "int", "declarator": "size", "var_name": "size"}], "methods": [{"identifier": "newImmutableFromMutable", "parameters": "(ConciseSet conciseSet)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet newImmutableFromMutable(ConciseSet conciseSet)", "full_signature": "public static ImmutableConciseSet newImmutableFromMutable(ConciseSet conciseSet)", "class_method_signature": "ImmutableConciseSet.newImmutableFromMutable(ConciseSet conciseSet)", "testcase": false, "constructor": false}, {"identifier": "union", "parameters": "(ImmutableConciseSet... sets)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet union(ImmutableConciseSet... sets)", "full_signature": "public static ImmutableConciseSet union(ImmutableConciseSet... sets)", "class_method_signature": "ImmutableConciseSet.union(ImmutableConciseSet... sets)", "testcase": false, "constructor": false}, {"identifier": "union", "parameters": "(Iterable<ImmutableConciseSet> sets)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet union(Iterable<ImmutableConciseSet> sets)", "full_signature": "public static ImmutableConciseSet union(Iterable<ImmutableConciseSet> sets)", "class_method_signature": "ImmutableConciseSet.union(Iterable<ImmutableConciseSet> sets)", "testcase": false, "constructor": false}, {"identifier": "union", "parameters": "(Iterator<ImmutableConciseSet> sets)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet union(Iterator<ImmutableConciseSet> sets)", "full_signature": "public static ImmutableConciseSet union(Iterator<ImmutableConciseSet> sets)", "class_method_signature": "ImmutableConciseSet.union(Iterator<ImmutableConciseSet> sets)", "testcase": false, "constructor": false}, {"identifier": "intersection", "parameters": "(ImmutableConciseSet... sets)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet intersection(ImmutableConciseSet... sets)", "full_signature": "public static ImmutableConciseSet intersection(ImmutableConciseSet... sets)", "class_method_signature": "ImmutableConciseSet.intersection(ImmutableConciseSet... sets)", "testcase": false, "constructor": false}, {"identifier": "intersection", "parameters": "(Iterable<ImmutableConciseSet> sets)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet intersection(Iterable<ImmutableConciseSet> sets)", "full_signature": "public static ImmutableConciseSet intersection(Iterable<ImmutableConciseSet> sets)", "class_method_signature": "ImmutableConciseSet.intersection(Iterable<ImmutableConciseSet> sets)", "testcase": false, "constructor": false}, {"identifier": "intersection", "parameters": "(Iterator<ImmutableConciseSet> sets)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet intersection(Iterator<ImmutableConciseSet> sets)", "full_signature": "public static ImmutableConciseSet intersection(Iterator<ImmutableConciseSet> sets)", "class_method_signature": "ImmutableConciseSet.intersection(Iterator<ImmutableConciseSet> sets)", "testcase": false, "constructor": false}, {"identifier": "complement", "parameters": "(ImmutableConciseSet set)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet complement(ImmutableConciseSet set)", "full_signature": "public static ImmutableConciseSet complement(ImmutableConciseSet set)", "class_method_signature": "ImmutableConciseSet.complement(ImmutableConciseSet set)", "testcase": false, "constructor": false}, {"identifier": "complement", "parameters": "(ImmutableConciseSet set, int length)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet complement(ImmutableConciseSet set, int length)", "full_signature": "public static ImmutableConciseSet complement(ImmutableConciseSet set, int length)", "class_method_signature": "ImmutableConciseSet.complement(ImmutableConciseSet set, int length)", "testcase": false, "constructor": false}, {"identifier": "compact", "parameters": "(ImmutableConciseSet set)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet compact(ImmutableConciseSet set)", "full_signature": "public static ImmutableConciseSet compact(ImmutableConciseSet set)", "class_method_signature": "ImmutableConciseSet.compact(ImmutableConciseSet set)", "testcase": false, "constructor": false}, {"identifier": "addAndCompact", "parameters": "(IntList set, int wordToAdd)", "modifiers": "private static", "return": "void", "signature": "void addAndCompact(IntList set, int wordToAdd)", "full_signature": "private static void addAndCompact(IntList set, int wordToAdd)", "class_method_signature": "ImmutableConciseSet.addAndCompact(IntList set, int wordToAdd)", "testcase": false, "constructor": false}, {"identifier": "doUnion", "parameters": "(Iterator<ImmutableConciseSet> sets)", "modifiers": "private static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet doUnion(Iterator<ImmutableConciseSet> sets)", "full_signature": "private static ImmutableConciseSet doUnion(Iterator<ImmutableConciseSet> sets)", "class_method_signature": "ImmutableConciseSet.doUnion(Iterator<ImmutableConciseSet> sets)", "testcase": false, "constructor": false}, {"identifier": "doIntersection", "parameters": "(Iterator<ImmutableConciseSet> sets)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet doIntersection(Iterator<ImmutableConciseSet> sets)", "full_signature": "public static ImmutableConciseSet doIntersection(Iterator<ImmutableConciseSet> sets)", "class_method_signature": "ImmutableConciseSet.doIntersection(Iterator<ImmutableConciseSet> sets)", "testcase": false, "constructor": false}, {"identifier": "partialSort", "parameters": "(\n      final WordIterator[] a,\n      final int maxChangedIndex,\n      final int size,\n      final Comparator<WordIterator> comp\n  )", "modifiers": "private static", "return": "void", "signature": "void partialSort(\n      final WordIterator[] a,\n      final int maxChangedIndex,\n      final int size,\n      final Comparator<WordIterator> comp\n  )", "full_signature": "private static void partialSort(\n      final WordIterator[] a,\n      final int maxChangedIndex,\n      final int size,\n      final Comparator<WordIterator> comp\n  )", "class_method_signature": "ImmutableConciseSet.partialSort(\n      final WordIterator[] a,\n      final int maxChangedIndex,\n      final int size,\n      final Comparator<WordIterator> comp\n  )", "testcase": false, "constructor": false}, {"identifier": "removeElement", "parameters": "(WordIterator[] q, int qIndex, int qSize)", "modifiers": "private static", "return": "void", "signature": "void removeElement(WordIterator[] q, int qIndex, int qSize)", "full_signature": "private static void removeElement(WordIterator[] q, int qIndex, int qSize)", "class_method_signature": "ImmutableConciseSet.removeElement(WordIterator[] q, int qIndex, int qSize)", "testcase": false, "constructor": false}, {"identifier": "doComplement", "parameters": "(ImmutableConciseSet set)", "modifiers": "public static", "return": "ImmutableConciseSet", "signature": "ImmutableConciseSet doComplement(ImmutableConciseSet set)", "full_signature": "public static ImmutableConciseSet doComplement(ImmutableConciseSet set)", "class_method_signature": "ImmutableConciseSet.doComplement(ImmutableConciseSet set)", "testcase": false, "constructor": false}, {"identifier": "trimZeros", "parameters": "(IntList set)", "modifiers": "private static", "return": "void", "signature": "void trimZeros(IntList set)", "full_signature": "private static void trimZeros(IntList set)", "class_method_signature": "ImmutableConciseSet.trimZeros(IntList set)", "testcase": false, "constructor": false}, {"identifier": "ImmutableConciseSet", "parameters": "()", "modifiers": "public", "return": "", "signature": " ImmutableConciseSet()", "full_signature": "public  ImmutableConciseSet()", "class_method_signature": "ImmutableConciseSet.ImmutableConciseSet()", "testcase": false, "constructor": true}, {"identifier": "ImmutableConciseSet", "parameters": "(IntBuffer buffer)", "modifiers": "public", "return": "", "signature": " ImmutableConciseSet(IntBuffer buffer)", "full_signature": "public  ImmutableConciseSet(IntBuffer buffer)", "class_method_signature": "ImmutableConciseSet.ImmutableConciseSet(IntBuffer buffer)", "testcase": false, "constructor": true}, {"identifier": "toBytes", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] toBytes()", "full_signature": "public byte[] toBytes()", "class_method_signature": "ImmutableConciseSet.toBytes()", "testcase": false, "constructor": false}, {"identifier": "calcSize", "parameters": "()", "modifiers": "private", "return": "int", "signature": "int calcSize()", "full_signature": "private int calcSize()", "class_method_signature": "ImmutableConciseSet.calcSize()", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int size()", "full_signature": "public int size()", "class_method_signature": "ImmutableConciseSet.size()", "testcase": false, "constructor": false}, {"identifier": "getLast", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getLast()", "full_signature": "public int getLast()", "class_method_signature": "ImmutableConciseSet.getLast()", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(final int integer)", "modifiers": "public", "return": "boolean", "signature": "boolean contains(final int integer)", "full_signature": "public boolean contains(final int integer)", "class_method_signature": "ImmutableConciseSet.contains(final int integer)", "testcase": false, "constructor": false}, {"identifier": "isEmpty", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean isEmpty()", "full_signature": "private boolean isEmpty()", "class_method_signature": "ImmutableConciseSet.isEmpty()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override // Based on the AbstractIntSet implementation by Alessandro Colantonio public", "return": "String", "signature": "String toString()", "full_signature": "@Override // Based on the AbstractIntSet implementation by Alessandro Colantonio public String toString()", "class_method_signature": "ImmutableConciseSet.toString()", "testcase": false, "constructor": false}, {"identifier": "iterator", "parameters": "()", "modifiers": "public", "return": "IntSet.IntIterator", "signature": "IntSet.IntIterator iterator()", "full_signature": "public IntSet.IntIterator iterator()", "class_method_signature": "ImmutableConciseSet.iterator()", "testcase": false, "constructor": false}, {"identifier": "newWordIterator", "parameters": "()", "modifiers": "public", "return": "WordIterator", "signature": "WordIterator newWordIterator()", "full_signature": "public WordIterator newWordIterator()", "class_method_signature": "ImmutableConciseSet.newWordIterator()", "testcase": false, "constructor": false}], "file": "extendedset/src/main/java/org/apache/druid/extendedset/intset/ImmutableConciseSet.java"}, "focal_method": {"identifier": "newImmutableFromMutable", "parameters": "(ConciseSet conciseSet)", "modifiers": "public static", "return": "ImmutableConciseSet", "body": "public static ImmutableConciseSet newImmutableFromMutable(ConciseSet conciseSet)\n  {\n    if (conciseSet == null || conciseSet.isEmpty()) {\n      return new ImmutableConciseSet();\n    }\n    return new ImmutableConciseSet(IntBuffer.wrap(conciseSet.getWords()));\n  }", "signature": "ImmutableConciseSet newImmutableFromMutable(ConciseSet conciseSet)", "full_signature": "public static ImmutableConciseSet newImmutableFromMutable(ConciseSet conciseSet)", "class_method_signature": "ImmutableConciseSet.newImmutableFromMutable(ConciseSet conciseSet)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "wrap", "getWords"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}