{"test_class": {"identifier": "LoadRuleTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = new Logger(LoadRuleTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = new Logger(LoadRuleTest.class)", "var_name": "log"}, {"original_string": "private static final ObjectMapper JSON_MAPPER = new DefaultObjectMapper();", "modifier": "private static final", "type": "ObjectMapper", "declarator": "JSON_MAPPER = new DefaultObjectMapper()", "var_name": "JSON_MAPPER"}, {"original_string": "private static final ServiceEmitter EMITTER = new ServiceEmitter(\n      \"service\",\n      \"host\",\n      new LoggingEmitter(\n          log,\n          LoggingEmitter.Level.ERROR,\n          JSON_MAPPER\n      )\n  );", "modifier": "private static final", "type": "ServiceEmitter", "declarator": "EMITTER = new ServiceEmitter(\n      \"service\",\n      \"host\",\n      new LoggingEmitter(\n          log,\n          LoggingEmitter.Level.ERROR,\n          JSON_MAPPER\n      )\n  )", "var_name": "EMITTER"}, {"original_string": "private ReplicationThrottler throttler;", "modifier": "private", "type": "ReplicationThrottler", "declarator": "throttler", "var_name": "throttler"}, {"original_string": "private ListeningExecutorService exec;", "modifier": "private", "type": "ListeningExecutorService", "declarator": "exec", "var_name": "exec"}, {"original_string": "private BalancerStrategy balancerStrategy;", "modifier": "private", "type": "BalancerStrategy", "declarator": "balancerStrategy", "var_name": "balancerStrategy"}, {"original_string": "private BalancerStrategy mockBalancerStrategy;", "modifier": "private", "type": "BalancerStrategy", "declarator": "mockBalancerStrategy", "var_name": "mockBalancerStrategy"}, {"original_string": "private static final AtomicInteger SERVER_ID = new AtomicInteger();", "modifier": "private static final", "type": "AtomicInteger", "declarator": "SERVER_ID = new AtomicInteger()", "var_name": "SERVER_ID"}], "file": "server/src/test/java/org/apache/druid/server/coordinator/rules/LoadRuleTest.java"}, "test_case": {"identifier": "testRedundantReplicaDropDuringDecommissioning", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testRedundantReplicaDropDuringDecommissioning()\n  {\n    final LoadQueuePeon mockPeon1 = new LoadQueuePeonTester();\n    final LoadQueuePeon mockPeon2 = new LoadQueuePeonTester();\n    final LoadQueuePeon mockPeon3 = new LoadQueuePeonTester();\n    EasyMock.expect(mockBalancerStrategy.pickServersToDrop(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andDelegateTo(balancerStrategy)\n            .times(4);\n    EasyMock.replay(throttler, mockBalancerStrategy);\n\n    LoadRule rule = createLoadRule(ImmutableMap.of(\"tier1\", 2));\n\n    final DataSegment segment1 = createDataSegment(\"foo1\");\n\n    DruidServer server1 = createServer(\"tier1\");\n    server1.addDataSegment(segment1);\n    DruidServer server2 = createServer(\"tier1\");\n    server2.addDataSegment(segment1);\n    DruidServer server3 = createServer(\"tier1\");\n    server3.addDataSegment(segment1);\n\n    DruidCluster druidCluster = DruidClusterBuilder\n        .newBuilder()\n        .addTier(\n            \"tier1\",\n            new ServerHolder(server1.toImmutableDruidServer(), mockPeon1, false),\n            new ServerHolder(server2.toImmutableDruidServer(), mockPeon2, true),\n            new ServerHolder(server3.toImmutableDruidServer(), mockPeon3, false)\n        )\n        .build();\n\n    CoordinatorStats stats = rule.run(null, makeCoordinatorRuntimeParams(druidCluster, segment1), segment1);\n    Assert.assertEquals(1L, stats.getTieredStat(\"droppedCount\", \"tier1\"));\n    Assert.assertEquals(0, mockPeon1.getSegmentsToDrop().size());\n    Assert.assertEquals(1, mockPeon2.getSegmentsToDrop().size());\n    Assert.assertEquals(0, mockPeon3.getSegmentsToDrop().size());\n\n    EasyMock.verify(throttler);\n  }", "signature": "void testRedundantReplicaDropDuringDecommissioning()", "full_signature": "@Test public void testRedundantReplicaDropDuringDecommissioning()", "class_method_signature": "LoadRuleTest.testRedundantReplicaDropDuringDecommissioning()", "testcase": true, "constructor": false, "invocations": ["times", "andDelegateTo", "expect", "pickServersToDrop", "anyObject", "anyObject", "replay", "createLoadRule", "of", "createDataSegment", "createServer", "addDataSegment", "createServer", "addDataSegment", "createServer", "addDataSegment", "build", "addTier", "newBuilder", "toImmutableDruidServer", "toImmutableDruidServer", "toImmutableDruidServer", "run", "makeCoordinatorRuntimeParams", "assertEquals", "getTieredStat", "assertEquals", "size", "getSegmentsToDrop", "assertEquals", "size", "getSegmentsToDrop", "assertEquals", "size", "getSegmentsToDrop", "verify"]}, "focal_class": {"identifier": "LoadRule", "superclass": "", "interfaces": "implements Rule", "fields": [{"original_string": "private static final EmittingLogger log = new EmittingLogger(LoadRule.class);", "modifier": "private static final", "type": "EmittingLogger", "declarator": "log = new EmittingLogger(LoadRule.class)", "var_name": "log"}, {"original_string": "static final String ASSIGNED_COUNT = \"assignedCount\";", "modifier": "static final", "type": "String", "declarator": "ASSIGNED_COUNT = \"assignedCount\"", "var_name": "ASSIGNED_COUNT"}, {"original_string": "static final String DROPPED_COUNT = \"droppedCount\";", "modifier": "static final", "type": "String", "declarator": "DROPPED_COUNT = \"droppedCount\"", "var_name": "DROPPED_COUNT"}, {"original_string": "public static final String REQUIRED_CAPACITY = \"requiredCapacity\";", "modifier": "public static final", "type": "String", "declarator": "REQUIRED_CAPACITY = \"requiredCapacity\"", "var_name": "REQUIRED_CAPACITY"}, {"original_string": "private final Object2IntMap<String> targetReplicants = new Object2IntOpenHashMap<>();", "modifier": "private final", "type": "Object2IntMap<String>", "declarator": "targetReplicants = new Object2IntOpenHashMap<>()", "var_name": "targetReplicants"}, {"original_string": "private final Object2IntMap<String> currentReplicants = new Object2IntOpenHashMap<>();", "modifier": "private final", "type": "Object2IntMap<String>", "declarator": "currentReplicants = new Object2IntOpenHashMap<>()", "var_name": "currentReplicants"}, {"original_string": "private final Map<String, ServerHolder> strategyCache = new HashMap<>();", "modifier": "private final", "type": "Map<String, ServerHolder>", "declarator": "strategyCache = new HashMap<>()", "var_name": "strategyCache"}], "methods": [{"identifier": "run", "parameters": "(\n      final DruidCoordinator coordinator,\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "modifiers": "@Override public", "return": "CoordinatorStats", "signature": "CoordinatorStats run(\n      final DruidCoordinator coordinator,\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "full_signature": "@Override public CoordinatorStats run(\n      final DruidCoordinator coordinator,\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "class_method_signature": "LoadRule.run(\n      final DruidCoordinator coordinator,\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "testcase": false, "constructor": false}, {"identifier": "canLoadSegments", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean canLoadSegments()", "full_signature": "@Override public boolean canLoadSegments()", "class_method_signature": "LoadRule.canLoadSegments()", "testcase": false, "constructor": false}, {"identifier": "updateUnderReplicated", "parameters": "(\n      Map<String, Object2LongMap<String>> underReplicatedPerTier,\n      SegmentReplicantLookup segmentReplicantLookup,\n      DataSegment segment\n  )", "modifiers": "@Override public", "return": "void", "signature": "void updateUnderReplicated(\n      Map<String, Object2LongMap<String>> underReplicatedPerTier,\n      SegmentReplicantLookup segmentReplicantLookup,\n      DataSegment segment\n  )", "full_signature": "@Override public void updateUnderReplicated(\n      Map<String, Object2LongMap<String>> underReplicatedPerTier,\n      SegmentReplicantLookup segmentReplicantLookup,\n      DataSegment segment\n  )", "class_method_signature": "LoadRule.updateUnderReplicated(\n      Map<String, Object2LongMap<String>> underReplicatedPerTier,\n      SegmentReplicantLookup segmentReplicantLookup,\n      DataSegment segment\n  )", "testcase": false, "constructor": false}, {"identifier": "assign", "parameters": "(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats\n  )", "modifiers": "private", "return": "void", "signature": "void assign(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats\n  )", "full_signature": "private void assign(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats\n  )", "class_method_signature": "LoadRule.assign(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats\n  )", "testcase": false, "constructor": false}, {"identifier": "createLoadQueueSizeLimitingPredicate", "parameters": "(\n      final DruidCoordinatorRuntimeParams params\n  )", "modifiers": "private static", "return": "Predicate<ServerHolder>", "signature": "Predicate<ServerHolder> createLoadQueueSizeLimitingPredicate(\n      final DruidCoordinatorRuntimeParams params\n  )", "full_signature": "private static Predicate<ServerHolder> createLoadQueueSizeLimitingPredicate(\n      final DruidCoordinatorRuntimeParams params\n  )", "class_method_signature": "LoadRule.createLoadQueueSizeLimitingPredicate(\n      final DruidCoordinatorRuntimeParams params\n  )", "testcase": false, "constructor": false}, {"identifier": "getFilteredHolders", "parameters": "(\n      final String tier,\n      final DruidCluster druidCluster,\n      final Predicate<ServerHolder> predicate\n  )", "modifiers": "private static", "return": "List<ServerHolder>", "signature": "List<ServerHolder> getFilteredHolders(\n      final String tier,\n      final DruidCluster druidCluster,\n      final Predicate<ServerHolder> predicate\n  )", "full_signature": "private static List<ServerHolder> getFilteredHolders(\n      final String tier,\n      final DruidCluster druidCluster,\n      final Predicate<ServerHolder> predicate\n  )", "class_method_signature": "LoadRule.getFilteredHolders(\n      final String tier,\n      final DruidCluster druidCluster,\n      final Predicate<ServerHolder> predicate\n  )", "testcase": false, "constructor": false}, {"identifier": "assignPrimary", "parameters": "(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "modifiers": "@Nullable private", "return": "ServerHolder", "signature": "ServerHolder assignPrimary(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "full_signature": "@Nullable private ServerHolder assignPrimary(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "class_method_signature": "LoadRule.assignPrimary(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "testcase": false, "constructor": false}, {"identifier": "assignReplicas", "parameters": "(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats,\n      @Nullable final String tierToSkip\n  )", "modifiers": "private", "return": "void", "signature": "void assignReplicas(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats,\n      @Nullable final String tierToSkip\n  )", "full_signature": "private void assignReplicas(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats,\n      @Nullable final String tierToSkip\n  )", "class_method_signature": "LoadRule.assignReplicas(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats,\n      @Nullable final String tierToSkip\n  )", "testcase": false, "constructor": false}, {"identifier": "assignReplicasForTier", "parameters": "(\n      final String tier,\n      final int targetReplicantsInTier,\n      final int currentReplicantsInTier,\n      final DruidCoordinatorRuntimeParams params,\n      final Predicate<ServerHolder> predicate,\n      final DataSegment segment\n  )", "modifiers": "private", "return": "int", "signature": "int assignReplicasForTier(\n      final String tier,\n      final int targetReplicantsInTier,\n      final int currentReplicantsInTier,\n      final DruidCoordinatorRuntimeParams params,\n      final Predicate<ServerHolder> predicate,\n      final DataSegment segment\n  )", "full_signature": "private int assignReplicasForTier(\n      final String tier,\n      final int targetReplicantsInTier,\n      final int currentReplicantsInTier,\n      final DruidCoordinatorRuntimeParams params,\n      final Predicate<ServerHolder> predicate,\n      final DataSegment segment\n  )", "class_method_signature": "LoadRule.assignReplicasForTier(\n      final String tier,\n      final int targetReplicantsInTier,\n      final int currentReplicantsInTier,\n      final DruidCoordinatorRuntimeParams params,\n      final Predicate<ServerHolder> predicate,\n      final DataSegment segment\n  )", "testcase": false, "constructor": false}, {"identifier": "drop", "parameters": "(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats\n  )", "modifiers": "private", "return": "void", "signature": "void drop(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats\n  )", "full_signature": "private void drop(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats\n  )", "class_method_signature": "LoadRule.drop(\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment,\n      final CoordinatorStats stats\n  )", "testcase": false, "constructor": false}, {"identifier": "loadingInProgress", "parameters": "(final DruidCluster druidCluster)", "modifiers": "private", "return": "boolean", "signature": "boolean loadingInProgress(final DruidCluster druidCluster)", "full_signature": "private boolean loadingInProgress(final DruidCluster druidCluster)", "class_method_signature": "LoadRule.loadingInProgress(final DruidCluster druidCluster)", "testcase": false, "constructor": false}, {"identifier": "dropForTier", "parameters": "(\n      final int numToDrop,\n      final NavigableSet<ServerHolder> holdersInTier,\n      final DataSegment segment,\n      final BalancerStrategy balancerStrategy\n  )", "modifiers": "private static", "return": "int", "signature": "int dropForTier(\n      final int numToDrop,\n      final NavigableSet<ServerHolder> holdersInTier,\n      final DataSegment segment,\n      final BalancerStrategy balancerStrategy\n  )", "full_signature": "private static int dropForTier(\n      final int numToDrop,\n      final NavigableSet<ServerHolder> holdersInTier,\n      final DataSegment segment,\n      final BalancerStrategy balancerStrategy\n  )", "class_method_signature": "LoadRule.dropForTier(\n      final int numToDrop,\n      final NavigableSet<ServerHolder> holdersInTier,\n      final DataSegment segment,\n      final BalancerStrategy balancerStrategy\n  )", "testcase": false, "constructor": false}, {"identifier": "dropSegmentFromServers", "parameters": "(\n      BalancerStrategy balancerStrategy,\n      DataSegment segment,\n      NavigableSet<ServerHolder> holders, int numToDrop\n  )", "modifiers": "private static", "return": "int", "signature": "int dropSegmentFromServers(\n      BalancerStrategy balancerStrategy,\n      DataSegment segment,\n      NavigableSet<ServerHolder> holders, int numToDrop\n  )", "full_signature": "private static int dropSegmentFromServers(\n      BalancerStrategy balancerStrategy,\n      DataSegment segment,\n      NavigableSet<ServerHolder> holders, int numToDrop\n  )", "class_method_signature": "LoadRule.dropSegmentFromServers(\n      BalancerStrategy balancerStrategy,\n      DataSegment segment,\n      NavigableSet<ServerHolder> holders, int numToDrop\n  )", "testcase": false, "constructor": false}, {"identifier": "validateTieredReplicants", "parameters": "(final Map<String, Integer> tieredReplicants)", "modifiers": "protected static", "return": "void", "signature": "void validateTieredReplicants(final Map<String, Integer> tieredReplicants)", "full_signature": "protected static void validateTieredReplicants(final Map<String, Integer> tieredReplicants)", "class_method_signature": "LoadRule.validateTieredReplicants(final Map<String, Integer> tieredReplicants)", "testcase": false, "constructor": false}, {"identifier": "getTieredReplicants", "parameters": "()", "modifiers": "public abstract", "return": "Map<String, Integer>", "signature": "Map<String, Integer> getTieredReplicants()", "full_signature": "public abstract Map<String, Integer> getTieredReplicants()", "class_method_signature": "LoadRule.getTieredReplicants()", "testcase": false, "constructor": false}, {"identifier": "getNumReplicants", "parameters": "(String tier)", "modifiers": "public abstract", "return": "int", "signature": "int getNumReplicants(String tier)", "full_signature": "public abstract int getNumReplicants(String tier)", "class_method_signature": "LoadRule.getNumReplicants(String tier)", "testcase": false, "constructor": false}], "file": "server/src/main/java/org/apache/druid/server/coordinator/rules/LoadRule.java"}, "focal_method": {"identifier": "run", "parameters": "(\n      final DruidCoordinator coordinator,\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "modifiers": "@Override public", "return": "CoordinatorStats", "body": "@Override\n  public CoordinatorStats run(\n      final DruidCoordinator coordinator,\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )\n  {\n    try {\n      // get the \"snapshots\" of targetReplicants and currentReplicants for assignments.\n      targetReplicants.putAll(getTieredReplicants());\n      currentReplicants.putAll(params.getSegmentReplicantLookup().getClusterTiers(segment.getId()));\n\n      final CoordinatorStats stats = new CoordinatorStats();\n      assign(params, segment, stats);\n\n      drop(params, segment, stats);\n      for (String tier : targetReplicants.keySet()) {\n        stats.addToTieredStat(REQUIRED_CAPACITY, tier, segment.getSize() * targetReplicants.getInt(tier));\n      }\n      return stats;\n    }\n    finally {\n      targetReplicants.clear();\n      currentReplicants.clear();\n      strategyCache.clear();\n    }\n  }", "signature": "CoordinatorStats run(\n      final DruidCoordinator coordinator,\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "full_signature": "@Override public CoordinatorStats run(\n      final DruidCoordinator coordinator,\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "class_method_signature": "LoadRule.run(\n      final DruidCoordinator coordinator,\n      final DruidCoordinatorRuntimeParams params,\n      final DataSegment segment\n  )", "testcase": false, "constructor": false, "invocations": ["putAll", "getTieredReplicants", "putAll", "getClusterTiers", "getSegmentReplicantLookup", "getId", "assign", "drop", "keySet", "addToTieredStat", "getSize", "getInt", "clear", "clear", "clear"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}