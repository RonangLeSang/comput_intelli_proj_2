{"test_class": {"identifier": "SqlResourceTest", "superclass": "extends CalciteTestBase", "interfaces": "", "fields": [{"original_string": "private static final ObjectMapper JSON_MAPPER = new DefaultObjectMapper();", "modifier": "private static final", "type": "ObjectMapper", "declarator": "JSON_MAPPER = new DefaultObjectMapper()", "var_name": "JSON_MAPPER"}, {"original_string": "private static final String DUMMY_SQL_QUERY_ID = \"dummy\";", "modifier": "private static final", "type": "String", "declarator": "DUMMY_SQL_QUERY_ID = \"dummy\"", "var_name": "DUMMY_SQL_QUERY_ID"}, {"original_string": "private static QueryRunnerFactoryConglomerate conglomerate;", "modifier": "private static", "type": "QueryRunnerFactoryConglomerate", "declarator": "conglomerate", "var_name": "conglomerate"}, {"original_string": "private static Closer resourceCloser;", "modifier": "private static", "type": "Closer", "declarator": "resourceCloser", "var_name": "resourceCloser"}, {"original_string": "@Rule\n  public TemporaryFolder temporaryFolder = new TemporaryFolder();", "modifier": "@Rule\n  public", "type": "TemporaryFolder", "declarator": "temporaryFolder = new TemporaryFolder()", "var_name": "temporaryFolder"}, {"original_string": "@Rule\n  public QueryLogHook queryLogHook = QueryLogHook.create();", "modifier": "@Rule\n  public", "type": "QueryLogHook", "declarator": "queryLogHook = QueryLogHook.create()", "var_name": "queryLogHook"}, {"original_string": "private SpecificSegmentsQuerySegmentWalker walker = null;", "modifier": "private", "type": "SpecificSegmentsQuerySegmentWalker", "declarator": "walker = null", "var_name": "walker"}, {"original_string": "private TestRequestLogger testRequestLogger;", "modifier": "private", "type": "TestRequestLogger", "declarator": "testRequestLogger", "var_name": "testRequestLogger"}, {"original_string": "private SqlResource resource;", "modifier": "private", "type": "SqlResource", "declarator": "resource", "var_name": "resource"}, {"original_string": "private HttpServletRequest req;", "modifier": "private", "type": "HttpServletRequest", "declarator": "req", "var_name": "req"}, {"original_string": "private ListeningExecutorService executorService;", "modifier": "private", "type": "ListeningExecutorService", "declarator": "executorService", "var_name": "executorService"}], "file": "sql/src/test/java/org/apache/druid/sql/http/SqlResourceTest.java"}, "test_case": {"identifier": "testUnsupportedQueryThrowsException", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testUnsupportedQueryThrowsException() throws Exception\n  {\n    String errorMessage = \"This will be support in Druid 9999\";\n    SqlQuery badQuery = EasyMock.createMock(SqlQuery.class);\n    EasyMock.expect(badQuery.getQuery()).andReturn(\"SELECT ANSWER TO LIFE\");\n    EasyMock.expect(badQuery.getContext()).andReturn(ImmutableMap.of());\n    EasyMock.expect(badQuery.getParameterList()).andThrow(new QueryUnsupportedException(errorMessage));\n    EasyMock.replay(badQuery);\n    final QueryException exception = doPost(badQuery).lhs;\n\n    Assert.assertNotNull(exception);\n    Assert.assertEquals(exception.getErrorCode(), QueryUnsupportedException.ERROR_CODE);\n    Assert.assertEquals(exception.getErrorClass(), QueryUnsupportedException.class.getName());\n  }", "signature": "void testUnsupportedQueryThrowsException()", "full_signature": "@Test public void testUnsupportedQueryThrowsException()", "class_method_signature": "SqlResourceTest.testUnsupportedQueryThrowsException()", "testcase": true, "constructor": false, "invocations": ["createMock", "andReturn", "expect", "getQuery", "andReturn", "expect", "getContext", "of", "andThrow", "expect", "getParameterList", "replay", "doPost", "assertNotNull", "assertEquals", "getErrorCode", "assertEquals", "getErrorClass", "getName"]}, "focal_class": {"identifier": "SqlResource", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = new Logger(SqlResource.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = new Logger(SqlResource.class)", "var_name": "log"}, {"original_string": "private final ObjectMapper jsonMapper;", "modifier": "private final", "type": "ObjectMapper", "declarator": "jsonMapper", "var_name": "jsonMapper"}, {"original_string": "private final SqlLifecycleFactory sqlLifecycleFactory;", "modifier": "private final", "type": "SqlLifecycleFactory", "declarator": "sqlLifecycleFactory", "var_name": "sqlLifecycleFactory"}], "methods": [{"identifier": "SqlResource", "parameters": "(\n      @Json ObjectMapper jsonMapper,\n      SqlLifecycleFactory sqlLifecycleFactory\n  )", "modifiers": "@Inject public", "return": "", "signature": " SqlResource(\n      @Json ObjectMapper jsonMapper,\n      SqlLifecycleFactory sqlLifecycleFactory\n  )", "full_signature": "@Inject public  SqlResource(\n      @Json ObjectMapper jsonMapper,\n      SqlLifecycleFactory sqlLifecycleFactory\n  )", "class_method_signature": "SqlResource.SqlResource(\n      @Json ObjectMapper jsonMapper,\n      SqlLifecycleFactory sqlLifecycleFactory\n  )", "testcase": false, "constructor": true}, {"identifier": "doPost", "parameters": "(\n      final SqlQuery sqlQuery,\n      @Context final HttpServletRequest req\n  )", "modifiers": "@POST @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public", "return": "Response", "signature": "Response doPost(\n      final SqlQuery sqlQuery,\n      @Context final HttpServletRequest req\n  )", "full_signature": "@POST @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public Response doPost(\n      final SqlQuery sqlQuery,\n      @Context final HttpServletRequest req\n  )", "class_method_signature": "SqlResource.doPost(\n      final SqlQuery sqlQuery,\n      @Context final HttpServletRequest req\n  )", "testcase": false, "constructor": false}], "file": "sql/src/main/java/org/apache/druid/sql/http/SqlResource.java"}, "focal_method": {"identifier": "doPost", "parameters": "(\n      final SqlQuery sqlQuery,\n      @Context final HttpServletRequest req\n  )", "modifiers": "@POST @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public", "return": "Response", "body": "@POST\n  @Produces(MediaType.APPLICATION_JSON)\n  @Consumes(MediaType.APPLICATION_JSON)\n  public Response doPost(\n      final SqlQuery sqlQuery,\n      @Context final HttpServletRequest req\n  ) throws IOException\n  {\n    final SqlLifecycle lifecycle = sqlLifecycleFactory.factorize();\n    final String sqlQueryId = lifecycle.initialize(sqlQuery.getQuery(), sqlQuery.getContext());\n    final String remoteAddr = req.getRemoteAddr();\n    final String currThreadName = Thread.currentThread().getName();\n\n    try {\n      Thread.currentThread().setName(StringUtils.format(\"sql[%s]\", sqlQueryId));\n\n      lifecycle.setParameters(sqlQuery.getParameterList());\n      \n      final PlannerContext plannerContext = lifecycle.planAndAuthorize(req);\n      final DateTimeZone timeZone = plannerContext.getTimeZone();\n\n      // Remember which columns are time-typed, so we can emit ISO8601 instead of millis values.\n      // Also store list of all column names, for X-Druid-Sql-Columns header.\n      final List<RelDataTypeField> fieldList = lifecycle.rowType().getFieldList();\n      final boolean[] timeColumns = new boolean[fieldList.size()];\n      final boolean[] dateColumns = new boolean[fieldList.size()];\n      final String[] columnNames = new String[fieldList.size()];\n\n      for (int i = 0; i < fieldList.size(); i++) {\n        final SqlTypeName sqlTypeName = fieldList.get(i).getType().getSqlTypeName();\n        timeColumns[i] = sqlTypeName == SqlTypeName.TIMESTAMP;\n        dateColumns[i] = sqlTypeName == SqlTypeName.DATE;\n        columnNames[i] = fieldList.get(i).getName();\n      }\n\n      final Yielder<Object[]> yielder0 = Yielders.each(lifecycle.execute());\n\n      try {\n        return Response\n            .ok(\n                (StreamingOutput) outputStream -> {\n                  Exception e = null;\n                  CountingOutputStream os = new CountingOutputStream(outputStream);\n                  Yielder<Object[]> yielder = yielder0;\n\n                  try (final ResultFormat.Writer writer = sqlQuery.getResultFormat()\n                                                                  .createFormatter(os, jsonMapper)) {\n                    writer.writeResponseStart();\n\n                    if (sqlQuery.includeHeader()) {\n                      writer.writeHeader(Arrays.asList(columnNames));\n                    }\n\n                    while (!yielder.isDone()) {\n                      final Object[] row = yielder.get();\n                      writer.writeRowStart();\n                      for (int i = 0; i < fieldList.size(); i++) {\n                        final Object value;\n\n                        if (timeColumns[i]) {\n                          value = ISODateTimeFormat.dateTime().print(\n                              Calcites.calciteTimestampToJoda((long) row[i], timeZone)\n                          );\n                        } else if (dateColumns[i]) {\n                          value = ISODateTimeFormat.dateTime().print(\n                              Calcites.calciteDateToJoda((int) row[i], timeZone)\n                          );\n                        } else {\n                          value = row[i];\n                        }\n\n                        writer.writeRowField(fieldList.get(i).getName(), value);\n                      }\n                      writer.writeRowEnd();\n                      yielder = yielder.next(null);\n                    }\n\n                    writer.writeResponseEnd();\n                  }\n                  catch (Exception ex) {\n                    e = ex;\n                    log.error(ex, \"Unable to send SQL response [%s]\", sqlQueryId);\n                    throw new RuntimeException(ex);\n                  }\n                  finally {\n                    yielder.close();\n                    lifecycle.emitLogsAndMetrics(e, remoteAddr, os.getCount());\n                  }\n                }\n            )\n            .header(\"X-Druid-SQL-Query-Id\", sqlQueryId)\n            .build();\n      }\n      catch (Throwable e) {\n        // make sure to close yielder if anything happened before starting to serialize the response.\n        yielder0.close();\n        throw new RuntimeException(e);\n      }\n    }\n    catch (QueryCapacityExceededException cap) {\n      lifecycle.emitLogsAndMetrics(cap, remoteAddr, -1);\n      return Response.status(QueryCapacityExceededException.STATUS_CODE).entity(jsonMapper.writeValueAsBytes(cap)).build();\n    }\n    catch (QueryUnsupportedException unsupported) {\n      log.warn(unsupported, \"Failed to handle query: %s\", sqlQuery);\n      lifecycle.emitLogsAndMetrics(unsupported, remoteAddr, -1);\n      return Response.status(QueryUnsupportedException.STATUS_CODE).entity(jsonMapper.writeValueAsBytes(unsupported)).build();\n    }\n    catch (ForbiddenException e) {\n      throw e; // let ForbiddenExceptionMapper handle this\n    }\n    catch (Exception e) {\n      log.warn(e, \"Failed to handle query: %s\", sqlQuery);\n      lifecycle.emitLogsAndMetrics(e, remoteAddr, -1);\n\n      final Exception exceptionToReport;\n\n      if (e instanceof RelOptPlanner.CannotPlanException) {\n        exceptionToReport = new ISE(\"Cannot build plan for query: %s\", sqlQuery.getQuery());\n      } else {\n        exceptionToReport = e;\n      }\n\n      return Response.serverError()\n                     .type(MediaType.APPLICATION_JSON_TYPE)\n                     .entity(jsonMapper.writeValueAsBytes(QueryInterruptedException.wrapIfNeeded(exceptionToReport)))\n                     .build();\n    }\n    finally {\n      Thread.currentThread().setName(currThreadName);\n    }\n  }", "signature": "Response doPost(\n      final SqlQuery sqlQuery,\n      @Context final HttpServletRequest req\n  )", "full_signature": "@POST @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public Response doPost(\n      final SqlQuery sqlQuery,\n      @Context final HttpServletRequest req\n  )", "class_method_signature": "SqlResource.doPost(\n      final SqlQuery sqlQuery,\n      @Context final HttpServletRequest req\n  )", "testcase": false, "constructor": false, "invocations": ["factorize", "initialize", "getQuery", "getContext", "getRemoteAddr", "getName", "currentThread", "setName", "currentThread", "format", "setParameters", "getParameterList", "planAndAuthorize", "getTimeZone", "getFieldList", "rowType", "size", "size", "size", "size", "getSqlTypeName", "getType", "get", "getName", "get", "each", "execute", "build", "header", "ok", "createFormatter", "getResultFormat", "writeResponseStart", "includeHeader", "writeHeader", "asList", "isDone", "get", "writeRowStart", "size", "print", "dateTime", "calciteTimestampToJoda", "print", "dateTime", "calciteDateToJoda", "writeRowField", "getName", "get", "writeRowEnd", "next", "writeResponseEnd", "error", "close", "emitLogsAndMetrics", "getCount", "close", "emitLogsAndMetrics", "build", "entity", "status", "writeValueAsBytes", "warn", "emitLogsAndMetrics", "build", "entity", "status", "writeValueAsBytes", "warn", "emitLogsAndMetrics", "getQuery", "build", "entity", "type", "serverError", "writeValueAsBytes", "wrapIfNeeded", "setName", "currentThread"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}