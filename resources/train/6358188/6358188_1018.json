{"test_class": {"identifier": "HashJoinSegmentStorageAdapterTest", "superclass": "extends BaseHashJoinSegmentStorageAdapterTest", "interfaces": "", "fields": [], "file": "processing/src/test/java/org/apache/druid/segment/join/HashJoinSegmentStorageAdapterTest.java"}, "test_case": {"identifier": "test_makeCursors_factToCountryLeft_filterExcludesAllLeftRows", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void test_makeCursors_factToCountryLeft_filterExcludesAllLeftRows()\n  {\n    Filter originalFilter = new SelectorFilter(\"page\", \"this matches nothing\");\n    List<JoinableClause> joinableClauses = ImmutableList.of(factToCountryOnIsoCode(JoinType.LEFT));\n\n    JoinFilterPreAnalysis joinFilterPreAnalysis = makeDefaultConfigPreAnalysis(\n        originalFilter,\n        joinableClauses,\n        VirtualColumns.EMPTY\n    );\n    JoinTestHelper.verifyCursors(\n        new HashJoinSegmentStorageAdapter(\n            factSegment.asStorageAdapter(),\n            joinableClauses,\n            joinFilterPreAnalysis\n        ).makeCursors(\n            originalFilter,\n            Intervals.ETERNITY,\n            VirtualColumns.EMPTY,\n            Granularities.ALL,\n            false,\n            null\n        ),\n        ImmutableList.of(\n            \"page\",\n            \"countryIsoCode\",\n            FACT_TO_COUNTRY_ON_ISO_CODE_PREFIX + \"countryIsoCode\",\n            FACT_TO_COUNTRY_ON_ISO_CODE_PREFIX + \"countryName\",\n            FACT_TO_COUNTRY_ON_ISO_CODE_PREFIX + \"countryNumber\"\n        ),\n        ImmutableList.of()\n    );\n  }", "signature": "void test_makeCursors_factToCountryLeft_filterExcludesAllLeftRows()", "full_signature": "@Test public void test_makeCursors_factToCountryLeft_filterExcludesAllLeftRows()", "class_method_signature": "HashJoinSegmentStorageAdapterTest.test_makeCursors_factToCountryLeft_filterExcludesAllLeftRows()", "testcase": true, "constructor": false, "invocations": ["of", "factToCountryOnIsoCode", "makeDefaultConfigPreAnalysis", "verifyCursors", "makeCursors", "asStorageAdapter", "of", "of"]}, "focal_class": {"identifier": "HashJoinSegmentStorageAdapter", "superclass": "", "interfaces": "implements StorageAdapter", "fields": [{"original_string": "private final StorageAdapter baseAdapter;", "modifier": "private final", "type": "StorageAdapter", "declarator": "baseAdapter", "var_name": "baseAdapter"}, {"original_string": "private final List<JoinableClause> clauses;", "modifier": "private final", "type": "List<JoinableClause>", "declarator": "clauses", "var_name": "clauses"}, {"original_string": "private final JoinFilterPreAnalysis joinFilterPreAnalysis;", "modifier": "private final", "type": "JoinFilterPreAnalysis", "declarator": "joinFilterPreAnalysis", "var_name": "joinFilterPreAnalysis"}], "methods": [{"identifier": "HashJoinSegmentStorageAdapter", "parameters": "(\n      final StorageAdapter baseAdapter,\n      final List<JoinableClause> clauses,\n      final JoinFilterPreAnalysis joinFilterPreAnalysis\n  )", "modifiers": "", "return": "", "signature": " HashJoinSegmentStorageAdapter(\n      final StorageAdapter baseAdapter,\n      final List<JoinableClause> clauses,\n      final JoinFilterPreAnalysis joinFilterPreAnalysis\n  )", "full_signature": "  HashJoinSegmentStorageAdapter(\n      final StorageAdapter baseAdapter,\n      final List<JoinableClause> clauses,\n      final JoinFilterPreAnalysis joinFilterPreAnalysis\n  )", "class_method_signature": "HashJoinSegmentStorageAdapter.HashJoinSegmentStorageAdapter(\n      final StorageAdapter baseAdapter,\n      final List<JoinableClause> clauses,\n      final JoinFilterPreAnalysis joinFilterPreAnalysis\n  )", "testcase": false, "constructor": true}, {"identifier": "getInterval", "parameters": "()", "modifiers": "@Override public", "return": "Interval", "signature": "Interval getInterval()", "full_signature": "@Override public Interval getInterval()", "class_method_signature": "HashJoinSegmentStorageAdapter.getInterval()", "testcase": false, "constructor": false}, {"identifier": "getAvailableDimensions", "parameters": "()", "modifiers": "@Override public", "return": "Indexed<String>", "signature": "Indexed<String> getAvailableDimensions()", "full_signature": "@Override public Indexed<String> getAvailableDimensions()", "class_method_signature": "HashJoinSegmentStorageAdapter.getAvailableDimensions()", "testcase": false, "constructor": false}, {"identifier": "getAvailableMetrics", "parameters": "()", "modifiers": "@Override public", "return": "Iterable<String>", "signature": "Iterable<String> getAvailableMetrics()", "full_signature": "@Override public Iterable<String> getAvailableMetrics()", "class_method_signature": "HashJoinSegmentStorageAdapter.getAvailableMetrics()", "testcase": false, "constructor": false}, {"identifier": "getDimensionCardinality", "parameters": "(String column)", "modifiers": "@Override public", "return": "int", "signature": "int getDimensionCardinality(String column)", "full_signature": "@Override public int getDimensionCardinality(String column)", "class_method_signature": "HashJoinSegmentStorageAdapter.getDimensionCardinality(String column)", "testcase": false, "constructor": false}, {"identifier": "getMinTime", "parameters": "()", "modifiers": "@Override public", "return": "DateTime", "signature": "DateTime getMinTime()", "full_signature": "@Override public DateTime getMinTime()", "class_method_signature": "HashJoinSegmentStorageAdapter.getMinTime()", "testcase": false, "constructor": false}, {"identifier": "getMaxTime", "parameters": "()", "modifiers": "@Override public", "return": "DateTime", "signature": "DateTime getMaxTime()", "full_signature": "@Override public DateTime getMaxTime()", "class_method_signature": "HashJoinSegmentStorageAdapter.getMaxTime()", "testcase": false, "constructor": false}, {"identifier": "getMinValue", "parameters": "(String column)", "modifiers": "@Nullable @Override public", "return": "Comparable", "signature": "Comparable getMinValue(String column)", "full_signature": "@Nullable @Override public Comparable getMinValue(String column)", "class_method_signature": "HashJoinSegmentStorageAdapter.getMinValue(String column)", "testcase": false, "constructor": false}, {"identifier": "getMaxValue", "parameters": "(String column)", "modifiers": "@Nullable @Override public", "return": "Comparable", "signature": "Comparable getMaxValue(String column)", "full_signature": "@Nullable @Override public Comparable getMaxValue(String column)", "class_method_signature": "HashJoinSegmentStorageAdapter.getMaxValue(String column)", "testcase": false, "constructor": false}, {"identifier": "getColumnCapabilities", "parameters": "(String column)", "modifiers": "@Nullable @Override public", "return": "ColumnCapabilities", "signature": "ColumnCapabilities getColumnCapabilities(String column)", "full_signature": "@Nullable @Override public ColumnCapabilities getColumnCapabilities(String column)", "class_method_signature": "HashJoinSegmentStorageAdapter.getColumnCapabilities(String column)", "testcase": false, "constructor": false}, {"identifier": "getColumnTypeName", "parameters": "(String column)", "modifiers": "@Nullable @Override public", "return": "String", "signature": "String getColumnTypeName(String column)", "full_signature": "@Nullable @Override public String getColumnTypeName(String column)", "class_method_signature": "HashJoinSegmentStorageAdapter.getColumnTypeName(String column)", "testcase": false, "constructor": false}, {"identifier": "getNumRows", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getNumRows()", "full_signature": "@Override public int getNumRows()", "class_method_signature": "HashJoinSegmentStorageAdapter.getNumRows()", "testcase": false, "constructor": false}, {"identifier": "getMaxIngestedEventTime", "parameters": "()", "modifiers": "@Override public", "return": "DateTime", "signature": "DateTime getMaxIngestedEventTime()", "full_signature": "@Override public DateTime getMaxIngestedEventTime()", "class_method_signature": "HashJoinSegmentStorageAdapter.getMaxIngestedEventTime()", "testcase": false, "constructor": false}, {"identifier": "getMetadata", "parameters": "()", "modifiers": "@Override public", "return": "Metadata", "signature": "Metadata getMetadata()", "full_signature": "@Override public Metadata getMetadata()", "class_method_signature": "HashJoinSegmentStorageAdapter.getMetadata()", "testcase": false, "constructor": false}, {"identifier": "makeCursors", "parameters": "(\n      @Nullable final Filter filter,\n      @Nonnull final Interval interval,\n      @Nonnull final VirtualColumns virtualColumns,\n      @Nonnull final Granularity gran,\n      final boolean descending,\n      @Nullable final QueryMetrics<?> queryMetrics\n  )", "modifiers": "@Override public", "return": "Sequence<Cursor>", "signature": "Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      @Nonnull final Interval interval,\n      @Nonnull final VirtualColumns virtualColumns,\n      @Nonnull final Granularity gran,\n      final boolean descending,\n      @Nullable final QueryMetrics<?> queryMetrics\n  )", "full_signature": "@Override public Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      @Nonnull final Interval interval,\n      @Nonnull final VirtualColumns virtualColumns,\n      @Nonnull final Granularity gran,\n      final boolean descending,\n      @Nullable final QueryMetrics<?> queryMetrics\n  )", "class_method_signature": "HashJoinSegmentStorageAdapter.makeCursors(\n      @Nullable final Filter filter,\n      @Nonnull final Interval interval,\n      @Nonnull final VirtualColumns virtualColumns,\n      @Nonnull final Granularity gran,\n      final boolean descending,\n      @Nullable final QueryMetrics<?> queryMetrics\n  )", "testcase": false, "constructor": false}, {"identifier": "isBaseColumn", "parameters": "(final String column)", "modifiers": "public", "return": "boolean", "signature": "boolean isBaseColumn(final String column)", "full_signature": "public boolean isBaseColumn(final String column)", "class_method_signature": "HashJoinSegmentStorageAdapter.isBaseColumn(final String column)", "testcase": false, "constructor": false}, {"identifier": "determineBaseColumnsWithPreAndPostJoinVirtualColumns", "parameters": "(\n      VirtualColumns virtualColumns,\n      @Nullable List<VirtualColumn> preJoinVirtualColumns,\n      @Nullable List<VirtualColumn> postJoinVirtualColumns\n  )", "modifiers": "public", "return": "Set<String>", "signature": "Set<String> determineBaseColumnsWithPreAndPostJoinVirtualColumns(\n      VirtualColumns virtualColumns,\n      @Nullable List<VirtualColumn> preJoinVirtualColumns,\n      @Nullable List<VirtualColumn> postJoinVirtualColumns\n  )", "full_signature": "public Set<String> determineBaseColumnsWithPreAndPostJoinVirtualColumns(\n      VirtualColumns virtualColumns,\n      @Nullable List<VirtualColumn> preJoinVirtualColumns,\n      @Nullable List<VirtualColumn> postJoinVirtualColumns\n  )", "class_method_signature": "HashJoinSegmentStorageAdapter.determineBaseColumnsWithPreAndPostJoinVirtualColumns(\n      VirtualColumns virtualColumns,\n      @Nullable List<VirtualColumn> preJoinVirtualColumns,\n      @Nullable List<VirtualColumn> postJoinVirtualColumns\n  )", "testcase": false, "constructor": false}, {"identifier": "getClauseForColumn", "parameters": "(final String column)", "modifiers": "private", "return": "Optional<JoinableClause>", "signature": "Optional<JoinableClause> getClauseForColumn(final String column)", "full_signature": "private Optional<JoinableClause> getClauseForColumn(final String column)", "class_method_signature": "HashJoinSegmentStorageAdapter.getClauseForColumn(final String column)", "testcase": false, "constructor": false}], "file": "processing/src/main/java/org/apache/druid/segment/join/HashJoinSegmentStorageAdapter.java"}, "focal_method": {"identifier": "makeCursors", "parameters": "(\n      @Nullable final Filter filter,\n      @Nonnull final Interval interval,\n      @Nonnull final VirtualColumns virtualColumns,\n      @Nonnull final Granularity gran,\n      final boolean descending,\n      @Nullable final QueryMetrics<?> queryMetrics\n  )", "modifiers": "@Override public", "return": "Sequence<Cursor>", "body": "@Override\n  public Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      @Nonnull final Interval interval,\n      @Nonnull final VirtualColumns virtualColumns,\n      @Nonnull final Granularity gran,\n      final boolean descending,\n      @Nullable final QueryMetrics<?> queryMetrics\n  )\n  {\n    // Filter pre-analysis key implied by the call to \"makeCursors\". We need to sanity-check that it matches\n    // the actual pre-analysis that was done. Note: we can't infer a rewrite config from the \"makeCursors\" call (it\n    // requires access to the query context) so we'll need to skip sanity-checking it, by re-using the one present\n    // in the cached key.)\n    final JoinFilterPreAnalysisKey keyIn =\n        new JoinFilterPreAnalysisKey(\n            joinFilterPreAnalysis.getKey().getRewriteConfig(),\n            clauses,\n            virtualColumns,\n            filter\n        );\n\n    final JoinFilterPreAnalysisKey keyCached = joinFilterPreAnalysis.getKey();\n\n    if (!keyIn.equals(keyCached)) {\n      // It is a bug if this happens. The implied key and the cached key should always match.\n      throw new ISE(\"Pre-analysis mismatch, cannot execute query\");\n    }\n\n    final List<VirtualColumn> preJoinVirtualColumns = new ArrayList<>();\n    final List<VirtualColumn> postJoinVirtualColumns = new ArrayList<>();\n\n    determineBaseColumnsWithPreAndPostJoinVirtualColumns(\n        virtualColumns,\n        preJoinVirtualColumns,\n        postJoinVirtualColumns\n    );\n\n    JoinFilterSplit joinFilterSplit = JoinFilterAnalyzer.splitFilter(joinFilterPreAnalysis);\n    preJoinVirtualColumns.addAll(joinFilterSplit.getPushDownVirtualColumns());\n\n    // Soon, we will need a way to push filters past a join when possible. This could potentially be done right here\n    // (by splitting out pushable pieces of 'filter') or it could be done at a higher level (i.e. in the SQL planner).\n    //\n    // If it's done in the SQL planner, that will likely mean adding a 'baseFilter' parameter to this class that would\n    // be passed in to the below baseAdapter.makeCursors call (instead of the null filter).\n    final Sequence<Cursor> baseCursorSequence = baseAdapter.makeCursors(\n        joinFilterSplit.getBaseTableFilter().isPresent() ? joinFilterSplit.getBaseTableFilter().get() : null,\n        interval,\n        VirtualColumns.create(preJoinVirtualColumns),\n        gran,\n        descending,\n        queryMetrics\n    );\n\n    Closer joinablesCloser = Closer.create();\n    return Sequences.<Cursor, Cursor>map(\n        baseCursorSequence,\n        cursor -> {\n          assert cursor != null;\n          Cursor retVal = cursor;\n\n          for (JoinableClause clause : clauses) {\n            retVal = HashJoinEngine.makeJoinCursor(retVal, clause, descending, joinablesCloser);\n          }\n\n          return PostJoinCursor.wrap(\n              retVal,\n              VirtualColumns.create(postJoinVirtualColumns),\n              joinFilterSplit.getJoinTableFilter().isPresent() ? joinFilterSplit.getJoinTableFilter().get() : null\n          );\n        }\n    ).withBaggage(joinablesCloser);\n  }", "signature": "Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      @Nonnull final Interval interval,\n      @Nonnull final VirtualColumns virtualColumns,\n      @Nonnull final Granularity gran,\n      final boolean descending,\n      @Nullable final QueryMetrics<?> queryMetrics\n  )", "full_signature": "@Override public Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      @Nonnull final Interval interval,\n      @Nonnull final VirtualColumns virtualColumns,\n      @Nonnull final Granularity gran,\n      final boolean descending,\n      @Nullable final QueryMetrics<?> queryMetrics\n  )", "class_method_signature": "HashJoinSegmentStorageAdapter.makeCursors(\n      @Nullable final Filter filter,\n      @Nonnull final Interval interval,\n      @Nonnull final VirtualColumns virtualColumns,\n      @Nonnull final Granularity gran,\n      final boolean descending,\n      @Nullable final QueryMetrics<?> queryMetrics\n  )", "testcase": false, "constructor": false, "invocations": ["getRewriteConfig", "getKey", "getKey", "equals", "determineBaseColumnsWithPreAndPostJoinVirtualColumns", "splitFilter", "addAll", "getPushDownVirtualColumns", "makeCursors", "isPresent", "getBaseTableFilter", "get", "getBaseTableFilter", "create", "create", "withBaggage", "map", "makeJoinCursor", "wrap", "create", "isPresent", "getJoinTableFilter", "get", "getJoinTableFilter"]}, "repository": {"repo_id": 6358188, "url": "https://github.com/apache/druid", "stars": 9116, "created": "10/23/2012 7:08:07 PM +00:00", "updates": "2020-01-27T21:36:20+00:00", "fork": "False", "license": "licensed"}}