{"test_class": {"identifier": "InodeTreeTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String TEST_PATH = \"test\";", "modifier": "private static final", "type": "String", "declarator": "TEST_PATH = \"test\"", "var_name": "TEST_PATH"}, {"original_string": "private static final AlluxioURI TEST_URI = new AlluxioURI(\"/test\");", "modifier": "private static final", "type": "AlluxioURI", "declarator": "TEST_URI = new AlluxioURI(\"/test\")", "var_name": "TEST_URI"}, {"original_string": "private static final AlluxioURI NESTED_URI = new AlluxioURI(\"/nested/test\");", "modifier": "private static final", "type": "AlluxioURI", "declarator": "NESTED_URI = new AlluxioURI(\"/nested/test\")", "var_name": "NESTED_URI"}, {"original_string": "private static final AlluxioURI NESTED_DIR_URI = new AlluxioURI(\"/nested/test/dir\");", "modifier": "private static final", "type": "AlluxioURI", "declarator": "NESTED_DIR_URI = new AlluxioURI(\"/nested/test/dir\")", "var_name": "NESTED_DIR_URI"}, {"original_string": "private static final AlluxioURI NESTED_DIR_FILE_URI = new AlluxioURI(\"/nested/test/dir/file1\");", "modifier": "private static final", "type": "AlluxioURI", "declarator": "NESTED_DIR_FILE_URI = new AlluxioURI(\"/nested/test/dir/file1\")", "var_name": "NESTED_DIR_FILE_URI"}, {"original_string": "private static final AlluxioURI NESTED_FILE_URI = new AlluxioURI(\"/nested/test/file\");", "modifier": "private static final", "type": "AlluxioURI", "declarator": "NESTED_FILE_URI = new AlluxioURI(\"/nested/test/file\")", "var_name": "NESTED_FILE_URI"}, {"original_string": "private static final AlluxioURI NESTED_MULTIDIR_FILE_URI\n      = new AlluxioURI(\"/nested/test/dira/dirb/file\");", "modifier": "private static final", "type": "AlluxioURI", "declarator": "NESTED_MULTIDIR_FILE_URI\n      = new AlluxioURI(\"/nested/test/dira/dirb/file\")", "var_name": "NESTED_MULTIDIR_FILE_URI"}, {"original_string": "public static final String TEST_OWNER = \"user1\";", "modifier": "public static final", "type": "String", "declarator": "TEST_OWNER = \"user1\"", "var_name": "TEST_OWNER"}, {"original_string": "public static final String TEST_GROUP = \"group1\";", "modifier": "public static final", "type": "String", "declarator": "TEST_GROUP = \"group1\"", "var_name": "TEST_GROUP"}, {"original_string": "public static final Mode TEST_DIR_MODE = new Mode((short) 0755);", "modifier": "public static final", "type": "Mode", "declarator": "TEST_DIR_MODE = new Mode((short) 0755)", "var_name": "TEST_DIR_MODE"}, {"original_string": "public static final Mode TEST_FILE_MODE = new Mode((short) 0644);", "modifier": "public static final", "type": "Mode", "declarator": "TEST_FILE_MODE = new Mode((short) 0644)", "var_name": "TEST_FILE_MODE"}, {"original_string": "private static CreateFileContext sFileContext;", "modifier": "private static", "type": "CreateFileContext", "declarator": "sFileContext", "var_name": "sFileContext"}, {"original_string": "private static CreateDirectoryContext sDirectoryContext;", "modifier": "private static", "type": "CreateDirectoryContext", "declarator": "sDirectoryContext", "var_name": "sDirectoryContext"}, {"original_string": "private static CreateFileContext sNestedFileContext;", "modifier": "private static", "type": "CreateFileContext", "declarator": "sNestedFileContext", "var_name": "sNestedFileContext"}, {"original_string": "private static CreateDirectoryContext sNestedDirectoryContext;", "modifier": "private static", "type": "CreateDirectoryContext", "declarator": "sNestedDirectoryContext", "var_name": "sNestedDirectoryContext"}, {"original_string": "private InodeStore mInodeStore;", "modifier": "private", "type": "InodeStore", "declarator": "mInodeStore", "var_name": "mInodeStore"}, {"original_string": "private InodeTree mTree;", "modifier": "private", "type": "InodeTree", "declarator": "mTree", "var_name": "mTree"}, {"original_string": "private MasterRegistry mRegistry;", "modifier": "private", "type": "MasterRegistry", "declarator": "mRegistry", "var_name": "mRegistry"}, {"original_string": "private MetricsMaster mMetricsMaster;", "modifier": "private", "type": "MetricsMaster", "declarator": "mMetricsMaster", "var_name": "mMetricsMaster"}, {"original_string": "@Rule\n  public TemporaryFolder mTestFolder = new TemporaryFolder();", "modifier": "@Rule\n  public", "type": "TemporaryFolder", "declarator": "mTestFolder = new TemporaryFolder()", "var_name": "mTestFolder"}, {"original_string": "@Rule\n  public ExpectedException mThrown = ExpectedException.none();", "modifier": "@Rule\n  public", "type": "ExpectedException", "declarator": "mThrown = ExpectedException.none()", "var_name": "mThrown"}, {"original_string": "@Rule\n  public ConfigurationRule mConfigurationRule =\n      new ConfigurationRule(new ImmutableMap.Builder<PropertyKey, String>()\n          .put(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\")\n          .put(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP, \"test-supergroup\")\n          .build(), ServerConfiguration.global());", "modifier": "@Rule\n  public", "type": "ConfigurationRule", "declarator": "mConfigurationRule =\n      new ConfigurationRule(new ImmutableMap.Builder<PropertyKey, String>()\n          .put(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\")\n          .put(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP, \"test-supergroup\")\n          .build(), ServerConfiguration.global())", "var_name": "mConfigurationRule"}], "file": "core/server/master/src/test/java/alluxio/master/file/meta/InodeTreeTest.java"}, "test_case": {"identifier": "createExistingDirectory", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void createExistingDirectory() throws Exception {\n    // create directory\n    createPath(mTree, TEST_URI, sDirectoryContext);\n\n    // create again with allowExists true\n    createPath(mTree, TEST_URI, CreateDirectoryContext\n        .mergeFrom(CreateDirectoryPOptions.newBuilder().setAllowExists(true)));\n\n    // create again with allowExists false\n    mThrown.expect(FileAlreadyExistsException.class);\n    mThrown\n        .expectMessage(\"Not allowed to create directory because path already exists: \" + TEST_URI);\n    createPath(mTree, TEST_URI, CreateDirectoryContext\n        .mergeFrom(CreateDirectoryPOptions.newBuilder().setAllowExists(false)));\n  }", "signature": "void createExistingDirectory()", "full_signature": "@Test public void createExistingDirectory()", "class_method_signature": "InodeTreeTest.createExistingDirectory()", "testcase": true, "constructor": false, "invocations": ["createPath", "createPath", "mergeFrom", "setAllowExists", "newBuilder", "expect", "expectMessage", "createPath", "mergeFrom", "setAllowExists", "newBuilder"]}, "focal_class": {"identifier": "InodeTree", "superclass": "", "interfaces": "implements DelegatingJournaled", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(InodeTree.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(InodeTree.class)", "var_name": "LOG"}, {"original_string": "private static final int PERSIST_WAIT_BASE_SLEEP_MS = 2;", "modifier": "private static final", "type": "int", "declarator": "PERSIST_WAIT_BASE_SLEEP_MS = 2", "var_name": "PERSIST_WAIT_BASE_SLEEP_MS"}, {"original_string": "private static final int PERSIST_WAIT_MAX_SLEEP_MS = 1000;", "modifier": "private static final", "type": "int", "declarator": "PERSIST_WAIT_MAX_SLEEP_MS = 1000", "var_name": "PERSIST_WAIT_MAX_SLEEP_MS"}, {"original_string": "private static final int PERSIST_WAIT_MAX_RETRIES = 50;", "modifier": "private static final", "type": "int", "declarator": "PERSIST_WAIT_MAX_RETRIES = 50", "var_name": "PERSIST_WAIT_MAX_RETRIES"}, {"original_string": "public static final long NO_PARENT = -1;", "modifier": "public static final", "type": "long", "declarator": "NO_PARENT = -1", "var_name": "NO_PARENT"}, {"original_string": "public static final String ROOT_INODE_NAME = \"\";", "modifier": "public static final", "type": "String", "declarator": "ROOT_INODE_NAME = \"\"", "var_name": "ROOT_INODE_NAME"}, {"original_string": "public static final String ROOT_PATH = \"/\";", "modifier": "public static final", "type": "String", "declarator": "ROOT_PATH = \"/\"", "var_name": "ROOT_PATH"}, {"original_string": "public static final int PATH_TRAVERSAL_RETRIES = 1000;", "modifier": "public static final", "type": "int", "declarator": "PATH_TRAVERSAL_RETRIES = 1000", "var_name": "PATH_TRAVERSAL_RETRIES"}, {"original_string": "private final MountTable mMountTable;", "modifier": "private final", "type": "MountTable", "declarator": "mMountTable", "var_name": "mMountTable"}, {"original_string": "private final TtlBucketList mTtlBuckets;", "modifier": "private final", "type": "TtlBucketList", "declarator": "mTtlBuckets", "var_name": "mTtlBuckets"}, {"original_string": "private final InodeLockManager mInodeLockManager;", "modifier": "private final", "type": "InodeLockManager", "declarator": "mInodeLockManager", "var_name": "mInodeLockManager"}, {"original_string": "private final ReadOnlyInodeStore mInodeStore;", "modifier": "private final", "type": "ReadOnlyInodeStore", "declarator": "mInodeStore", "var_name": "mInodeStore"}, {"original_string": "private final InodeTreePersistentState mState;", "modifier": "private final", "type": "InodeTreePersistentState", "declarator": "mState", "var_name": "mState"}, {"original_string": "private final ContainerIdGenerable mContainerIdGenerator;", "modifier": "private final", "type": "ContainerIdGenerable", "declarator": "mContainerIdGenerator", "var_name": "mContainerIdGenerator"}, {"original_string": "private final InodeDirectoryIdGenerator mDirectoryIdGenerator;", "modifier": "private final", "type": "InodeDirectoryIdGenerator", "declarator": "mDirectoryIdGenerator", "var_name": "mDirectoryIdGenerator"}], "methods": [{"identifier": "InodeTree", "parameters": "(InodeStore inodeStore, ContainerIdGenerable containerIdGenerator,\n      InodeDirectoryIdGenerator directoryIdGenerator, MountTable mountTable,\n      InodeLockManager lockManager)", "modifiers": "public", "return": "", "signature": " InodeTree(InodeStore inodeStore, ContainerIdGenerable containerIdGenerator,\n      InodeDirectoryIdGenerator directoryIdGenerator, MountTable mountTable,\n      InodeLockManager lockManager)", "full_signature": "public  InodeTree(InodeStore inodeStore, ContainerIdGenerable containerIdGenerator,\n      InodeDirectoryIdGenerator directoryIdGenerator, MountTable mountTable,\n      InodeLockManager lockManager)", "class_method_signature": "InodeTree.InodeTree(InodeStore inodeStore, ContainerIdGenerable containerIdGenerator,\n      InodeDirectoryIdGenerator directoryIdGenerator, MountTable mountTable,\n      InodeLockManager lockManager)", "testcase": false, "constructor": true}, {"identifier": "initializeRoot", "parameters": "(String owner, String group, Mode mode, JournalContext context)", "modifiers": "public", "return": "void", "signature": "void initializeRoot(String owner, String group, Mode mode, JournalContext context)", "full_signature": "public void initializeRoot(String owner, String group, Mode mode, JournalContext context)", "class_method_signature": "InodeTree.initializeRoot(String owner, String group, Mode mode, JournalContext context)", "testcase": false, "constructor": false}, {"identifier": "getTtlBuckets", "parameters": "()", "modifiers": "public", "return": "TtlBucketList", "signature": "TtlBucketList getTtlBuckets()", "full_signature": "public TtlBucketList getTtlBuckets()", "class_method_signature": "InodeTree.getTtlBuckets()", "testcase": false, "constructor": false}, {"identifier": "getInodeCount", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getInodeCount()", "full_signature": "public long getInodeCount()", "class_method_signature": "InodeTree.getInodeCount()", "testcase": false, "constructor": false}, {"identifier": "setDirectChildrenLoaded", "parameters": "(Supplier<JournalContext> context, InodeDirectory dir)", "modifiers": "public", "return": "void", "signature": "void setDirectChildrenLoaded(Supplier<JournalContext> context, InodeDirectory dir)", "full_signature": "public void setDirectChildrenLoaded(Supplier<JournalContext> context, InodeDirectory dir)", "class_method_signature": "InodeTree.setDirectChildrenLoaded(Supplier<JournalContext> context, InodeDirectory dir)", "testcase": false, "constructor": false}, {"identifier": "newBlock", "parameters": "(Supplier<JournalContext> context, NewBlockEntry entry)", "modifiers": "public", "return": "long", "signature": "long newBlock(Supplier<JournalContext> context, NewBlockEntry entry)", "full_signature": "public long newBlock(Supplier<JournalContext> context, NewBlockEntry entry)", "class_method_signature": "InodeTree.newBlock(Supplier<JournalContext> context, NewBlockEntry entry)", "testcase": false, "constructor": false}, {"identifier": "updateInodeFile", "parameters": "(Supplier<JournalContext> context, UpdateInodeFileEntry entry)", "modifiers": "public", "return": "void", "signature": "void updateInodeFile(Supplier<JournalContext> context, UpdateInodeFileEntry entry)", "full_signature": "public void updateInodeFile(Supplier<JournalContext> context, UpdateInodeFileEntry entry)", "class_method_signature": "InodeTree.updateInodeFile(Supplier<JournalContext> context, UpdateInodeFileEntry entry)", "testcase": false, "constructor": false}, {"identifier": "updateInode", "parameters": "(Supplier<JournalContext> context, UpdateInodeEntry entry)", "modifiers": "public", "return": "void", "signature": "void updateInode(Supplier<JournalContext> context, UpdateInodeEntry entry)", "full_signature": "public void updateInode(Supplier<JournalContext> context, UpdateInodeEntry entry)", "class_method_signature": "InodeTree.updateInode(Supplier<JournalContext> context, UpdateInodeEntry entry)", "testcase": false, "constructor": false}, {"identifier": "updateInodeAccessTimeNoJournal", "parameters": "(long inodeId, long accessTime)", "modifiers": "public", "return": "UpdateInodeEntry", "signature": "UpdateInodeEntry updateInodeAccessTimeNoJournal(long inodeId, long accessTime)", "full_signature": "public UpdateInodeEntry updateInodeAccessTimeNoJournal(long inodeId, long accessTime)", "class_method_signature": "InodeTree.updateInodeAccessTimeNoJournal(long inodeId, long accessTime)", "testcase": false, "constructor": false}, {"identifier": "rename", "parameters": "(Supplier<JournalContext> context, RenameEntry entry)", "modifiers": "public", "return": "void", "signature": "void rename(Supplier<JournalContext> context, RenameEntry entry)", "full_signature": "public void rename(Supplier<JournalContext> context, RenameEntry entry)", "class_method_signature": "InodeTree.rename(Supplier<JournalContext> context, RenameEntry entry)", "testcase": false, "constructor": false}, {"identifier": "setAcl", "parameters": "(Supplier<JournalContext> context, SetAclEntry entry)", "modifiers": "public", "return": "void", "signature": "void setAcl(Supplier<JournalContext> context, SetAclEntry entry)", "full_signature": "public void setAcl(Supplier<JournalContext> context, SetAclEntry entry)", "class_method_signature": "InodeTree.setAcl(Supplier<JournalContext> context, SetAclEntry entry)", "testcase": false, "constructor": false}, {"identifier": "getRootUserName", "parameters": "()", "modifiers": "@Nullable public", "return": "String", "signature": "String getRootUserName()", "full_signature": "@Nullable public String getRootUserName()", "class_method_signature": "InodeTree.getRootUserName()", "testcase": false, "constructor": false}, {"identifier": "getPinnedSize", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getPinnedSize()", "full_signature": "public int getPinnedSize()", "class_method_signature": "InodeTree.getPinnedSize()", "testcase": false, "constructor": false}, {"identifier": "inodeIdExists", "parameters": "(long id)", "modifiers": "public", "return": "boolean", "signature": "boolean inodeIdExists(long id)", "full_signature": "public boolean inodeIdExists(long id)", "class_method_signature": "InodeTree.inodeIdExists(long id)", "testcase": false, "constructor": false}, {"identifier": "tryLockInodePath", "parameters": "(LockingScheme scheme)", "modifiers": "public", "return": "LockedInodePath", "signature": "LockedInodePath tryLockInodePath(LockingScheme scheme)", "full_signature": "public LockedInodePath tryLockInodePath(LockingScheme scheme)", "class_method_signature": "InodeTree.tryLockInodePath(LockingScheme scheme)", "testcase": false, "constructor": false}, {"identifier": "lockInodePath", "parameters": "(LockingScheme scheme)", "modifiers": "public", "return": "LockedInodePath", "signature": "LockedInodePath lockInodePath(LockingScheme scheme)", "full_signature": "public LockedInodePath lockInodePath(LockingScheme scheme)", "class_method_signature": "InodeTree.lockInodePath(LockingScheme scheme)", "testcase": false, "constructor": false}, {"identifier": "lockInodePath", "parameters": "(AlluxioURI uri, LockPattern lockPattern)", "modifiers": "public", "return": "LockedInodePath", "signature": "LockedInodePath lockInodePath(AlluxioURI uri, LockPattern lockPattern)", "full_signature": "public LockedInodePath lockInodePath(AlluxioURI uri, LockPattern lockPattern)", "class_method_signature": "InodeTree.lockInodePath(AlluxioURI uri, LockPattern lockPattern)", "testcase": false, "constructor": false}, {"identifier": "lockInodePath", "parameters": "(AlluxioURI uri, LockPattern lockPattern, boolean tryLock)", "modifiers": "public", "return": "LockedInodePath", "signature": "LockedInodePath lockInodePath(AlluxioURI uri, LockPattern lockPattern, boolean tryLock)", "full_signature": "public LockedInodePath lockInodePath(AlluxioURI uri, LockPattern lockPattern, boolean tryLock)", "class_method_signature": "InodeTree.lockInodePath(AlluxioURI uri, LockPattern lockPattern, boolean tryLock)", "testcase": false, "constructor": false}, {"identifier": "inodePathExists", "parameters": "(AlluxioURI uri)", "modifiers": "public", "return": "boolean", "signature": "boolean inodePathExists(AlluxioURI uri)", "full_signature": "public boolean inodePathExists(AlluxioURI uri)", "class_method_signature": "InodeTree.inodePathExists(AlluxioURI uri)", "testcase": false, "constructor": false}, {"identifier": "lockFullInodePath", "parameters": "(AlluxioURI uri, LockingScheme lockScheme)", "modifiers": "public", "return": "LockedInodePath", "signature": "LockedInodePath lockFullInodePath(AlluxioURI uri, LockingScheme lockScheme)", "full_signature": "public LockedInodePath lockFullInodePath(AlluxioURI uri, LockingScheme lockScheme)", "class_method_signature": "InodeTree.lockFullInodePath(AlluxioURI uri, LockingScheme lockScheme)", "testcase": false, "constructor": false}, {"identifier": "lockFullInodePath", "parameters": "(AlluxioURI uri, LockPattern lockPattern)", "modifiers": "public", "return": "LockedInodePath", "signature": "LockedInodePath lockFullInodePath(AlluxioURI uri, LockPattern lockPattern)", "full_signature": "public LockedInodePath lockFullInodePath(AlluxioURI uri, LockPattern lockPattern)", "class_method_signature": "InodeTree.lockFullInodePath(AlluxioURI uri, LockPattern lockPattern)", "testcase": false, "constructor": false}, {"identifier": "lockFullInodePath", "parameters": "(long id, LockPattern lockPattern)", "modifiers": "public", "return": "LockedInodePath", "signature": "LockedInodePath lockFullInodePath(long id, LockPattern lockPattern)", "full_signature": "public LockedInodePath lockFullInodePath(long id, LockPattern lockPattern)", "class_method_signature": "InodeTree.lockFullInodePath(long id, LockPattern lockPattern)", "testcase": false, "constructor": false}, {"identifier": "lockInodePathById", "parameters": "(long id, LockPattern lockPattern)", "modifiers": "private", "return": "LockedInodePath", "signature": "LockedInodePath lockInodePathById(long id, LockPattern lockPattern)", "full_signature": "private LockedInodePath lockInodePathById(long id, LockPattern lockPattern)", "class_method_signature": "InodeTree.lockInodePathById(long id, LockPattern lockPattern)", "testcase": false, "constructor": false}, {"identifier": "lockInodePathPair", "parameters": "(AlluxioURI path1, LockPattern lockPattern1,\n      AlluxioURI path2, LockPattern lockPattern2)", "modifiers": "public", "return": "InodePathPair", "signature": "InodePathPair lockInodePathPair(AlluxioURI path1, LockPattern lockPattern1,\n      AlluxioURI path2, LockPattern lockPattern2)", "full_signature": "public InodePathPair lockInodePathPair(AlluxioURI path1, LockPattern lockPattern1,\n      AlluxioURI path2, LockPattern lockPattern2)", "class_method_signature": "InodeTree.lockInodePathPair(AlluxioURI path1, LockPattern lockPattern1,\n      AlluxioURI path2, LockPattern lockPattern2)", "testcase": false, "constructor": false}, {"identifier": "ensureFullInodePath", "parameters": "(LockedInodePath inodePath)", "modifiers": "public", "return": "void", "signature": "void ensureFullInodePath(LockedInodePath inodePath)", "full_signature": "public void ensureFullInodePath(LockedInodePath inodePath)", "class_method_signature": "InodeTree.ensureFullInodePath(LockedInodePath inodePath)", "testcase": false, "constructor": false}, {"identifier": "computePathForInode", "parameters": "(InodeView inode, StringBuilder builder)", "modifiers": "private", "return": "void", "signature": "void computePathForInode(InodeView inode, StringBuilder builder)", "full_signature": "private void computePathForInode(InodeView inode, StringBuilder builder)", "class_method_signature": "InodeTree.computePathForInode(InodeView inode, StringBuilder builder)", "testcase": false, "constructor": false}, {"identifier": "getPath", "parameters": "(InodeView inode)", "modifiers": "public", "return": "AlluxioURI", "signature": "AlluxioURI getPath(InodeView inode)", "full_signature": "public AlluxioURI getPath(InodeView inode)", "class_method_signature": "InodeTree.getPath(InodeView inode)", "testcase": false, "constructor": false}, {"identifier": "getRoot", "parameters": "()", "modifiers": "public", "return": "InodeDirectory", "signature": "InodeDirectory getRoot()", "full_signature": "public InodeDirectory getRoot()", "class_method_signature": "InodeTree.getRoot()", "testcase": false, "constructor": false}, {"identifier": "createPath", "parameters": "(RpcContext rpcContext, LockedInodePath inodePath,\n      CreatePathContext<?, ?> context)", "modifiers": "public", "return": "List<Inode>", "signature": "List<Inode> createPath(RpcContext rpcContext, LockedInodePath inodePath,\n      CreatePathContext<?, ?> context)", "full_signature": "public List<Inode> createPath(RpcContext rpcContext, LockedInodePath inodePath,\n      CreatePathContext<?, ?> context)", "class_method_signature": "InodeTree.createPath(RpcContext rpcContext, LockedInodePath inodePath,\n      CreatePathContext<?, ?> context)", "testcase": false, "constructor": false}, {"identifier": "inheritOwnerAndGroupIfEmpty", "parameters": "(MutableInode<?> newInode,\n      InodeDirectoryView ancestorInode)", "modifiers": "private static", "return": "void", "signature": "void inheritOwnerAndGroupIfEmpty(MutableInode<?> newInode,\n      InodeDirectoryView ancestorInode)", "full_signature": "private static void inheritOwnerAndGroupIfEmpty(MutableInode<?> newInode,\n      InodeDirectoryView ancestorInode)", "class_method_signature": "InodeTree.inheritOwnerAndGroupIfEmpty(MutableInode<?> newInode,\n      InodeDirectoryView ancestorInode)", "testcase": false, "constructor": false}, {"identifier": "getDescendants", "parameters": "(LockedInodePath inodePath)", "modifiers": "public", "return": "LockedInodePathList", "signature": "LockedInodePathList getDescendants(LockedInodePath inodePath)", "full_signature": "public LockedInodePathList getDescendants(LockedInodePath inodePath)", "class_method_signature": "InodeTree.getDescendants(LockedInodePath inodePath)", "testcase": false, "constructor": false}, {"identifier": "gatherDescendants", "parameters": "(LockedInodePath inodePath, List<LockedInodePath> descendants)", "modifiers": "private", "return": "void", "signature": "void gatherDescendants(LockedInodePath inodePath, List<LockedInodePath> descendants)", "full_signature": "private void gatherDescendants(LockedInodePath inodePath, List<LockedInodePath> descendants)", "class_method_signature": "InodeTree.gatherDescendants(LockedInodePath inodePath, List<LockedInodePath> descendants)", "testcase": false, "constructor": false}, {"identifier": "deleteInode", "parameters": "(RpcContext rpcContext, LockedInodePath inodePath, long opTimeMs)", "modifiers": "public", "return": "void", "signature": "void deleteInode(RpcContext rpcContext, LockedInodePath inodePath, long opTimeMs)", "full_signature": "public void deleteInode(RpcContext rpcContext, LockedInodePath inodePath, long opTimeMs)", "class_method_signature": "InodeTree.deleteInode(RpcContext rpcContext, LockedInodePath inodePath, long opTimeMs)", "testcase": false, "constructor": false}, {"identifier": "checkPinningValidity", "parameters": "(Set<String> pinnedMediumTypes)", "modifiers": "private", "return": "boolean", "signature": "boolean checkPinningValidity(Set<String> pinnedMediumTypes)", "full_signature": "private boolean checkPinningValidity(Set<String> pinnedMediumTypes)", "class_method_signature": "InodeTree.checkPinningValidity(Set<String> pinnedMediumTypes)", "testcase": false, "constructor": false}, {"identifier": "setPinned", "parameters": "(RpcContext rpcContext, LockedInodePath inodePath, boolean pinned,\n      List<String> mediumTypes, long opTimeMs)", "modifiers": "public", "return": "void", "signature": "void setPinned(RpcContext rpcContext, LockedInodePath inodePath, boolean pinned,\n      List<String> mediumTypes, long opTimeMs)", "full_signature": "public void setPinned(RpcContext rpcContext, LockedInodePath inodePath, boolean pinned,\n      List<String> mediumTypes, long opTimeMs)", "class_method_signature": "InodeTree.setPinned(RpcContext rpcContext, LockedInodePath inodePath, boolean pinned,\n      List<String> mediumTypes, long opTimeMs)", "testcase": false, "constructor": false}, {"identifier": "setReplication", "parameters": "(RpcContext rpcContext, LockedInodePath inodePath,\n      Integer replicationMax, Integer replicationMin, long opTimeMs)", "modifiers": "public", "return": "void", "signature": "void setReplication(RpcContext rpcContext, LockedInodePath inodePath,\n      Integer replicationMax, Integer replicationMin, long opTimeMs)", "full_signature": "public void setReplication(RpcContext rpcContext, LockedInodePath inodePath,\n      Integer replicationMax, Integer replicationMin, long opTimeMs)", "class_method_signature": "InodeTree.setReplication(RpcContext rpcContext, LockedInodePath inodePath,\n      Integer replicationMax, Integer replicationMin, long opTimeMs)", "testcase": false, "constructor": false}, {"identifier": "getReplicationLimitedFileIds", "parameters": "()", "modifiers": "public", "return": "Set<Long>", "signature": "Set<Long> getReplicationLimitedFileIds()", "full_signature": "public Set<Long> getReplicationLimitedFileIds()", "class_method_signature": "InodeTree.getReplicationLimitedFileIds()", "testcase": false, "constructor": false}, {"identifier": "getToBePersistedIds", "parameters": "()", "modifiers": "public", "return": "Set<Long>", "signature": "Set<Long> getToBePersistedIds()", "full_signature": "public Set<Long> getToBePersistedIds()", "class_method_signature": "InodeTree.getToBePersistedIds()", "testcase": false, "constructor": false}, {"identifier": "getPinIdSet", "parameters": "()", "modifiers": "public", "return": "Set<Long>", "signature": "Set<Long> getPinIdSet()", "full_signature": "public Set<Long> getPinIdSet()", "class_method_signature": "InodeTree.getPinIdSet()", "testcase": false, "constructor": false}, {"identifier": "getInodeLockManager", "parameters": "()", "modifiers": "public", "return": "InodeLockManager", "signature": "InodeLockManager getInodeLockManager()", "full_signature": "public InodeLockManager getInodeLockManager()", "class_method_signature": "InodeTree.getInodeLockManager()", "testcase": false, "constructor": false}, {"identifier": "isRootId", "parameters": "(long fileId)", "modifiers": "public", "return": "boolean", "signature": "boolean isRootId(long fileId)", "full_signature": "public boolean isRootId(long fileId)", "class_method_signature": "InodeTree.isRootId(long fileId)", "testcase": false, "constructor": false}, {"identifier": "getDelegate", "parameters": "()", "modifiers": "@Override public", "return": "Journaled", "signature": "Journaled getDelegate()", "full_signature": "@Override public Journaled getDelegate()", "class_method_signature": "InodeTree.getDelegate()", "testcase": false, "constructor": false}, {"identifier": "syncPersistExistingDirectory", "parameters": "(Supplier<JournalContext> context, InodeDirectoryView dir)", "modifiers": "public", "return": "void", "signature": "void syncPersistExistingDirectory(Supplier<JournalContext> context, InodeDirectoryView dir)", "full_signature": "public void syncPersistExistingDirectory(Supplier<JournalContext> context, InodeDirectoryView dir)", "class_method_signature": "InodeTree.syncPersistExistingDirectory(Supplier<JournalContext> context, InodeDirectoryView dir)", "testcase": false, "constructor": false}, {"identifier": "syncPersistNewDirectory", "parameters": "(MutableInodeDirectory dir)", "modifiers": "public", "return": "void", "signature": "void syncPersistNewDirectory(MutableInodeDirectory dir)", "full_signature": "public void syncPersistNewDirectory(MutableInodeDirectory dir)", "class_method_signature": "InodeTree.syncPersistNewDirectory(MutableInodeDirectory dir)", "testcase": false, "constructor": false}, {"identifier": "syncPersistDirectory", "parameters": "(InodeDirectoryView dir)", "modifiers": "private", "return": "Optional<UfsStatus>", "signature": "Optional<UfsStatus> syncPersistDirectory(InodeDirectoryView dir)", "full_signature": "private Optional<UfsStatus> syncPersistDirectory(InodeDirectoryView dir)", "class_method_signature": "InodeTree.syncPersistDirectory(InodeDirectoryView dir)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "InodeTree.close()", "testcase": false, "constructor": false}], "file": "core/server/master/src/main/java/alluxio/master/file/meta/InodeTree.java"}, "focal_method": {"identifier": "createPath", "parameters": "(RpcContext rpcContext, LockedInodePath inodePath,\n      CreatePathContext<?, ?> context)", "modifiers": "public", "return": "List<Inode>", "body": "public List<Inode> createPath(RpcContext rpcContext, LockedInodePath inodePath,\n      CreatePathContext<?, ?> context) throws FileAlreadyExistsException, BlockInfoException,\n      InvalidPathException, IOException, FileDoesNotExistException {\n    Preconditions.checkState(inodePath.getLockPattern() == LockPattern.WRITE_EDGE);\n\n    // TODO(gpang): consider splitting this into createFilePath and createDirectoryPath, with a\n    // helper method for the shared logic.\n    AlluxioURI path = inodePath.getUri();\n    if (path.isRoot()) {\n      String errorMessage = \"Not allowed to create existing root path: \" + path;\n      LOG.error(errorMessage);\n      throw new FileAlreadyExistsException(errorMessage);\n    }\n    if (inodePath.fullPathExists()) {\n      if (context instanceof CreateDirectoryContext\n          && ((CreateDirectoryContext) context).getOptions().getAllowExists()) {\n        return Collections.emptyList();\n      } else {\n        String pathType = \"file\";\n        if (context instanceof CreateDirectoryContext) {\n          pathType = \"directory\";\n        }\n        String errorMessage = String\n            .format(\"Not allowed to create %s because path already exists: %s\", pathType, path);\n        throw new FileAlreadyExistsException(errorMessage);\n      }\n    }\n\n    if (context instanceof CreateFileContext) {\n      CreateFileContext fileContext = (CreateFileContext) context;\n      if (fileContext.getOptions().getBlockSizeBytes() < 1) {\n        throw new BlockInfoException(\n            \"Invalid block size \" + fileContext.getOptions().getBlockSizeBytes());\n      }\n    }\n\n    LOG.debug(\"createPath {}\", path);\n\n    String[] pathComponents = inodePath.mPathComponents;\n    String name = path.getName();\n\n    // pathIndex is the index into pathComponents where we start filling in the path from the inode.\n    int pathIndex = inodePath.getExistingInodeCount();\n    if (pathIndex < pathComponents.length - 1) {\n      // The immediate parent was not found. If it's not recursive, we throw an exception here.\n      // Otherwise we add the remaining path components to the list of components to create.\n      if (!context.isRecursive()) {\n        throw new FileDoesNotExistException(String.format(\n            \"File %s creation failed. Component %d(%s) does not exist\",\n            path, pathIndex, pathComponents[pathIndex]));\n      }\n    }\n    // The ancestor inode (parent or ancestor) of the target path.\n    Inode ancestorInode = inodePath.getAncestorInode();\n    if (!ancestorInode.isDirectory()) {\n      throw new InvalidPathException(\"Could not traverse to parent directory of path \" + path\n          + \". Component \" + pathComponents[pathIndex - 1] + \" is not a directory.\");\n    }\n    InodeDirectoryView currentInodeDirectory = ancestorInode.asDirectory();\n\n    List<Inode> createdInodes = new ArrayList<>();\n    if (context.isPersisted()) {\n      // Synchronously persist directories. These inodes are already READ locked.\n      for (Inode inode : inodePath.getInodeList()) {\n        if (!inode.isPersisted()) {\n          // This cast is safe because we've already verified that the file inode doesn't exist.\n          syncPersistExistingDirectory(rpcContext, inode.asDirectory());\n        }\n      }\n    }\n    if ((pathIndex < (pathComponents.length - 1)\n        || !mInodeStore.getChild(currentInodeDirectory, name).isPresent())\n        && context.getOperationTimeMs() > currentInodeDirectory.getLastModificationTimeMs()) {\n      // (1) There are components in parent paths that need to be created. Or\n      // (2) The last component of the path needs to be created.\n      // In these two cases, the last traversed Inode will be modified if the new timestamp is after\n      // the existing last modified time.\n      long currentId = currentInodeDirectory.getId();\n      try (LockResource lr = mInodeLockManager.lockUpdate(currentId)) {\n        long updatedLastModified = mInodeStore.get(currentId).get().getLastModificationTimeMs();\n        if (updatedLastModified < context.getOperationTimeMs()) {\n          UpdateInodeEntry.Builder updateInodeEntry = UpdateInodeEntry.newBuilder()\n              .setId(currentId)\n              .setLastModificationTimeMs(context.getOperationTimeMs())\n              .setLastAccessTimeMs(context.getOperationTimeMs());\n          if (context.getXAttr() != null) {\n            updateInodeEntry.putAllXAttr(CommonUtils.convertToByteString(context.getXAttr()));\n          }\n          mState.applyAndJournal(rpcContext, updateInodeEntry.build());\n        }\n      }\n    }\n\n    // Fill in the ancestor directories that were missing.\n    // NOTE, we set the mode of missing ancestor directories to be the default value, rather\n    // than inheriting the option of the final file to create, because it may not have\n    // \"execute\" permission.\n    CreateDirectoryContext missingDirContext = CreateDirectoryContext.defaults();\n    missingDirContext.getOptions().setCommonOptions(FileSystemMasterCommonPOptions.newBuilder()\n        .setTtl(context.getTtl()).setTtlAction(context.getTtlAction()));\n    missingDirContext.setWriteType(context.getWriteType());\n    missingDirContext.setOperationTimeMs(context.getOperationTimeMs());\n    missingDirContext.setMountPoint(false);\n    missingDirContext.setOwner(context.getOwner());\n    missingDirContext.setGroup(context.getGroup());\n    missingDirContext.setXAttr(context.getXAttr());\n    StringBuilder pathBuilder = new StringBuilder().append(\n        String.join(AlluxioURI.SEPARATOR, Arrays.asList(pathComponents).subList(0, pathIndex))\n    );\n    for (int k = pathIndex; k < (pathComponents.length - 1); k++) {\n      MutableInodeDirectory newDir = MutableInodeDirectory.create(\n          mDirectoryIdGenerator.getNewDirectoryId(rpcContext.getJournalContext()),\n          currentInodeDirectory.getId(), pathComponents[k], missingDirContext);\n\n      newDir.setPinned(currentInodeDirectory.isPinned());\n\n      inheritOwnerAndGroupIfEmpty(newDir, currentInodeDirectory);\n\n      // if the parent has default ACL, copy that default ACL as the new directory's default\n      // and access acl, ANDed with the umask\n      // if it is part of a metadata load operation, we ignore the umask and simply inherit\n      // the default ACL as the directory's new default and access ACL\n      short mode = context.isMetadataLoad() ? Mode.createFullAccess().toShort()\n          : newDir.getMode();\n      DefaultAccessControlList dAcl = currentInodeDirectory.getDefaultACL();\n      if (!dAcl.isEmpty()) {\n        Pair<AccessControlList, DefaultAccessControlList> pair =\n            dAcl.generateChildDirACL(mode);\n        newDir.setInternalAcl(pair.getFirst());\n        newDir.setDefaultACL(pair.getSecond());\n      }\n      String newDirPath = k == 0 ? ROOT_PATH\n          : pathBuilder.append(AlluxioURI.SEPARATOR).append(pathComponents[k]).toString();\n      mState.applyAndJournal(rpcContext, newDir,\n          newDirPath);\n\n      inodePath.addNextInode(Inode.wrap(newDir));\n\n      // Persist the directory *after* it exists in the inode tree. This prevents multiple\n      // concurrent creates from trying to persist the same directory name.\n      if (context.isPersisted()) {\n        syncPersistExistingDirectory(rpcContext, newDir);\n      }\n      createdInodes.add(Inode.wrap(newDir));\n      currentInodeDirectory = newDir;\n    }\n\n    // Create the final path component.\n    MutableInode<?> newInode;\n    // create the new inode, with a write lock\n    if (context instanceof CreateDirectoryContext) {\n      CreateDirectoryContext directoryContext = (CreateDirectoryContext) context;\n      MutableInodeDirectory newDir = MutableInodeDirectory.create(\n          mDirectoryIdGenerator.getNewDirectoryId(rpcContext.getJournalContext()),\n          currentInodeDirectory.getId(), name, directoryContext);\n\n      // if the parent has default ACL, take the default ACL ANDed with the umask as the new\n      // directory's default and access acl\n      // When it is a metadata load operation, do not take the umask into account\n      short mode = context.isMetadataLoad() ? Mode.createFullAccess().toShort()\n          : newDir.getMode();\n      DefaultAccessControlList dAcl = currentInodeDirectory.getDefaultACL();\n      if (!dAcl.isEmpty()) {\n        Pair<AccessControlList, DefaultAccessControlList> pair =\n            dAcl.generateChildDirACL(mode);\n        newDir.setInternalAcl(pair.getFirst());\n        newDir.setDefaultACL(pair.getSecond());\n      }\n\n      if (directoryContext.isPersisted()) {\n        // Do not journal the persist entry, since a creation entry will be journaled instead.\n        if (context.isMetadataLoad()) {\n          // if we are creating the file as a result of loading metadata, the newDir is already\n          // persisted, and we got the permissions info from the ufs.\n          newDir.setOwner(context.getOwner())\n              .setGroup(context.getGroup())\n              .setMode(context.getMode().toShort());\n\n          Long operationTimeMs = context.getOperationTimeMs();\n          if (operationTimeMs != null) {\n            newDir.setLastModificationTimeMs(operationTimeMs, true);\n            newDir.setLastAccessTimeMs(operationTimeMs, true);\n          }\n          newDir.setPersistenceState(PersistenceState.PERSISTED);\n        } else {\n          syncPersistNewDirectory(newDir);\n        }\n      }\n      // Do NOT call setOwner/Group after inheriting from parent if empty\n      inheritOwnerAndGroupIfEmpty(newDir, currentInodeDirectory);\n      newInode = newDir;\n    } else if (context instanceof CreateFileContext) {\n      CreateFileContext fileContext = (CreateFileContext) context;\n      MutableInodeFile newFile = MutableInodeFile.create(mContainerIdGenerator.getNewContainerId(),\n          currentInodeDirectory.getId(), name, System.currentTimeMillis(), fileContext);\n\n      // if the parent has a default ACL, copy that default ACL ANDed with the umask as the new\n      // file's access ACL.\n      // If it is a metadata load operation, do not consider the umask.\n      DefaultAccessControlList dAcl = currentInodeDirectory.getDefaultACL();\n      short mode = context.isMetadataLoad() ? Mode.createFullAccess().toShort() : newFile.getMode();\n      if (!dAcl.isEmpty()) {\n        AccessControlList acl = dAcl.generateChildFileACL(mode);\n        newFile.setInternalAcl(acl);\n      }\n      if (fileContext.isCacheable()) {\n        newFile.setCacheable(true);\n      }\n      if (fileContext.getWriteType() == WriteType.ASYNC_THROUGH) {\n        newFile.setPersistenceState(PersistenceState.TO_BE_PERSISTED);\n      }\n\n      // Do NOT call setOwner/Group after inheriting from parent if empty\n      inheritOwnerAndGroupIfEmpty(newFile, currentInodeDirectory);\n      newInode = newFile;\n    } else {\n      throw new IllegalStateException(String.format(\"Unrecognized create options: %s\", context));\n    }\n    newInode.setPinned(currentInodeDirectory.isPinned());\n\n    mState.applyAndJournal(rpcContext, newInode,\n        inodePath.getUri().getPath());\n    Inode inode = Inode.wrap(newInode);\n    inodePath.addNextInode(inode);\n    createdInodes.add(inode);\n    LOG.debug(\"createFile: File Created: {} parent: {}\", newInode, currentInodeDirectory);\n    return createdInodes;\n  }", "signature": "List<Inode> createPath(RpcContext rpcContext, LockedInodePath inodePath,\n      CreatePathContext<?, ?> context)", "full_signature": "public List<Inode> createPath(RpcContext rpcContext, LockedInodePath inodePath,\n      CreatePathContext<?, ?> context)", "class_method_signature": "InodeTree.createPath(RpcContext rpcContext, LockedInodePath inodePath,\n      CreatePathContext<?, ?> context)", "testcase": false, "constructor": false, "invocations": ["checkState", "getLockPattern", "getUri", "isRoot", "error", "fullPathExists", "getAllowExists", "getOptions", "emptyList", "format", "getBlockSizeBytes", "getOptions", "getBlockSizeBytes", "getOptions", "debug", "getName", "getExistingInodeCount", "isRecursive", "format", "getAncestorInode", "isDirectory", "asDirectory", "isPersisted", "getInodeList", "isPersisted", "syncPersistExistingDirectory", "asDirectory", "isPresent", "getChild", "getOperationTimeMs", "getLastModificationTimeMs", "getId", "lockUpdate", "getLastModificationTimeMs", "get", "get", "getOperationTimeMs", "setLastAccessTimeMs", "setLastModificationTimeMs", "setId", "newBuilder", "getOperationTimeMs", "getOperationTimeMs", "getXAttr", "putAllXAttr", "convertToByteString", "getXAttr", "applyAndJournal", "build", "defaults", "setCommonOptions", "getOptions", "setTtlAction", "setTtl", "newBuilder", "getTtl", "getTtlAction", "setWriteType", "getWriteType", "setOperationTimeMs", "getOperationTimeMs", "setMountPoint", "setOwner", "getOwner", "setGroup", "getGroup", "setXAttr", "getXAttr", "append", "join", "subList", "asList", "create", "getNewDirectoryId", "getJournalContext", "getId", "setPinned", "isPinned", "inheritOwnerAndGroupIfEmpty", "isMetadataLoad", "toShort", "createFullAccess", "getMode", "getDefaultACL", "isEmpty", "generateChildDirACL", "setInternalAcl", "getFirst", "setDefaultACL", "getSecond", "toString", "append", "append", "applyAndJournal", "addNextInode", "wrap", "isPersisted", "syncPersistExistingDirectory", "add", "wrap", "create", "getNewDirectoryId", "getJournalContext", "getId", "isMetadataLoad", "toShort", "createFullAccess", "getMode", "getDefaultACL", "isEmpty", "generateChildDirACL", "setInternalAcl", "getFirst", "setDefaultACL", "getSecond", "isPersisted", "isMetadataLoad", "setMode", "setGroup", "setOwner", "getOwner", "getGroup", "toShort", "getMode", "getOperationTimeMs", "setLastModificationTimeMs", "setLastAccessTimeMs", "setPersistenceState", "syncPersistNewDirectory", "inheritOwnerAndGroupIfEmpty", "create", "getNewContainerId", "getId", "currentTimeMillis", "getDefaultACL", "isMetadataLoad", "toShort", "createFullAccess", "getMode", "isEmpty", "generateChildFileACL", "setInternalAcl", "isCacheable", "setCacheable", "getWriteType", "setPersistenceState", "inheritOwnerAndGroupIfEmpty", "format", "setPinned", "isPinned", "applyAndJournal", "getPath", "getUri", "wrap", "addNextInode", "add", "debug"]}, "repository": {"repo_id": 7276954, "url": "https://github.com/Alluxio/alluxio", "stars": 4494, "created": "12/21/2012 5:43:46 PM +00:00", "updates": "2020-01-24T20:27:46+00:00", "fork": "False", "license": "licensed"}}