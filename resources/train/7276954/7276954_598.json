{"test_class": {"identifier": "BlockLockManagerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final long TEST_SESSION_ID = 2;", "modifier": "private static final", "type": "long", "declarator": "TEST_SESSION_ID = 2", "var_name": "TEST_SESSION_ID"}, {"original_string": "private static final long TEST_BLOCK_ID = 9;", "modifier": "private static final", "type": "long", "declarator": "TEST_BLOCK_ID = 9", "var_name": "TEST_BLOCK_ID"}, {"original_string": "private BlockLockManager mLockManager;", "modifier": "private", "type": "BlockLockManager", "declarator": "mLockManager", "var_name": "mLockManager"}, {"original_string": "@Rule\n  public TemporaryFolder mFolder = new TemporaryFolder();", "modifier": "@Rule\n  public", "type": "TemporaryFolder", "declarator": "mFolder = new TemporaryFolder()", "var_name": "mFolder"}, {"original_string": "@Rule\n  public ExpectedException mThrown = ExpectedException.none();", "modifier": "@Rule\n  public", "type": "ExpectedException", "declarator": "mThrown = ExpectedException.none()", "var_name": "mThrown"}], "file": "core/server/worker/src/test/java/alluxio/worker/block/BlockLockManagerTest.java"}, "test_case": {"identifier": "grabManyLocks", "parameters": "()", "modifiers": "@Test(timeout = 10000) public", "return": "void", "body": "@Test(timeout = 10000)\n  public void grabManyLocks() throws Exception {\n    int maxLocks = 100;\n    setMaxLocks(maxLocks);\n    BlockLockManager manager = new BlockLockManager();\n    for (int i = 0; i < maxLocks; i++) {\n      manager.lockBlock(i, i, BlockLockType.WRITE);\n    }\n    lockExpectingHang(manager, 101);\n  }", "signature": "void grabManyLocks()", "full_signature": "@Test(timeout = 10000) public void grabManyLocks()", "class_method_signature": "BlockLockManagerTest.grabManyLocks()", "testcase": true, "constructor": false, "invocations": ["setMaxLocks", "lockBlock", "lockExpectingHang"]}, "focal_class": {"identifier": "BlockLockManager", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(BlockLockManager.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(BlockLockManager.class)", "var_name": "LOG"}, {"original_string": "public static final long INVALID_LOCK_ID = -1;", "modifier": "public static final", "type": "long", "declarator": "INVALID_LOCK_ID = -1", "var_name": "INVALID_LOCK_ID"}, {"original_string": "private static final AtomicLong LOCK_ID_GEN = new AtomicLong(0);", "modifier": "private static final", "type": "AtomicLong", "declarator": "LOCK_ID_GEN = new AtomicLong(0)", "var_name": "LOCK_ID_GEN"}, {"original_string": "private final ResourcePool<ClientRWLock> mLockPool = new ResourcePool<ClientRWLock>(\n      ServerConfiguration.getInt(PropertyKey.WORKER_TIERED_STORE_BLOCK_LOCKS)) {\n    @Override\n    public void close() {}\n\n    @Override\n    protected ClientRWLock createNewResource() {\n      return new ClientRWLock();\n    }\n  };", "modifier": "private final", "type": "ResourcePool<ClientRWLock>", "declarator": "mLockPool = new ResourcePool<ClientRWLock>(\n      ServerConfiguration.getInt(PropertyKey.WORKER_TIERED_STORE_BLOCK_LOCKS)) {\n    @Override\n    public void close() {}\n\n    @Override\n    protected ClientRWLock createNewResource() {\n      return new ClientRWLock();\n    }\n  }", "var_name": "mLockPool"}, {"original_string": "@GuardedBy(\"mSharedMapsLock\")\n  private final Map<Long, ClientRWLock> mLocks = new HashMap<>();", "modifier": "@GuardedBy(\"mSharedMapsLock\")\n  private final", "type": "Map<Long, ClientRWLock>", "declarator": "mLocks = new HashMap<>()", "var_name": "mLocks"}, {"original_string": "@GuardedBy(\"mSharedMapsLock\")\n  private final Map<Long, Set<Long>> mSessionIdToLockIdsMap = new HashMap<>();", "modifier": "@GuardedBy(\"mSharedMapsLock\")\n  private final", "type": "Map<Long, Set<Long>>", "declarator": "mSessionIdToLockIdsMap = new HashMap<>()", "var_name": "mSessionIdToLockIdsMap"}, {"original_string": "@GuardedBy(\"mSharedMapsLock\")\n  private final Map<Long, LockRecord> mLockIdToRecordMap = new HashMap<>();", "modifier": "@GuardedBy(\"mSharedMapsLock\")\n  private final", "type": "Map<Long, LockRecord>", "declarator": "mLockIdToRecordMap = new HashMap<>()", "var_name": "mLockIdToRecordMap"}, {"original_string": "private final ReentrantReadWriteLock mSharedMapsLock = new ReentrantReadWriteLock();", "modifier": "private final", "type": "ReentrantReadWriteLock", "declarator": "mSharedMapsLock = new ReentrantReadWriteLock()", "var_name": "mSharedMapsLock"}], "methods": [{"identifier": "BlockLockManager", "parameters": "()", "modifiers": "public", "return": "", "signature": " BlockLockManager()", "full_signature": "public  BlockLockManager()", "class_method_signature": "BlockLockManager.BlockLockManager()", "testcase": false, "constructor": true}, {"identifier": "lockBlock", "parameters": "(long sessionId, long blockId, BlockLockType blockLockType)", "modifiers": "public", "return": "long", "signature": "long lockBlock(long sessionId, long blockId, BlockLockType blockLockType)", "full_signature": "public long lockBlock(long sessionId, long blockId, BlockLockType blockLockType)", "class_method_signature": "BlockLockManager.lockBlock(long sessionId, long blockId, BlockLockType blockLockType)", "testcase": false, "constructor": false}, {"identifier": "sessionHoldsLock", "parameters": "(long sessionId, long blockId)", "modifiers": "private", "return": "boolean", "signature": "boolean sessionHoldsLock(long sessionId, long blockId)", "full_signature": "private boolean sessionHoldsLock(long sessionId, long blockId)", "class_method_signature": "BlockLockManager.sessionHoldsLock(long sessionId, long blockId)", "testcase": false, "constructor": false}, {"identifier": "getBlockLock", "parameters": "(long blockId)", "modifiers": "private", "return": "ClientRWLock", "signature": "ClientRWLock getBlockLock(long blockId)", "full_signature": "private ClientRWLock getBlockLock(long blockId)", "class_method_signature": "BlockLockManager.getBlockLock(long blockId)", "testcase": false, "constructor": false}, {"identifier": "unlockBlockNoException", "parameters": "(long lockId)", "modifiers": "public", "return": "boolean", "signature": "boolean unlockBlockNoException(long lockId)", "full_signature": "public boolean unlockBlockNoException(long lockId)", "class_method_signature": "BlockLockManager.unlockBlockNoException(long lockId)", "testcase": false, "constructor": false}, {"identifier": "unlockBlock", "parameters": "(long lockId)", "modifiers": "public", "return": "void", "signature": "void unlockBlock(long lockId)", "full_signature": "public void unlockBlock(long lockId)", "class_method_signature": "BlockLockManager.unlockBlock(long lockId)", "testcase": false, "constructor": false}, {"identifier": "unlockBlock", "parameters": "(long sessionId, long blockId)", "modifiers": "public", "return": "boolean", "signature": "boolean unlockBlock(long sessionId, long blockId)", "full_signature": "public boolean unlockBlock(long sessionId, long blockId)", "class_method_signature": "BlockLockManager.unlockBlock(long sessionId, long blockId)", "testcase": false, "constructor": false}, {"identifier": "validateLock", "parameters": "(long sessionId, long blockId, long lockId)", "modifiers": "public", "return": "void", "signature": "void validateLock(long sessionId, long blockId, long lockId)", "full_signature": "public void validateLock(long sessionId, long blockId, long lockId)", "class_method_signature": "BlockLockManager.validateLock(long sessionId, long blockId, long lockId)", "testcase": false, "constructor": false}, {"identifier": "cleanupSession", "parameters": "(long sessionId)", "modifiers": "public", "return": "void", "signature": "void cleanupSession(long sessionId)", "full_signature": "public void cleanupSession(long sessionId)", "class_method_signature": "BlockLockManager.cleanupSession(long sessionId)", "testcase": false, "constructor": false}, {"identifier": "getLockedBlocks", "parameters": "()", "modifiers": "public", "return": "Set<Long>", "signature": "Set<Long> getLockedBlocks()", "full_signature": "public Set<Long> getLockedBlocks()", "class_method_signature": "BlockLockManager.getLockedBlocks()", "testcase": false, "constructor": false}, {"identifier": "unlock", "parameters": "(Lock lock, long blockId)", "modifiers": "private", "return": "void", "signature": "void unlock(Lock lock, long blockId)", "full_signature": "private void unlock(Lock lock, long blockId)", "class_method_signature": "BlockLockManager.unlock(Lock lock, long blockId)", "testcase": false, "constructor": false}, {"identifier": "releaseBlockLockIfUnused", "parameters": "(long blockId)", "modifiers": "private", "return": "void", "signature": "void releaseBlockLockIfUnused(long blockId)", "full_signature": "private void releaseBlockLockIfUnused(long blockId)", "class_method_signature": "BlockLockManager.releaseBlockLockIfUnused(long blockId)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void validate()", "full_signature": "public void validate()", "class_method_signature": "BlockLockManager.validate()", "testcase": false, "constructor": false}], "file": "core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java"}, "focal_method": {"identifier": "lockBlock", "parameters": "(long sessionId, long blockId, BlockLockType blockLockType)", "modifiers": "public", "return": "long", "body": "public long lockBlock(long sessionId, long blockId, BlockLockType blockLockType) {\n    ClientRWLock blockLock = getBlockLock(blockId);\n    Lock lock;\n    if (blockLockType == BlockLockType.READ) {\n      lock = blockLock.readLock();\n    } else {\n      // Make sure the session isn't already holding the block lock.\n      if (sessionHoldsLock(sessionId, blockId)) {\n        throw new IllegalStateException(String\n            .format(\"Session %s attempted to take a write lock on block %s, but the session already\"\n                + \" holds a lock on the block\", sessionId, blockId));\n      }\n      lock = blockLock.writeLock();\n    }\n    lock.lock();\n    try {\n      long lockId = LOCK_ID_GEN.getAndIncrement();\n      try (LockResource r = new LockResource(mSharedMapsLock.writeLock())) {\n        mLockIdToRecordMap.put(lockId, new LockRecord(sessionId, blockId, lock));\n        Set<Long> sessionLockIds = mSessionIdToLockIdsMap.get(sessionId);\n        if (sessionLockIds == null) {\n          mSessionIdToLockIdsMap.put(sessionId, Sets.newHashSet(lockId));\n        } else {\n          sessionLockIds.add(lockId);\n        }\n      }\n      return lockId;\n    } catch (RuntimeException e) {\n      // If an unexpected exception occurs, we should release the lock to be conservative.\n      unlock(lock, blockId);\n      throw e;\n    }\n  }", "signature": "long lockBlock(long sessionId, long blockId, BlockLockType blockLockType)", "full_signature": "public long lockBlock(long sessionId, long blockId, BlockLockType blockLockType)", "class_method_signature": "BlockLockManager.lockBlock(long sessionId, long blockId, BlockLockType blockLockType)", "testcase": false, "constructor": false, "invocations": ["getBlockLock", "readLock", "sessionHoldsLock", "format", "writeLock", "lock", "getAndIncrement", "writeLock", "put", "get", "put", "newHashSet", "add", "unlock"]}, "repository": {"repo_id": 7276954, "url": "https://github.com/Alluxio/alluxio", "stars": 4494, "created": "12/21/2012 5:43:46 PM +00:00", "updates": "2020-01-24T20:27:46+00:00", "fork": "False", "license": "licensed"}}