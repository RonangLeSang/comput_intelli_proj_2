{"test_class": {"identifier": "RangeFilterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double DELTA_04 = 1e-04;", "modifier": "private static final", "type": "double", "declarator": "DELTA_04 = 1e-04", "var_name": "DELTA_04"}, {"original_string": "private static final double DELTA_03 = 1e-03;", "modifier": "private static final", "type": "double", "declarator": "DELTA_03 = 1e-03", "var_name": "DELTA_03"}, {"original_string": "private static final String testDirectory = \"/d2/etna_test/rangeFilterTest/\";", "modifier": "private static final", "type": "String", "declarator": "testDirectory = \"/d2/etna_test/rangeFilterTest/\"", "var_name": "testDirectory"}, {"original_string": "private static int nRows = 128;", "modifier": "private static", "type": "int", "declarator": "nRows = 128", "var_name": "nRows"}, {"original_string": "private static int nCols = 128;", "modifier": "private static", "type": "int", "declarator": "nCols = 128", "var_name": "nCols"}, {"original_string": "private static ComplexDoubleMatrix masterCplx;", "modifier": "private static", "type": "ComplexDoubleMatrix", "declarator": "masterCplx", "var_name": "masterCplx"}, {"original_string": "private static ComplexDoubleMatrix slaveCplx;", "modifier": "private static", "type": "ComplexDoubleMatrix", "declarator": "slaveCplx", "var_name": "slaveCplx"}, {"original_string": "private static ComplexDoubleMatrix masterCplx_ACTUAL;", "modifier": "private static", "type": "ComplexDoubleMatrix", "declarator": "masterCplx_ACTUAL", "var_name": "masterCplx_ACTUAL"}, {"original_string": "private static ComplexDoubleMatrix slaveCplx_ACTUAL;", "modifier": "private static", "type": "ComplexDoubleMatrix", "declarator": "slaveCplx_ACTUAL", "var_name": "slaveCplx_ACTUAL"}, {"original_string": "final static int nlMean = 15;", "modifier": "final static", "type": "int", "declarator": "nlMean = 15", "var_name": "nlMean"}, {"original_string": "final static int SNRThreshold = 5;", "modifier": "final static", "type": "int", "declarator": "SNRThreshold = 5", "var_name": "SNRThreshold"}, {"original_string": "final static double RSR = 18962500.774137583;", "modifier": "final static", "type": "double", "declarator": "RSR = 18962500.774137583", "var_name": "RSR"}, {"original_string": "final static int RBW = 15550000;", "modifier": "final static", "type": "int", "declarator": "RBW = 15550000", "var_name": "RBW"}], "file": "jdoris-core/src/test/java/org/jdoris/core/filtering/RangeFilterTest.java"}, "test_case": {"identifier": "filterBlock_HAMM_OVSMP_WEIGHT", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void filterBlock_HAMM_OVSMP_WEIGHT() throws Exception {\n\n        /// define parameters parameters\n        final double alphaHamming = 0.75;\n        final int ovsFactor = 2;\n        final boolean doWeightCorrelFlag = true;\n\n        masterCplx_ACTUAL = masterCplx.dup();\n        slaveCplx_ACTUAL = slaveCplx.dup();\n\n        /// load Expected Data\n        String fileMasterDataNameFiltered = \"slc_image_filtered_hamm_2_ON.cr4.swap\";\n        ComplexDoubleMatrix masterCplx_rngFilter_EXPECTED = loadExpectedData(fileMasterDataNameFiltered);\n\n        String fileSlaveDataNameFiltered = \"slc_image1_filtered_hamm_2_ON.cr4.swap\";\n        ComplexDoubleMatrix slaveCplx_rngFilter_EXPECTED = loadExpectedData(fileSlaveDataNameFiltered);\n\n        /// range filter data block\n        RangeFilter.filterBlock(masterCplx_ACTUAL, slaveCplx_ACTUAL, nlMean, SNRThreshold, RSR, RBW, alphaHamming, ovsFactor, doWeightCorrelFlag);\n\n        assertFilterBlock(masterCplx_rngFilter_EXPECTED, slaveCplx_rngFilter_EXPECTED);\n    }", "signature": "void filterBlock_HAMM_OVSMP_WEIGHT()", "full_signature": "@Test public void filterBlock_HAMM_OVSMP_WEIGHT()", "class_method_signature": "RangeFilterTest.filterBlock_HAMM_OVSMP_WEIGHT()", "testcase": true, "constructor": false, "invocations": ["dup", "dup", "loadExpectedData", "loadExpectedData", "filterBlock", "assertFilterBlock"]}, "focal_class": {"identifier": "RangeFilter", "superclass": "extends ProductDataFilter", "interfaces": "", "fields": [{"original_string": "static Logger logger = Logger.getLogger(RangeFilter.class.getName());", "modifier": "static", "type": "Logger", "declarator": "logger = Logger.getLogger(RangeFilter.class.getName())", "var_name": "logger"}, {"original_string": "todo_classes.inputgeneral generalInput;", "modifier": "", "type": "todo_classes.inputgeneral", "declarator": "generalInput", "var_name": "generalInput"}, {"original_string": "todo_classes.input_filtrange filtRangeInput;", "modifier": "", "type": "todo_classes.input_filtrange", "declarator": "filtRangeInput", "var_name": "filtRangeInput"}, {"original_string": "private DoubleMatrix power;", "modifier": "private", "type": "DoubleMatrix", "declarator": "power", "var_name": "power"}, {"original_string": "private int fftLength;", "modifier": "private", "type": "int", "declarator": "fftLength", "var_name": "fftLength"}, {"original_string": "private long nRows;", "modifier": "private", "type": "long", "declarator": "nRows", "var_name": "nRows"}, {"original_string": "private long nCols;", "modifier": "private", "type": "long", "declarator": "nCols", "var_name": "nCols"}, {"original_string": "private double RSR;", "modifier": "private", "type": "double", "declarator": "RSR", "var_name": "RSR"}, {"original_string": "private double RBW;", "modifier": "private", "type": "double", "declarator": "RBW", "var_name": "RBW"}, {"original_string": "private int nlMean = 15;", "modifier": "private", "type": "int", "declarator": "nlMean = 15", "var_name": "nlMean"}, {"original_string": "private double SNRthreshold = 5;", "modifier": "private", "type": "double", "declarator": "SNRthreshold = 5", "var_name": "SNRthreshold"}, {"original_string": "private double alphaHamming = 0.75;", "modifier": "private", "type": "double", "declarator": "alphaHamming = 0.75", "var_name": "alphaHamming"}, {"original_string": "private int ovsFactor = 1;", "modifier": "private", "type": "int", "declarator": "ovsFactor = 1", "var_name": "ovsFactor"}, {"original_string": "private boolean doHamming = false;", "modifier": "private", "type": "boolean", "declarator": "doHamming = false", "var_name": "doHamming"}, {"original_string": "private boolean doOversampleFlag = false;", "modifier": "private", "type": "boolean", "declarator": "doOversampleFlag = false", "var_name": "doOversampleFlag"}, {"original_string": "private boolean doWeightCorrelFlag = false;", "modifier": "private", "type": "boolean", "declarator": "doWeightCorrelFlag = false", "var_name": "doWeightCorrelFlag"}], "methods": [{"identifier": "RangeFilter", "parameters": "()", "modifiers": "public", "return": "", "signature": " RangeFilter()", "full_signature": "public  RangeFilter()", "class_method_signature": "RangeFilter.RangeFilter()", "testcase": false, "constructor": true}, {"identifier": "RangeFilter", "parameters": "(SLCImage master, SLCImage slave, ComplexDoubleMatrix data, ComplexDoubleMatrix data1)", "modifiers": "public", "return": "", "signature": " RangeFilter(SLCImage master, SLCImage slave, ComplexDoubleMatrix data, ComplexDoubleMatrix data1)", "full_signature": "public  RangeFilter(SLCImage master, SLCImage slave, ComplexDoubleMatrix data, ComplexDoubleMatrix data1)", "class_method_signature": "RangeFilter.RangeFilter(SLCImage master, SLCImage slave, ComplexDoubleMatrix data, ComplexDoubleMatrix data1)", "testcase": false, "constructor": true}, {"identifier": "setAlphaHamming", "parameters": "(double alphaHamming)", "modifiers": "public", "return": "void", "signature": "void setAlphaHamming(double alphaHamming)", "full_signature": "public void setAlphaHamming(double alphaHamming)", "class_method_signature": "RangeFilter.setAlphaHamming(double alphaHamming)", "testcase": false, "constructor": false}, {"identifier": "setOvsFactor", "parameters": "(int ovsFactor)", "modifiers": "public", "return": "void", "signature": "void setOvsFactor(int ovsFactor)", "full_signature": "public void setOvsFactor(int ovsFactor)", "class_method_signature": "RangeFilter.setOvsFactor(int ovsFactor)", "testcase": false, "constructor": false}, {"identifier": "setDoWeightCorrelFlag", "parameters": "(boolean doWeightCorrelFlag)", "modifiers": "public", "return": "void", "signature": "void setDoWeightCorrelFlag(boolean doWeightCorrelFlag)", "full_signature": "public void setDoWeightCorrelFlag(boolean doWeightCorrelFlag)", "class_method_signature": "RangeFilter.setDoWeightCorrelFlag(boolean doWeightCorrelFlag)", "testcase": false, "constructor": false}, {"identifier": "setFftLength", "parameters": "(int fftLength)", "modifiers": "public", "return": "void", "signature": "void setFftLength(int fftLength)", "full_signature": "public void setFftLength(int fftLength)", "class_method_signature": "RangeFilter.setFftLength(int fftLength)", "testcase": false, "constructor": false}, {"identifier": "setNlMean", "parameters": "(int nlMean)", "modifiers": "public", "return": "void", "signature": "void setNlMean(int nlMean)", "full_signature": "public void setNlMean(int nlMean)", "class_method_signature": "RangeFilter.setNlMean(int nlMean)", "testcase": false, "constructor": false}, {"identifier": "setSNRthreshold", "parameters": "(double SNRthreshold)", "modifiers": "public", "return": "void", "signature": "void setSNRthreshold(double SNRthreshold)", "full_signature": "public void setSNRthreshold(double SNRthreshold)", "class_method_signature": "RangeFilter.setSNRthreshold(double SNRthreshold)", "testcase": false, "constructor": false}, {"identifier": "defineParameters", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void defineParameters()", "full_signature": "public void defineParameters()", "class_method_signature": "RangeFilter.defineParameters()", "testcase": false, "constructor": false}, {"identifier": "defineFilter", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void defineFilter()", "full_signature": "@Override public void defineFilter()", "class_method_signature": "RangeFilter.defineFilter()", "testcase": false, "constructor": false}, {"identifier": "defineFilterVector", "parameters": "(double deltaF, DoubleMatrix freqAxis, DoubleMatrix inverseHamming, long shift)", "modifiers": "private", "return": "DoubleMatrix", "signature": "DoubleMatrix defineFilterVector(double deltaF, DoubleMatrix freqAxis, DoubleMatrix inverseHamming, long shift)", "full_signature": "private DoubleMatrix defineFilterVector(double deltaF, DoubleMatrix freqAxis, DoubleMatrix inverseHamming, long shift)", "class_method_signature": "RangeFilter.defineFilterVector(double deltaF, DoubleMatrix freqAxis, DoubleMatrix inverseHamming, long shift)", "testcase": false, "constructor": false}, {"identifier": "applyFilter", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void applyFilter()", "full_signature": "@Override public void applyFilter()", "class_method_signature": "RangeFilter.applyFilter()", "testcase": false, "constructor": false}, {"identifier": "applyFilterMaster", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void applyFilterMaster()", "full_signature": "public void applyFilterMaster()", "class_method_signature": "RangeFilter.applyFilterMaster()", "testcase": false, "constructor": false}, {"identifier": "applyFilterSlave", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void applyFilterSlave()", "full_signature": "public void applyFilterSlave()", "class_method_signature": "RangeFilter.applyFilterSlave()", "testcase": false, "constructor": false}, {"identifier": "sanityChecks", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void sanityChecks()", "full_signature": "private void sanityChecks()", "class_method_signature": "RangeFilter.sanityChecks()", "testcase": false, "constructor": false}, {"identifier": "computePowerMatrix", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void computePowerMatrix()", "full_signature": "private void computePowerMatrix()", "class_method_signature": "RangeFilter.computePowerMatrix()", "testcase": false, "constructor": false}, {"identifier": "computeNlMeanPower", "parameters": "(final long nlMean, final long fftLength, DoubleMatrix power)", "modifiers": "private static", "return": "DoubleMatrix", "signature": "DoubleMatrix computeNlMeanPower(final long nlMean, final long fftLength, DoubleMatrix power)", "full_signature": "private static DoubleMatrix computeNlMeanPower(final long nlMean, final long fftLength, DoubleMatrix power)", "class_method_signature": "RangeFilter.computeNlMeanPower(final long nlMean, final long fftLength, DoubleMatrix power)", "testcase": false, "constructor": false}, {"identifier": "doWeightCorrel", "parameters": "(final double RSR, final double RBW,  final long fftLength, DoubleMatrix data)", "modifiers": "private static", "return": "void", "signature": "void doWeightCorrel(final double RSR, final double RBW,  final long fftLength, DoubleMatrix data)", "full_signature": "private static void doWeightCorrel(final double RSR, final double RBW,  final long fftLength, DoubleMatrix data)", "class_method_signature": "RangeFilter.doWeightCorrel(final double RSR, final double RBW,  final long fftLength, DoubleMatrix data)", "testcase": false, "constructor": false}, {"identifier": "doWeightCorrel", "parameters": "(final double RSR, final double RBW, final long numLines, final long numPixels, final long fftLength, DoubleMatrix data)", "modifiers": "private static", "return": "void", "signature": "void doWeightCorrel(final double RSR, final double RBW, final long numLines, final long numPixels, final long fftLength, DoubleMatrix data)", "full_signature": "private static void doWeightCorrel(final double RSR, final double RBW, final long numLines, final long numPixels, final long fftLength, DoubleMatrix data)", "class_method_signature": "RangeFilter.doWeightCorrel(final double RSR, final double RBW, final long numLines, final long numPixels, final long fftLength, DoubleMatrix data)", "testcase": false, "constructor": false}, {"identifier": "defineFrequencyAxis", "parameters": "(final long numPixs, final double RSR)", "modifiers": "private static", "return": "DoubleMatrix", "signature": "DoubleMatrix defineFrequencyAxis(final long numPixs, final double RSR)", "full_signature": "private static DoubleMatrix defineFrequencyAxis(final long numPixs, final double RSR)", "class_method_signature": "RangeFilter.defineFrequencyAxis(final long numPixs, final double RSR)", "testcase": false, "constructor": false}, {"identifier": "efficientFilter", "parameters": "()", "modifiers": "@Deprecated public", "return": "void", "signature": "void efficientFilter()", "full_signature": "@Deprecated public void efficientFilter()", "class_method_signature": "RangeFilter.efficientFilter()", "testcase": false, "constructor": false}, {"identifier": "filterBlock", "parameters": "(ComplexDoubleMatrix masterDataBlock, // updated\n                            ComplexDoubleMatrix slaveDataBlock,  // updated\n                            int nlMean,\n                            double SNRthreshold,\n                            double RSR, // in MHz\n                            double RBW, // in MHz\n                            double alphaHamming,\n                            int ovsFactor,\n                            boolean doWeightCorrelFlag)", "modifiers": "@Deprecated public static", "return": "void", "signature": "void filterBlock(ComplexDoubleMatrix masterDataBlock, // updated\n                            ComplexDoubleMatrix slaveDataBlock,  // updated\n                            int nlMean,\n                            double SNRthreshold,\n                            double RSR, // in MHz\n                            double RBW, // in MHz\n                            double alphaHamming,\n                            int ovsFactor,\n                            boolean doWeightCorrelFlag)", "full_signature": "@Deprecated public static void filterBlock(ComplexDoubleMatrix masterDataBlock, // updated\n                            ComplexDoubleMatrix slaveDataBlock,  // updated\n                            int nlMean,\n                            double SNRthreshold,\n                            double RSR, // in MHz\n                            double RBW, // in MHz\n                            double alphaHamming,\n                            int ovsFactor,\n                            boolean doWeightCorrelFlag)", "class_method_signature": "RangeFilter.filterBlock(ComplexDoubleMatrix masterDataBlock, // updated\n                            ComplexDoubleMatrix slaveDataBlock,  // updated\n                            int nlMean,\n                            double SNRthreshold,\n                            double RSR, // in MHz\n                            double RBW, // in MHz\n                            double alphaHamming,\n                            int ovsFactor,\n                            boolean doWeightCorrelFlag)", "testcase": false, "constructor": false}], "file": "jdoris-core/src/main/java/org/jdoris/core/filtering/RangeFilter.java"}, "focal_method": {"identifier": "filterBlock", "parameters": "(ComplexDoubleMatrix masterDataBlock, // updated\n                            ComplexDoubleMatrix slaveDataBlock,  // updated\n                            int nlMean,\n                            double SNRthreshold,\n                            double RSR, // in MHz\n                            double RBW, // in MHz\n                            double alphaHamming,\n                            int ovsFactor,\n                            boolean doWeightCorrelFlag)", "modifiers": "@Deprecated public static", "return": "void", "body": "@Deprecated\n    public static void filterBlock(ComplexDoubleMatrix masterDataBlock, // updated\n                            ComplexDoubleMatrix slaveDataBlock,  // updated\n                            int nlMean,\n                            double SNRthreshold,\n                            double RSR, // in MHz\n                            double RBW, // in MHz\n                            double alphaHamming,\n                            int ovsFactor,\n                            boolean doWeightCorrelFlag) throws Exception { // returned\n\n\n        double meanSNR;\n        double percentNotFiltered;\n\n        /// define parameters ///\n\n        final long numLines = masterDataBlock.rows;\n        final long numPixs = masterDataBlock.columns;\n        final long outputLines = numLines - nlMean + 1;\n        final long firstLine = ((nlMean - 1) / 2);        // indices in matrix system\n        final long lastLine = firstLine + outputLines - 1;\n        final boolean doHammingFlag = (alphaHamming < 0.9999);\n        // use oversampling before int. gen.\n        final boolean doOversampleFlag = (ovsFactor != 1);\n        int notFiltered = 0; // method counter\n\n        /// sanity check on input paramaters ///\n        if (!MathUtils.isOdd(nlMean)) {\n            logger.error(\"nlMean has to be odd.\");\n            throw new IllegalArgumentException(\"nlMean has to be odd.\");\n        }\n        if (!MathUtils.isPower2(numPixs)) {\n            logger.error(\"numPixels (FFT) has to be power of 2.\");\n            throw new IllegalArgumentException(\"numPixels (FFT) has to be power of 2.\");\n        }\n        if (!MathUtils.isPower2(ovsFactor)) {\n            logger.error(\"oversample factor (FFT) has to be power of 2.\");\n            throw new IllegalArgumentException(\"oversample factor (FFT) has to be power of 2.\");\n        }\n        if (slaveDataBlock.rows != numLines) {\n            logger.error(\"slave not same size as master.\");\n            throw new IllegalArgumentException(\"slave not same size as master.\");\n        }\n        if (slaveDataBlock.columns != numPixs) {\n            logger.error(\"slave not same size as master.\");\n            throw new IllegalArgumentException(\"slave not same size as master.\");\n        }\n        if (outputLines < 1) {\n            logger.warn(\"no outputLines, continuing....\");\n        }\n\n        /// local variables ///\n        DoubleMatrix inverseHamming = null;\n\n        /// shift parameters ////\n        final double deltaF = RSR / numPixs;\n//        final double freq = -RSR / 2.; // defined in defineFrequencyAxis\n\n        DoubleMatrix freqAxis = defineFrequencyAxis(numPixs, RSR);\n\n        if (doHammingFlag) {\n            inverseHamming = WeightWindows.inverseHamming(freqAxis, RBW, RSR, alphaHamming);\n        }\n\n        //// COMPUTE CPLX IFG ON THE FLY -> power ////\n        ComplexDoubleMatrix cplxIfg;\n        if (doOversampleFlag) {\n            cplxIfg = SarUtils.computeIfg(masterDataBlock, slaveDataBlock, 1, ovsFactor);\n        } else {\n            cplxIfg = SarUtils.computeIfg(masterDataBlock, slaveDataBlock);\n        }\n\n        long fftLength = cplxIfg.columns;\n\n        logger.debug(\"is real4 accurate enough? it seems so!\");\n\n        SpectralUtils.fft_inplace(cplxIfg, 2);             // cplxIfg = fft over rows\n        DoubleMatrix power = SarUtils.intensity(cplxIfg);  // power   = cplxIfg.*conj(cplxIfg);\n\n        //// Use weighted correlation due to bias in normal definition\n        // Note: Actually better de-weight with autoconvoluted hamming.\n        if (doWeightCorrelFlag) {\n            doWeightCorrel(RSR, RBW, fftLength, power);\n//            doWeightCorrel(RSR, RBW, numLines, numPixs, fftLength, power);\n        }\n\n        /// Average power to reduce noise : fft.ing in-place over data rows ///\n        SpectralUtils.fft_inplace(masterDataBlock, 2);\n        SpectralUtils.fft_inplace(slaveDataBlock, 2);\n        logger.trace(\"Took FFT over rows of master, slave.\");\n\n        DoubleMatrix nlMeanPower = computeNlMeanPower(nlMean, fftLength, power);\n\n        long shift; // returned by max\n        meanSNR = 0.;\n        double meanShift = 0.;\n\n        // Start actual filtering\n        for (long outLine = firstLine; outLine <= lastLine; ++outLine) {\n\n            double totalPower = nlMeanPower.sum();\n            double maxValue = nlMeanPower.max();\n            shift = nlMeanPower.argmax();\n            long lastShift = shift;\n            double SNR = fftLength * (maxValue / (totalPower - maxValue));\n            meanSNR += SNR;\n\n            //// Check for negative shift\n            boolean negShift = false;\n            if (shift > (int) (fftLength / 2)) {\n                shift = (int) fftLength - shift;\n                lastShift = shift; // use this if current shift not OK.\n                negShift = true;\n            }\n\n            // ______ Do actual filtering ______\n            if (SNR < SNRthreshold) {\n                notFiltered++; // update notFiltered counter\n                shift = lastShift;\n                logger.warn(\"using last shift for filter\");\n            }\n\n            // interim variables\n            meanShift += shift;\n            DoubleMatrix filter;\n\n            if (doHammingFlag) {\n                // Newhamming is scaled and centered around new mean\n                // filter is fftshifted\n                filter = WeightWindows.hamming(\n                        freqAxis.sub(0.5 * shift * deltaF),\n                        RBW - (shift * deltaF),\n                        RSR, alphaHamming);\n                filter.muli(inverseHamming);\n            } else {\n                // no weighting of spectra\n                // filter is fftshifted\n                filter = WeightWindows.rect((freqAxis.sub(.5 * shift * deltaF)).div((RBW - shift * deltaF)));\n            }\n\n            //// Use freq. as returned by fft ////\n            // Note that filter_slave = fliplr(filter_m)\n            // and that this is also valid after ifftshift\n            SpectralUtils.ifftshift_inplace(filter);\n\n            //// Actual spectral filtering ////\n            if (!negShift) {\n                masterDataBlock.putRow((int) outLine, dotmult(masterDataBlock.getRow((int) outLine), new ComplexDoubleMatrix(filter)));\n                fliplr_inplace(filter);\n                slaveDataBlock.putRow((int) outLine, dotmult(slaveDataBlock.getRow((int) outLine), new ComplexDoubleMatrix(filter)));\n            } else {\n                slaveDataBlock.putRow((int) outLine, dotmult(slaveDataBlock.getRow((int) outLine), new ComplexDoubleMatrix(filter)));\n                fliplr_inplace(filter);\n                masterDataBlock.putRow((int) outLine, dotmult(masterDataBlock.getRow((int) outLine), new ComplexDoubleMatrix(filter)));\n            }\n\n            /// Update 'walking' mean\n            if (outLine != lastLine) {\n                DoubleMatrix line1 = power.getRow((int) (outLine - firstLine));\n                DoubleMatrix lineN = power.getRow((int) (outLine - firstLine + nlMean));\n                nlMeanPower.addi(lineN.sub(line1));\n            }\n\n        } // loop over outLines\n\n        // IFFT of spectrally filtered data, and return these\n        SpectralUtils.invfft_inplace(masterDataBlock, 2);\n        SpectralUtils.invfft_inplace(slaveDataBlock, 2);\n\n        // return these main filter call\n        meanShift /= (outputLines - notFiltered);\n        meanSNR /= outputLines;\n        percentNotFiltered = 100. * (float) (notFiltered) / (float) outputLines;\n\n        // Some info for this data block\n        final double meanFrFreq = meanShift * deltaF;    // Hz?\n        logger.debug(\"mean SHIFT for block\"\n                + \": \" + meanShift\n                + \" = \" + meanFrFreq / 1e6 + \" MHz (fringe freq.).\");\n\n        logger.debug(\"mean SNR for block: \" + meanSNR);\n        logger.debug(\"filtered for block\"\n                + \": \" + (100.00 - percentNotFiltered) + \"%\");\n\n        if (percentNotFiltered > 60.0) {\n            logger.warn(\"more then 60% of signal filtered?!?\");\n        }\n\n    }", "signature": "void filterBlock(ComplexDoubleMatrix masterDataBlock, // updated\n                            ComplexDoubleMatrix slaveDataBlock,  // updated\n                            int nlMean,\n                            double SNRthreshold,\n                            double RSR, // in MHz\n                            double RBW, // in MHz\n                            double alphaHamming,\n                            int ovsFactor,\n                            boolean doWeightCorrelFlag)", "full_signature": "@Deprecated public static void filterBlock(ComplexDoubleMatrix masterDataBlock, // updated\n                            ComplexDoubleMatrix slaveDataBlock,  // updated\n                            int nlMean,\n                            double SNRthreshold,\n                            double RSR, // in MHz\n                            double RBW, // in MHz\n                            double alphaHamming,\n                            int ovsFactor,\n                            boolean doWeightCorrelFlag)", "class_method_signature": "RangeFilter.filterBlock(ComplexDoubleMatrix masterDataBlock, // updated\n                            ComplexDoubleMatrix slaveDataBlock,  // updated\n                            int nlMean,\n                            double SNRthreshold,\n                            double RSR, // in MHz\n                            double RBW, // in MHz\n                            double alphaHamming,\n                            int ovsFactor,\n                            boolean doWeightCorrelFlag)", "testcase": false, "constructor": false, "invocations": ["isOdd", "error", "isPower2", "error", "isPower2", "error", "error", "error", "warn", "defineFrequencyAxis", "inverseHamming", "computeIfg", "computeIfg", "debug", "fft_inplace", "intensity", "doWeightCorrel", "fft_inplace", "fft_inplace", "trace", "computeNlMeanPower", "sum", "max", "argmax", "warn", "hamming", "sub", "muli", "rect", "div", "sub", "ifftshift_inplace", "putRow", "dotmult", "getRow", "fliplr_inplace", "putRow", "dotmult", "getRow", "putRow", "dotmult", "getRow", "fliplr_inplace", "putRow", "dotmult", "getRow", "getRow", "getRow", "addi", "sub", "invfft_inplace", "invfft_inplace", "debug", "debug", "debug", "warn"]}, "repository": {"repo_id": 1605107, "url": "https://github.com/ppolabs/jdoris", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 5, "size": 3997, "license": "licensed"}}