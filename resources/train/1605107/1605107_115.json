{"test_class": {"identifier": "PolyUtilsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double DELTA_06 = 1e-06;", "modifier": "private static final", "type": "double", "declarator": "DELTA_06 = 1e-06", "var_name": "DELTA_06"}, {"original_string": "private static final double DELTA_03 = 1e-03;", "modifier": "private static final", "type": "double", "declarator": "DELTA_03 = 1e-03", "var_name": "DELTA_03"}, {"original_string": "private static final double DELTA_02 = 1e-02;", "modifier": "private static final", "type": "double", "declarator": "DELTA_02 = 1e-02", "var_name": "DELTA_02"}, {"original_string": "private static final double DELTA_01 = 1e-01;", "modifier": "private static final", "type": "double", "declarator": "DELTA_01 = 1e-01", "var_name": "DELTA_01"}], "file": "jdoris-core/src/test/java/org/jdoris/core/utils/PolyUtilsTest.java"}, "test_case": {"identifier": "testPolyFit", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testPolyFit() throws Exception {\n\n        // max degree\n        final int maxDegree = 6;\n\n        double[] x = MathUtils.increment(11, 0, 0.1);\n        double[] y = new double[x.length];\n\n        // define double as errf(x)\n        for (int i = 0; i < x.length; i++) {\n            y[i] = erf(x[i]);\n//            System.out.println(\"y = \" + y[i]);\n        }\n\n        // define EXPECTED values : precomputde in matlab with fliplr(polyfit)\n        ArrayList<double[]> coeff_EXPECTED = new ArrayList<double[]>();\n        coeff_EXPECTED.add(new double[]{0.0531277556004621, 0.853026625583286});\n        coeff_EXPECTED.add(new double[]{-0.00634545069301346, 1.24951466753979, -0.396488041956504});\n        coeff_EXPECTED.add(new double[]{-0.00117120913502653, 1.16730171834066, -0.180894643707045,\n                -0.143728932166306});\n        coeff_EXPECTED.add(new double[]{1.87578727256749e-05, 1.12598341946038, 0.0256968506943939,\n                -0.474275323208611, 0.165273195521153});\n        coeff_EXPECTED.add(new double[]{7.50968728582951e-06, 1.12686515221902, 0.0184323975978185,\n                -0.453809874699964, 0.141839475854753, 0.00937348786656298});\n        coeff_EXPECTED.add(new double[]{6.40296881978214e-08, 1.12837041599673, -3.2419597312071e-05,\n                -0.374389526989057, -0.0116238001908376, 0.145877210494725, -0.0455012408760536});\n\n        // loop over assert\n        for (int degree = 0; degree < maxDegree; degree++) {\n            double[] coeff_ACTUAL = PolyUtils.polyFit(new DoubleMatrix(x), new DoubleMatrix(y), degree + 1);\n            Assert.assertArrayEquals(coeff_EXPECTED.get(degree), coeff_ACTUAL, DELTA_03);\n        }\n\n    }", "signature": "void testPolyFit()", "full_signature": "@Test public void testPolyFit()", "class_method_signature": "PolyUtilsTest.testPolyFit()", "testcase": true, "constructor": false, "invocations": ["increment", "erf", "add", "add", "add", "add", "add", "add", "polyFit", "assertArrayEquals", "get"]}, "focal_class": {"identifier": "PolyUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Logger logger = (Logger) LoggerFactory.getLogger(PolyUtils.class);", "modifier": "public static final", "type": "Logger", "declarator": "logger = (Logger) LoggerFactory.getLogger(PolyUtils.class)", "var_name": "logger"}], "methods": [{"identifier": "normalize2", "parameters": "(double data, final int min, final int max)", "modifiers": "public static", "return": "double", "signature": "double normalize2(double data, final int min, final int max)", "full_signature": "public static double normalize2(double data, final int min, final int max)", "class_method_signature": "PolyUtils.normalize2(double data, final int min, final int max)", "testcase": false, "constructor": false}, {"identifier": "normalize2", "parameters": "(double data, final double min, final double max)", "modifiers": "public static", "return": "double", "signature": "double normalize2(double data, final double min, final double max)", "full_signature": "public static double normalize2(double data, final double min, final double max)", "class_method_signature": "PolyUtils.normalize2(double data, final double min, final double max)", "testcase": false, "constructor": false}, {"identifier": "normalize", "parameters": "(DoubleMatrix t)", "modifiers": "public static", "return": "DoubleMatrix", "signature": "DoubleMatrix normalize(DoubleMatrix t)", "full_signature": "public static DoubleMatrix normalize(DoubleMatrix t)", "class_method_signature": "PolyUtils.normalize(DoubleMatrix t)", "testcase": false, "constructor": false}, {"identifier": "degreeFromCoefficients", "parameters": "(int numOfCoefficients)", "modifiers": "public static", "return": "int", "signature": "int degreeFromCoefficients(int numOfCoefficients)", "full_signature": "public static int degreeFromCoefficients(int numOfCoefficients)", "class_method_signature": "PolyUtils.degreeFromCoefficients(int numOfCoefficients)", "testcase": false, "constructor": false}, {"identifier": "numberOfCoefficients", "parameters": "(final int degree)", "modifiers": "public static", "return": "int", "signature": "int numberOfCoefficients(final int degree)", "full_signature": "public static int numberOfCoefficients(final int degree)", "class_method_signature": "PolyUtils.numberOfCoefficients(final int degree)", "testcase": false, "constructor": false}, {"identifier": "polyFitNormalized", "parameters": "(DoubleMatrix t, DoubleMatrix y, final int degree)", "modifiers": "public static", "return": "double[]", "signature": "double[] polyFitNormalized(DoubleMatrix t, DoubleMatrix y, final int degree)", "full_signature": "public static double[] polyFitNormalized(DoubleMatrix t, DoubleMatrix y, final int degree)", "class_method_signature": "PolyUtils.polyFitNormalized(DoubleMatrix t, DoubleMatrix y, final int degree)", "testcase": false, "constructor": false}, {"identifier": "polyFit2D", "parameters": "(final DoubleMatrix x, final DoubleMatrix y, final DoubleMatrix z, final int degree)", "modifiers": "public static", "return": "double[]", "signature": "double[] polyFit2D(final DoubleMatrix x, final DoubleMatrix y, final DoubleMatrix z, final int degree)", "full_signature": "public static double[] polyFit2D(final DoubleMatrix x, final DoubleMatrix y, final DoubleMatrix z, final int degree)", "class_method_signature": "PolyUtils.polyFit2D(final DoubleMatrix x, final DoubleMatrix y, final DoubleMatrix z, final int degree)", "testcase": false, "constructor": false}, {"identifier": "polyFit", "parameters": "(DoubleMatrix t, DoubleMatrix y, final int degree)", "modifiers": "public static", "return": "double[]", "signature": "double[] polyFit(DoubleMatrix t, DoubleMatrix y, final int degree)", "full_signature": "public static double[] polyFit(DoubleMatrix t, DoubleMatrix y, final int degree)", "class_method_signature": "PolyUtils.polyFit(DoubleMatrix t, DoubleMatrix y, final int degree)", "testcase": false, "constructor": false}, {"identifier": "polyVal1D", "parameters": "(double x, double[] coeffs)", "modifiers": "public static", "return": "double", "signature": "double polyVal1D(double x, double[] coeffs)", "full_signature": "public static double polyVal1D(double x, double[] coeffs)", "class_method_signature": "PolyUtils.polyVal1D(double x, double[] coeffs)", "testcase": false, "constructor": false}, {"identifier": "polyval", "parameters": "(final double[] x, final double[] y, final double coeff[], int degree)", "modifiers": "public static", "return": "double[][]", "signature": "double[][] polyval(final double[] x, final double[] y, final double coeff[], int degree)", "full_signature": "public static double[][] polyval(final double[] x, final double[] y, final double coeff[], int degree)", "class_method_signature": "PolyUtils.polyval(final double[] x, final double[] y, final double coeff[], int degree)", "testcase": false, "constructor": false}, {"identifier": "polyval", "parameters": "(final DoubleMatrix x, final DoubleMatrix y, final DoubleMatrix coeff, int degree)", "modifiers": "public static", "return": "DoubleMatrix", "signature": "DoubleMatrix polyval(final DoubleMatrix x, final DoubleMatrix y, final DoubleMatrix coeff, int degree)", "full_signature": "public static DoubleMatrix polyval(final DoubleMatrix x, final DoubleMatrix y, final DoubleMatrix coeff, int degree)", "class_method_signature": "PolyUtils.polyval(final DoubleMatrix x, final DoubleMatrix y, final DoubleMatrix coeff, int degree)", "testcase": false, "constructor": false}, {"identifier": "polyval", "parameters": "(final double x, final double y, final DoubleMatrix coeff, int degree)", "modifiers": "public static", "return": "double", "signature": "double polyval(final double x, final double y, final DoubleMatrix coeff, int degree)", "full_signature": "public static double polyval(final double x, final double y, final DoubleMatrix coeff, int degree)", "class_method_signature": "PolyUtils.polyval(final double x, final double y, final DoubleMatrix coeff, int degree)", "testcase": false, "constructor": false}, {"identifier": "polyval", "parameters": "(final double x, final double y, final double[] coeff)", "modifiers": "public static", "return": "double", "signature": "double polyval(final double x, final double y, final double[] coeff)", "full_signature": "public static double polyval(final double x, final double y, final double[] coeff)", "class_method_signature": "PolyUtils.polyval(final double x, final double y, final double[] coeff)", "testcase": false, "constructor": false}, {"identifier": "polyval", "parameters": "(final double x, final double y, final double[] coeff, int degree)", "modifiers": "public static", "return": "double", "signature": "double polyval(final double x, final double y, final double[] coeff, int degree)", "full_signature": "public static double polyval(final double x, final double y, final double[] coeff, int degree)", "class_method_signature": "PolyUtils.polyval(final double x, final double y, final double[] coeff, int degree)", "testcase": false, "constructor": false}], "file": "jdoris-core/src/main/java/org/jdoris/core/utils/PolyUtils.java"}, "focal_method": {"identifier": "polyFit", "parameters": "(DoubleMatrix t, DoubleMatrix y, final int degree)", "modifiers": "public static", "return": "double[]", "body": "public static double[] polyFit(DoubleMatrix t, DoubleMatrix y, final int degree) throws IllegalArgumentException {\n\n        logger.setLevel(Level.INFO);\n\n        if (t.length != y.length || !t.isVector() || !y.isVector()) {\n            logger.error(\"polyfit: require same size vectors.\");\n            throw new IllegalArgumentException(\"polyfit: require same size vectors.\");\n        }\n\n        // Normalize _posting_ for numerical reasons\n        final int numOfPoints = t.length;\n\n        // Check redundancy\n        final int numOfUnknowns = degree + 1;\n        logger.debug(\"Degree of interpolating polynomial: {}\", degree);\n        logger.debug(\"Number of unknowns: {}\", numOfUnknowns);\n        logger.debug(\"Number of data points: {}\", numOfPoints);\n\n        if (numOfPoints < numOfUnknowns) {\n            logger.error(\"Number of points is smaller than parameters solved for.\");\n            throw new IllegalArgumentException(\"Number of points is smaller than parameters solved for.\");\n        }\n\n        // Set up system of equations to solve coeff :: Design matrix\n        logger.debug(\"Setting up linear system of equations\");\n        DoubleMatrix A = new DoubleMatrix(numOfPoints, numOfUnknowns);\n        // work with columns\n        for (int j = 0; j <= degree; j++) {\n            A.putColumn(j, pow(t, j));\n        }\n\n        // Fit polynomial through computed vector of phases\n        logger.debug(\"Solving lin. system of equations with Cholesky.\");\n\n        DoubleMatrix N = A.transpose().mmul(A);\n        DoubleMatrix rhs = A.transpose().mmul(y);\n\n        // solution seems to be OK up to 10^-09!\n        DoubleMatrix x = Solve.solveSymmetric(N, rhs);\n        DoubleMatrix Qx_hat = Solve.solveSymmetric(N, DoubleMatrix.eye(N.getRows()));\n\n        double maxDeviation = (N.mmul(Qx_hat).sub(DoubleMatrix.eye(Qx_hat.rows))).normmax();\n        logger.debug(\"polyfit orbit: max(abs(N*inv(N)-I)) = \" + maxDeviation);\n\n        // ___ report max error... (seems sometimes this can be extremely large) ___\n        if (maxDeviation > 1e-6) {\n            logger.warn(\"polyfit orbit: max(abs(N*inv(N)-I)) = {}\", maxDeviation);\n            logger.warn(\"polyfit orbit interpolation unstable!\");\n        }\n\n        // work out residuals\n        DoubleMatrix y_hat = A.mmul(x);\n        DoubleMatrix e_hat = y.sub(y_hat);\n\n        // 0.05 is already 1 wavelength! (?)\n        if (e_hat.normmax() > 0.02) {\n            logger.warn(\"WARNING: Max. approximation error at datapoints (x,y,or z?): {}\", e_hat.normmax());\n        } else {\n            logger.debug(\"Max. approximation error at datapoints (x,y,or z?): {}\", e_hat.normmax());\n        }\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"REPORTING POLYFIT LEAST SQUARES ERRORS\");\n            logger.debug(\" time \\t\\t\\t y \\t\\t\\t yhat  \\t\\t\\t ehat\");\n            for (int i = 0; i < numOfPoints; i++) {\n                logger.debug(\" \" + t.get(i) + \"\\t\" + y.get(i) + \"\\t\" + y_hat.get(i) + \"\\t\" + e_hat.get(i));\n            }\n\n            for (int i = 0; i < numOfPoints - 1; i++) {\n                // ___ check if dt is constant, not necessary for me, but may ___\n                // ___ signal error in header data of SLC image ___\n                double dt = t.get(i + 1) - t.get(i);\n                logger.debug(\"Time step between point \" + i + 1 + \" and \" + i + \"= \" + dt);\n\n                if (Math.abs(dt - (t.get(1) - t.get(0))) > 0.001)// 1ms of difference we allow...\n                    logger.warn(\"WARNING: Orbit: data does not have equidistant time interval?\");\n            }\n        }\n        return x.toArray();\n    }", "signature": "double[] polyFit(DoubleMatrix t, DoubleMatrix y, final int degree)", "full_signature": "public static double[] polyFit(DoubleMatrix t, DoubleMatrix y, final int degree)", "class_method_signature": "PolyUtils.polyFit(DoubleMatrix t, DoubleMatrix y, final int degree)", "testcase": false, "constructor": false, "invocations": ["setLevel", "isVector", "isVector", "error", "debug", "debug", "debug", "error", "debug", "putColumn", "pow", "debug", "mmul", "transpose", "mmul", "transpose", "solveSymmetric", "solveSymmetric", "eye", "getRows", "normmax", "sub", "mmul", "eye", "debug", "warn", "warn", "mmul", "sub", "normmax", "warn", "normmax", "debug", "normmax", "isDebugEnabled", "debug", "debug", "debug", "get", "get", "get", "get", "get", "get", "debug", "abs", "get", "get", "warn", "toArray"]}, "repository": {"repo_id": 1605107, "url": "https://github.com/ppolabs/jdoris", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 5, "size": 3997, "license": "licensed"}}