{"test_class": {"identifier": "PreprocessTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Preprocess module;", "modifier": "private static", "type": "Preprocess", "declarator": "module", "var_name": "module"}, {"original_string": "private static MaryInterface mary;", "modifier": "private static", "type": "MaryInterface", "declarator": "mary", "var_name": "mary"}], "file": "marytts-languages/marytts-lang-en/src/test/java/marytts/language/en/PreprocessTest.java"}, "test_case": {"identifier": "testExpand", "parameters": "(String token, String word)", "modifiers": "@Test(dataProvider = \"ExpandTestData\") public", "return": "void", "body": "@Test(dataProvider = \"ExpandTestData\")\n    public void testExpand(String token, String word) throws Exception {\n        String words = \"<maryxml xmlns=\\\"http://mary.dfki.de/2002/MaryXML\\\" \" +\n                \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" version=\\\"0.5\\\"><p><s><t>\"\n                + token + \"</t></s></p></maryxml>\";\n        String retVal = module.expand(DomUtils.parseDocument(words));\n        Assert.assertEquals(retVal, word);\n    }", "signature": "void testExpand(String token, String word)", "full_signature": "@Test(dataProvider = \"ExpandTestData\") public void testExpand(String token, String word)", "class_method_signature": "PreprocessTest.testExpand(String token, String word)", "testcase": true, "constructor": false, "invocations": ["expand", "parseDocument", "assertEquals"]}, "focal_class": {"identifier": "Preprocess", "superclass": "extends InternalModule", "interfaces": "", "fields": [{"original_string": "private static final Map<String, String> symbols = new HashMap<>();", "modifier": "private static final", "type": "Map<String, String>", "declarator": "symbols = new HashMap<>()", "var_name": "symbols"}, {"original_string": "private static final Map<String, String[]> contractions = new HashMap<>();", "modifier": "private static final", "type": "Map<String, String[]>", "declarator": "contractions = new HashMap<>()", "var_name": "contractions"}, {"original_string": "private static final Pattern moneyPattern = Pattern.compile(\"([$\u00a3\u20ac])(-?([\\\\d,]+\\\\.?\\\\d+|\\\\.\\\\d+)+)\");", "modifier": "private static final", "type": "Pattern", "declarator": "moneyPattern = Pattern.compile(\"([$\u00a3\u20ac])(-?([\\\\d,]+\\\\.?\\\\d+|\\\\.\\\\d+)+)\");", "var_name": "moneyPattern"}, {"original_string": "private static final Pattern timePattern = Pattern.compile(\"((0?[0-9])|(1[0-1])|(1[2-9])|(2[0-3])):([0-5][0-9])\" +\n            \"(a\\\\.m\\\\.|am|pm|p\\\\.m\\\\.|a\\\\.m|p\\\\.m)?\", Pattern.CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "timePattern = Pattern.compile(\"((0?[0-9])|(1[0-1])|(1[2-9])|(2[0-3])):([0-5][0-9])\" +\n            \"(a\\\\.m\\\\.|am|pm|p\\\\.m\\\\.|a\\\\.m|p\\\\.m)?\", Pattern.CASE_INSENSITIVE)", "var_name": "timePattern"}, {"original_string": "private static final Pattern durationPattern = Pattern.compile(\"(\\\\d+):([0-5][0-9]):([0-5][0-9])(:([0-5][0-9]))?\");", "modifier": "private static final", "type": "Pattern", "declarator": "durationPattern = Pattern.compile(\"(\\\\d+):([0-5][0-9]):([0-5][0-9])(:([0-5][0-9]))?\")", "var_name": "durationPattern"}, {"original_string": "private static final Pattern abbrevPattern = Pattern.compile(\"[a-zA-Z]{2,}\\\\.\");", "modifier": "private static final", "type": "Pattern", "declarator": "abbrevPattern = Pattern.compile(\"[a-zA-Z]{2,}\\\\.\")", "var_name": "abbrevPattern"}, {"original_string": "private static final Pattern acronymPattern = Pattern.compile(\"([a-zA-Z]\\\\.[a-zA-Z](\\\\.)?)+([a-zA-Z](\\\\.)?)?\");", "modifier": "private static final", "type": "Pattern", "declarator": "acronymPattern = Pattern.compile(\"([a-zA-Z]\\\\.[a-zA-Z](\\\\.)?)+([a-zA-Z](\\\\.)?)?\")", "var_name": "acronymPattern"}, {"original_string": "private static final Pattern realNumPattern = Pattern.compile(\"(-)?([\\\\d,]+)?(\\\\.(\\\\d+)(%)?)?\");", "modifier": "private static final", "type": "Pattern", "declarator": "realNumPattern = Pattern.compile(\"(-)?([\\\\d,]+)?(\\\\.(\\\\d+)(%)?)?\")", "var_name": "realNumPattern"}, {"original_string": "private static final Pattern numberWordPattern = Pattern.compile(\"([a-zA-Z]+[0-9]+|[0-9]+[a-zA-Z]+)\\\\w*\");", "modifier": "private static final", "type": "Pattern", "declarator": "numberWordPattern = Pattern.compile(\"([a-zA-Z]+[0-9]+|[0-9]+[a-zA-Z]+)\\\\w*\")", "var_name": "numberWordPattern"}, {"original_string": "private static final Pattern datePattern = Pattern.compile(\"(\\\\d{1,2})[/.](\\\\d{1,2})[/.]\\\\d{4}\");", "modifier": "private static final", "type": "Pattern", "declarator": "datePattern = Pattern.compile(\"(\\\\d{1,2})[/.](\\\\d{1,2})[/.]\\\\d{4}\")", "var_name": "datePattern"}, {"original_string": "private static final Pattern yearPattern = Pattern.compile(\"(\\\\d+)(bc|ad|b\\\\.c\\\\.|b\\\\.c|a\\\\.d\\\\.|a\\\\.d)\", Pattern.CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "yearPattern = Pattern.compile(\"(\\\\d+)(bc|ad|b\\\\.c\\\\.|b\\\\.c|a\\\\.d\\\\.|a\\\\.d)\", Pattern.CASE_INSENSITIVE)", "var_name": "yearPattern"}, {"original_string": "private static final Pattern contractPattern = Pattern.compile(\"[a-zA-Z]+('[a-zA-Z]+)\");", "modifier": "private static final", "type": "Pattern", "declarator": "contractPattern = Pattern.compile(\"[a-zA-Z]+('[a-zA-Z]+)\")", "var_name": "contractPattern"}, {"original_string": "private static final Pattern URLPattern = Pattern.compile(\"(https?://)?((www\\\\.)?([-a-zA-Z0-9@:%._\\\\\\\\+~#=]{2,256}\\\\.\" +\n            \"[a-z]{2,6}\\\\b([-a-zA-Z0-9@:%_\\\\\\\\+.~#?&/=]*)))\");", "modifier": "private static final", "type": "Pattern", "declarator": "URLPattern = Pattern.compile(\"(https?://)?((www\\\\.)?([-a-zA-Z0-9@:%._\\\\\\\\+~#=]{2,256}\\\\.\" +\n            \"[a-z]{2,6}\\\\b([-a-zA-Z0-9@:%_\\\\\\\\+.~#?&/=]*)))\")", "var_name": "URLPattern"}, {"original_string": "private static final Pattern rangePattern = Pattern.compile(\"([0-9]+)-([0-9]+)\");", "modifier": "private static final", "type": "Pattern", "declarator": "rangePattern = Pattern.compile(\"([0-9]+)-([0-9]+)\")", "var_name": "rangePattern"}, {"original_string": "private static final Pattern consonantPattern = Pattern.compile(\"[b-df-hj-np-tv-z]+\", Pattern.CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "consonantPattern = Pattern.compile(\"[b-df-hj-np-tv-z]+\", Pattern.CASE_INSENSITIVE)", "var_name": "consonantPattern"}, {"original_string": "private static final Pattern punctuationPattern = Pattern.compile(\"\\\\p{Punct}\");", "modifier": "private static final", "type": "Pattern", "declarator": "punctuationPattern = Pattern.compile(\"\\\\p{Punct}\")", "var_name": "punctuationPattern"}, {"original_string": "private static final Pattern myPunctPattern = Pattern.compile(\",\\\\.:;?'\\\"\");", "modifier": "private static final", "type": "Pattern", "declarator": "myPunctPattern = Pattern.compile(\",\\\\.:;?'\\\"\")", "var_name": "myPunctPattern"}, {"original_string": "private static final Pattern hashtagPattern = Pattern.compile(\"(#)(\\\\w+)\");", "modifier": "private static final", "type": "Pattern", "declarator": "hashtagPattern = Pattern.compile(\"(#)(\\\\w+)\")", "var_name": "hashtagPattern"}, {"original_string": "private static final Pattern ordinalPattern = Pattern.compile(\"[\\\\d,]+(st|nd|rd|th)\", Pattern.CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "ordinalPattern = Pattern.compile(\"[\\\\d,]+(st|nd|rd|th)\", Pattern.CASE_INSENSITIVE)", "var_name": "ordinalPattern"}, {"original_string": "private static final Pattern currencySymbPattern = Pattern.compile(\"[$\u00a3\u20ac]\");", "modifier": "private static final", "type": "Pattern", "declarator": "currencySymbPattern = Pattern.compile(\"[$\u00a3\u20ac]\");", "var_name": "currencySymbPattern"}, {"original_string": "private static final Pattern numberSPattern = Pattern.compile(\"(\\\\d+)([sS]+)\");", "modifier": "private static final", "type": "Pattern", "declarator": "numberSPattern = Pattern.compile(\"(\\\\d+)([sS]+)\")", "var_name": "numberSPattern"}, {"original_string": "private static final Pattern fourDigitsPattern = Pattern.compile(\"\\\\d{4}\");", "modifier": "private static final", "type": "Pattern", "declarator": "fourDigitsPattern = Pattern.compile(\"\\\\d{4}\")", "var_name": "fourDigitsPattern"}, {"original_string": "protected final String cardinalRule;", "modifier": "protected final", "type": "String", "declarator": "cardinalRule", "var_name": "cardinalRule"}, {"original_string": "protected final String ordinalRule;", "modifier": "protected final", "type": "String", "declarator": "ordinalRule", "var_name": "ordinalRule"}, {"original_string": "protected final String yearRule;", "modifier": "protected final", "type": "String", "declarator": "yearRule", "var_name": "yearRule"}, {"original_string": "private final RuleBasedNumberFormat rbnf;", "modifier": "private final", "type": "RuleBasedNumberFormat", "declarator": "rbnf", "var_name": "rbnf"}, {"original_string": "private final DateFormat df;", "modifier": "private final", "type": "DateFormat", "declarator": "df", "var_name": "df"}, {"original_string": "private Map<Object, Object> abbrevMap;", "modifier": "private", "type": "Map<Object, Object>", "declarator": "abbrevMap", "var_name": "abbrevMap"}], "methods": [{"identifier": "Preprocess", "parameters": "()", "modifiers": "public", "return": "", "signature": " Preprocess()", "full_signature": "public  Preprocess()", "class_method_signature": "Preprocess.Preprocess()", "testcase": false, "constructor": true}, {"identifier": "getOrdinalRuleName", "parameters": "(final RuleBasedNumberFormat rbnf)", "modifiers": "protected static", "return": "String", "signature": "String getOrdinalRuleName(final RuleBasedNumberFormat rbnf)", "full_signature": "protected static String getOrdinalRuleName(final RuleBasedNumberFormat rbnf)", "class_method_signature": "Preprocess.getOrdinalRuleName(final RuleBasedNumberFormat rbnf)", "testcase": false, "constructor": false}, {"identifier": "getYearRuleName", "parameters": "(final RuleBasedNumberFormat rbnf)", "modifiers": "protected static", "return": "String", "signature": "String getYearRuleName(final RuleBasedNumberFormat rbnf)", "full_signature": "protected static String getYearRuleName(final RuleBasedNumberFormat rbnf)", "class_method_signature": "Preprocess.getYearRuleName(final RuleBasedNumberFormat rbnf)", "testcase": false, "constructor": false}, {"identifier": "loadAbbrevMap", "parameters": "()", "modifiers": "public static", "return": "Map<Object, Object>", "signature": "Map<Object, Object> loadAbbrevMap()", "full_signature": "public static Map<Object, Object> loadAbbrevMap()", "class_method_signature": "Preprocess.loadAbbrevMap()", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "(MaryData d)", "modifiers": "public", "return": "MaryData", "signature": "MaryData process(MaryData d)", "full_signature": "public MaryData process(MaryData d)", "class_method_signature": "Preprocess.process(MaryData d)", "testcase": false, "constructor": false}, {"identifier": "expand", "parameters": "(Document doc)", "modifiers": "protected", "return": "String", "signature": "String expand(Document doc)", "full_signature": "protected String expand(Document doc)", "class_method_signature": "Preprocess.expand(Document doc)", "testcase": false, "constructor": false}, {"identifier": "expandNumber", "parameters": "(String number)", "modifiers": "protected", "return": "String", "signature": "String expandNumber(String number)", "full_signature": "protected String expandNumber(String number)", "class_method_signature": "Preprocess.expandNumber(String number)", "testcase": false, "constructor": false}, {"identifier": "expandNumber", "parameters": "(double number)", "modifiers": "protected", "return": "String", "signature": "String expandNumber(double number)", "full_signature": "protected String expandNumber(double number)", "class_method_signature": "Preprocess.expandNumber(double number)", "testcase": false, "constructor": false}, {"identifier": "expandOrdinal", "parameters": "(String number)", "modifiers": "protected", "return": "String", "signature": "String expandOrdinal(String number)", "full_signature": "protected String expandOrdinal(String number)", "class_method_signature": "Preprocess.expandOrdinal(String number)", "testcase": false, "constructor": false}, {"identifier": "expandOrdinal", "parameters": "(double number)", "modifiers": "protected", "return": "String", "signature": "String expandOrdinal(double number)", "full_signature": "protected String expandOrdinal(double number)", "class_method_signature": "Preprocess.expandOrdinal(double number)", "testcase": false, "constructor": false}, {"identifier": "expandYear", "parameters": "(double number)", "modifiers": "protected", "return": "String", "signature": "String expandYear(double number)", "full_signature": "protected String expandYear(double number)", "class_method_signature": "Preprocess.expandYear(double number)", "testcase": false, "constructor": false}, {"identifier": "expandDuration", "parameters": "(String duration)", "modifiers": "protected", "return": "String", "signature": "String expandDuration(String duration)", "full_signature": "protected String expandDuration(String duration)", "class_method_signature": "Preprocess.expandDuration(String duration)", "testcase": false, "constructor": false}, {"identifier": "expandAcronym", "parameters": "(String acronym)", "modifiers": "protected static", "return": "String", "signature": "String expandAcronym(String acronym)", "full_signature": "protected static String expandAcronym(String acronym)", "class_method_signature": "Preprocess.expandAcronym(String acronym)", "testcase": false, "constructor": false}, {"identifier": "expandURL", "parameters": "(String email)", "modifiers": "protected static", "return": "String", "signature": "String expandURL(String email)", "full_signature": "protected static String expandURL(String email)", "class_method_signature": "Preprocess.expandURL(String email)", "testcase": false, "constructor": false}, {"identifier": "expandYearBCAD", "parameters": "(String year)", "modifiers": "protected", "return": "String", "signature": "String expandYearBCAD(String year)", "full_signature": "protected String expandYearBCAD(String year)", "class_method_signature": "Preprocess.expandYearBCAD(String year)", "testcase": false, "constructor": false}, {"identifier": "expandConsonants", "parameters": "(String consonants)", "modifiers": "protected", "return": "String", "signature": "String expandConsonants(String consonants)", "full_signature": "protected String expandConsonants(String consonants)", "class_method_signature": "Preprocess.expandConsonants(String consonants)", "testcase": false, "constructor": false}, {"identifier": "expandHashtag", "parameters": "(String hashtag)", "modifiers": "protected", "return": "String", "signature": "String expandHashtag(String hashtag)", "full_signature": "protected String expandHashtag(String hashtag)", "class_method_signature": "Preprocess.expandHashtag(String hashtag)", "testcase": false, "constructor": false}, {"identifier": "expandRange", "parameters": "(String range)", "modifiers": "protected", "return": "String", "signature": "String expandRange(String range)", "full_signature": "protected String expandRange(String range)", "class_method_signature": "Preprocess.expandRange(String range)", "testcase": false, "constructor": false}, {"identifier": "expandNumberS", "parameters": "(String numberS)", "modifiers": "protected", "return": "String", "signature": "String expandNumberS(String numberS)", "full_signature": "protected String expandNumberS(String numberS)", "class_method_signature": "Preprocess.expandNumberS(String numberS)", "testcase": false, "constructor": false}, {"identifier": "splitContraction", "parameters": "(String contraction)", "modifiers": "protected", "return": "String", "signature": "String splitContraction(String contraction)", "full_signature": "protected String splitContraction(String contraction)", "class_method_signature": "Preprocess.splitContraction(String contraction)", "testcase": false, "constructor": false}, {"identifier": "expandAbbreviation", "parameters": "(String abbrev, boolean isCapital)", "modifiers": "protected", "return": "String", "signature": "String expandAbbreviation(String abbrev, boolean isCapital)", "full_signature": "protected String expandAbbreviation(String abbrev, boolean isCapital)", "class_method_signature": "Preprocess.expandAbbreviation(String abbrev, boolean isCapital)", "testcase": false, "constructor": false}, {"identifier": "removeCommas", "parameters": "(String numberText)", "modifiers": "protected static", "return": "String", "signature": "String removeCommas(String numberText)", "full_signature": "protected static String removeCommas(String numberText)", "class_method_signature": "Preprocess.removeCommas(String numberText)", "testcase": false, "constructor": false}, {"identifier": "expandDate", "parameters": "(String date)", "modifiers": "protected", "return": "String", "signature": "String expandDate(String date)", "full_signature": "protected String expandDate(String date)", "class_method_signature": "Preprocess.expandDate(String date)", "testcase": false, "constructor": false}, {"identifier": "expandTime", "parameters": "(String time)", "modifiers": "protected", "return": "String", "signature": "String expandTime(String time)", "full_signature": "protected String expandTime(String time)", "class_method_signature": "Preprocess.expandTime(String time)", "testcase": false, "constructor": false}, {"identifier": "expandRealNumber", "parameters": "(String number)", "modifiers": "protected", "return": "String", "signature": "String expandRealNumber(String number)", "full_signature": "protected String expandRealNumber(String number)", "class_method_signature": "Preprocess.expandRealNumber(String number)", "testcase": false, "constructor": false}, {"identifier": "expandWordNumber", "parameters": "(String wordnumseq)", "modifiers": "protected", "return": "String", "signature": "String expandWordNumber(String wordnumseq)", "full_signature": "protected String expandWordNumber(String wordnumseq)", "class_method_signature": "Preprocess.expandWordNumber(String wordnumseq)", "testcase": false, "constructor": false}, {"identifier": "expandMoney", "parameters": "(String money)", "modifiers": "protected", "return": "String", "signature": "String expandMoney(String money)", "full_signature": "protected String expandMoney(String money)", "class_method_signature": "Preprocess.expandMoney(String money)", "testcase": false, "constructor": false}], "file": "marytts-languages/marytts-lang-en/src/main/java/marytts/language/en/Preprocess.java"}, "focal_method": {"identifier": "expand", "parameters": "(Document doc)", "modifiers": "protected", "return": "String", "body": "protected String expand(Document doc) throws ParseException, IOException, MaryConfigurationException {\n        String whichCurrency = \"\";\n        boolean URLFirst = false;\n        boolean isURL = false;\n        boolean puncSplit = false;\n        boolean dashSplit = false;\n        String webEmailTemp = \"\";\n        String retVal = null;\n        TreeWalker tw = ((DocumentTraversal) doc).createTreeWalker(doc, NodeFilter.SHOW_ELEMENT,\n                new NameNodeFilter(MaryXML.TOKEN), false);\n        Element t;\n        // loop through each node in dom tree\n        while ((t = (Element) tw.nextNode()) != null) {\n            /*\n             * PRELIM FOR EACH NODE\n             */\n            // to accommodate the first token being a url\n            if (URLFirst) {\n                t = (Element) tw.previousNode();\n                URLFirst = false;\n            }\n            boolean isYear = true;\n            boolean splitContraction = false;\n            if (MaryDomUtils.hasAncestor(t, MaryXML.SAYAS) || t.hasAttribute(\"ph\") || t.hasAttribute(\"sounds_like\")) {\n                // if token already has any of these attributes then ignore\n                continue;\n            }\n            String tokenText = MaryDomUtils.tokenText(t);\n            // isYear extra check\n            if (fourDigitsPattern.matcher(tokenText).matches() && !whichCurrency.equals(\"\")) {\n                isYear = false;\n            }\n            // check if currency\n            if (currencySymbPattern.matcher(tokenText).matches()) {\n                whichCurrency = tokenText;\n            }\n            /*\n             * ACTUAL PROCESSING\n             */\n            // ordinal\n            if (ordinalPattern.matcher(tokenText).matches()) {\n                String matched = tokenText.split(\"(?i)st|nd|rd|th\")[0];\n                MaryDomUtils.setTokenText(t, expandOrdinal(matched));\n                // single a or A character\n            } else if (tokenText.matches(\"[aA]\")) {\n                Element checkNextNode = MaryDomUtils.getNextSiblingElement(t);\n                if (checkNextNode == null || myPunctPattern.matcher(MaryDomUtils.tokenText(checkNextNode)).matches()\n                        || MaryDomUtils.tokenText(checkNextNode).length() == 1) {\n                    MaryDomUtils.setTokenText(t, \"_a\");\n                }\n                // date\n            } else if (datePattern.matcher(tokenText).matches()) {\n                MaryDomUtils.setTokenText(t, expandDate(tokenText));\n                // number followed by s\n            } else if (numberSPattern.matcher(tokenText).matches()) {\n                MaryDomUtils.setTokenText(t, expandNumberS(tokenText));\n                // year with bc or ad\n            } else if (yearPattern.matcher(tokenText).matches()) {\n                MaryDomUtils.setTokenText(t, expandYearBCAD(tokenText));\n                // year as just 4 digits &rarr; this should always be checked BEFORE real number\n            } else if (fourDigitsPattern.matcher(tokenText).matches() && isYear) {\n                MaryDomUtils.setTokenText(t, expandYear(Double.parseDouble(tokenText)));\n                // wordAndNumber &rarr; must come AFTER year\n            } else if (numberWordPattern.matcher(tokenText).matches()) {\n                MaryDomUtils.setTokenText(t, expandWordNumber(tokenText));\n                // Currency\n            } else if (moneyPattern.matcher(tokenText).matches()) {\n                MaryDomUtils.setTokenText(t, expandMoney(tokenText));\n                // real number\n            } else if (realNumPattern.matcher(tokenText).matches()) {\n                if (!\"\".equals(whichCurrency)) {\n                    MaryDomUtils.setTokenText(t, expandMoney(whichCurrency + tokenText));\n                } else {\n                    MaryDomUtils.setTokenText(t, expandRealNumber(tokenText));\n                }\n                // contractions\n            } else if (contractPattern.matcher(tokenText).matches()) {\n                // first check lexicon\n                if (MaryRuntimeUtils.checkLexicon(\"en_US\", tokenText).length == 0) {\n                    Matcher contractionMatch = contractPattern.matcher(tokenText);\n                    if (contractionMatch.find()) {\n                        // if no contraction we allow g2p rules to handle\n                        if (!contractions.containsKey(contractionMatch.group(1))) {\n                            MaryDomUtils.setTokenText(t, tokenText.replaceAll(\"'\", \"\"));\n                        }\n                    } else {\n                        throw new IllegalStateException(\"No match for find()\");\n                    }\n                    // FIXME: we do not want to have to phonological word => for now we do not split !\n                    // // if not in lexicon and we have a contraction expansion then split into two tokens\n                    // else\n                    // {\n                    // splitContraction = true;\n                    // MaryDomUtils.setTokenText(t, splitContraction(tokenText));\n                    // }\n                }\n                // acronym\n            } else if (acronymPattern.matcher(tokenText).matches()) {\n                MaryDomUtils.setTokenText(t, expandAcronym(tokenText));\n                // abbreviation\n            } else if ((abbrevPattern.matcher(tokenText).matches() ||\n                    abbrevMap.containsKey(tokenText.toLowerCase())) && !isURL) {\n                Element testAbbNode = MaryDomUtils.getNextSiblingElement(t);\n                boolean nextTokenIsCapital = false;\n                if (testAbbNode != null && Character.isUpperCase(MaryDomUtils.tokenText(testAbbNode).charAt(0))) {\n                    nextTokenIsCapital = true;\n                }\n                MaryDomUtils.setTokenText(t, expandAbbreviation(tokenText, nextTokenIsCapital));\n                // time\n            } else if (timePattern.matcher(tokenText).matches()) {\n                MaryDomUtils.setTokenText(t, expandTime(tokenText));\n                // duration\n            } else if (durationPattern.matcher(tokenText).matches()) {\n                MaryDomUtils.setTokenText(t, expandDuration(tokenText));\n                // hashtags\n            } else if (hashtagPattern.matcher(tokenText).matches()) {\n                MaryDomUtils.setTokenText(t, expandHashtag(tokenText));\n                // URLs\n            } else if (URLPattern.matcher(tokenText).matches()) {\n                // matching group 2 contains the chunk we want\n                Matcher urlMatcher = URLPattern.matcher(tokenText);\n                if (urlMatcher.find()) {\n                    webEmailTemp = tokenText;\n                    isURL = true;\n                    MaryDomUtils.setTokenText(t, expandURL(urlMatcher.group(2)));\n                } else {\n                    throw new IllegalStateException(\"No match for find()\");\n                }\n                // dot . for web and email addresses\n            } else if (tokenText.equals(\".\") && isURL) {\n                MaryDomUtils.setTokenText(t, \"dot\");\n                webEmailTemp = webEmailTemp.replaceFirst(\"\\\\.\", \"dot\");\n                if (!webEmailTemp.contains(\".\")) {\n                    isURL = false;\n                }\n                // symbols\n            } else if (symbols.containsKey(tokenText)) {\n                MaryDomUtils.setTokenText(t, symbols.get(tokenText));\n                // number ranges &rarr; before checking for dashes\n            } else if (rangePattern.matcher(tokenText).matches()) {\n                MaryDomUtils.setTokenText(t, expandRange(tokenText));\n                // dashes and underscores\n            } else if (tokenText.contains(\"-\") || tokenText.contains(\"_\")) {\n                dashSplit = true;\n                String[] tokens = tokenText.split(\"[-_]\");\n                int i = 0;\n                for (String tok : tokens) {\n                    if (tok.matches(\"\\\\d+\")) {\n                        StringBuilder newTok = new StringBuilder();\n                        for (char c : tok.toCharArray()) {\n                            newTok.append(expandNumber(String.valueOf(c))).append(\" \");\n                        }\n                        tokens[i] = newTok.toString();\n                    }\n                    i++;\n                }\n                MaryDomUtils.setTokenText(t, Arrays.toString(tokens).replaceAll(\"[,\\\\]\\\\[]\", \"\"));\n                // words containing only consonants\n            } else if (consonantPattern.matcher(tokenText).matches()) {\n                // first check lexicon\n                if (MaryRuntimeUtils.checkLexicon(\"en_US\", tokenText).length == 0) {\n                    MaryDomUtils.setTokenText(t, expandConsonants(tokenText));\n                }\n                // a final attempt to split by punctuation\n            } else if (punctuationPattern.matcher(tokenText).find() && tokenText.length() > 1) {\n                puncSplit = true;\n                String[] puncTokens = tokenText.split(\"((?<=\\\\p{Punct})|(?=\\\\p{Punct}))\");\n                MaryDomUtils.setTokenText(t, Arrays.toString(puncTokens).replaceAll(\"[,\\\\]\\\\[]\", \"\"));\n            } else if (tokenText.equals(\"\\\"\")) {\n                // FIXME: skip quotes for now as we don't have any clever management of the POS for the prosodic feature\n            } else if (punctuationPattern.matcher(tokenText).matches()) {\n                t.setAttribute(\"pos\", \".\");\n            }\n            if (retVal == null) {\n                retVal = MaryDomUtils.tokenText(t);\n            }\n            // if token isn't ignored but there is no handling rule don't add MTU\n            if (!tokenText.equals(MaryDomUtils.tokenText(t))) {\n                MaryDomUtils.encloseWithMTU(t, tokenText, null);\n                // finally, split new expanded token separated by spaces into separate tokens (also catch any leftover dashes)\n                String[] newTokens = MaryDomUtils.tokenText(t).replaceAll(\"-\", \" \").split(\"\\\\s+\");\n                MaryDomUtils.setTokenText(t, newTokens[0]);\n                for (int i = 1; i < newTokens.length; i++) {\n                    requireNonNull(t);\n                    MaryDomUtils.appendToken(t, newTokens[i]);\n                    t = MaryDomUtils.getNextSiblingElement(t);\n                    // if tokens are an expanded contraction\n                    // TODO: the followng expression is always false...\n                    if (splitContraction && newTokens.length == 2) {\n                        if (newTokens[0].substring(newTokens[0].length() - 1).matches(\"[cfkpt]\")\n                                && contractions.get(newTokens[i]).length > 1) {\n                            t.setAttribute(\"ph\", contractions.get(newTokens[i])[1]);\n                        } else {\n                            t.setAttribute(\"ph\", contractions.get(newTokens[i])[0]);\n                        }\n                    }\n                }\n                // if expanded url or punctuation go over each node, otherwise let TreeWalker catch up\n                if (!isURL && !puncSplit && !dashSplit) {\n                    tw.setCurrentNode(t);\n                } else {\n                    Node n = tw.previousNode();\n                    // if the first node in doc is an email or web address, account for this\n                    if (n == null) {\n                        URLFirst = true;\n                    }\n                    puncSplit = false;\n                    dashSplit = false;\n                }\n            }\n        }\n        return retVal;\n    }", "signature": "String expand(Document doc)", "full_signature": "protected String expand(Document doc)", "class_method_signature": "Preprocess.expand(Document doc)", "testcase": false, "constructor": false, "invocations": ["createTreeWalker", "nextNode", "previousNode", "hasAncestor", "hasAttribute", "hasAttribute", "tokenText", "matches", "matcher", "equals", "matches", "matcher", "matches", "matcher", "split", "setTokenText", "expandOrdinal", "matches", "getNextSiblingElement", "matches", "matcher", "tokenText", "length", "tokenText", "setTokenText", "matches", "matcher", "setTokenText", "expandDate", "matches", "matcher", "setTokenText", "expandNumberS", "matches", "matcher", "setTokenText", "expandYearBCAD", "matches", "matcher", "setTokenText", "expandYear", "parseDouble", "matches", "matcher", "setTokenText", "expandWordNumber", "matches", "matcher", "setTokenText", "expandMoney", "matches", "matcher", "equals", "setTokenText", "expandMoney", "setTokenText", "expandRealNumber", "matches", "matcher", "checkLexicon", "matcher", "find", "containsKey", "group", "setTokenText", "replaceAll", "matches", "matcher", "setTokenText", "expandAcronym", "matches", "matcher", "containsKey", "toLowerCase", "getNextSiblingElement", "isUpperCase", "charAt", "tokenText", "setTokenText", "expandAbbreviation", "matches", "matcher", "setTokenText", "expandTime", "matches", "matcher", "setTokenText", "expandDuration", "matches", "matcher", "setTokenText", "expandHashtag", "matches", "matcher", "matcher", "find", "setTokenText", "expandURL", "group", "equals", "setTokenText", "replaceFirst", "contains", "containsKey", "setTokenText", "get", "matches", "matcher", "setTokenText", "expandRange", "contains", "contains", "split", "matches", "toCharArray", "append", "append", "expandNumber", "valueOf", "toString", "setTokenText", "replaceAll", "toString", "matches", "matcher", "checkLexicon", "setTokenText", "expandConsonants", "find", "matcher", "length", "split", "setTokenText", "replaceAll", "toString", "equals", "matches", "matcher", "setAttribute", "tokenText", "equals", "tokenText", "encloseWithMTU", "split", "replaceAll", "tokenText", "setTokenText", "requireNonNull", "appendToken", "getNextSiblingElement", "matches", "substring", "length", "get", "setAttribute", "get", "setAttribute", "get", "setCurrentNode", "previousNode"]}, "repository": {"repo_id": 3020895, "url": "https://github.com/marytts/marytts", "language": "Java", "is_fork": false, "fork_count": 603, "stargazer_count": 1478, "size": 149475, "license": "licensed"}}