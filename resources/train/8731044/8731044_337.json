{"test_class": {"identifier": "NodeUtilTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String FIRST_CHILD = \"1\";", "modifier": "private static final", "type": "String", "declarator": "FIRST_CHILD = \"1\"", "var_name": "FIRST_CHILD"}, {"original_string": "private static final String SECOND_CHILD = \"2\";", "modifier": "private static final", "type": "String", "declarator": "SECOND_CHILD = \"2\"", "var_name": "SECOND_CHILD"}, {"original_string": "private static final String THIRD_CHILD = \"3\";", "modifier": "private static final", "type": "String", "declarator": "THIRD_CHILD = \"3\"", "var_name": "THIRD_CHILD"}, {"original_string": "private MockNode root;", "modifier": "private", "type": "MockNode", "declarator": "root", "var_name": "root"}, {"original_string": "private Node first;", "modifier": "private", "type": "Node", "declarator": "first", "var_name": "first"}, {"original_string": "private Node second;", "modifier": "private", "type": "Node", "declarator": "second", "var_name": "second"}, {"original_string": "private Node third;", "modifier": "private", "type": "Node", "declarator": "third", "var_name": "third"}], "file": "magnolia-core/src/test/java/info/magnolia/jcr/util/NodeUtilTest.java"}, "test_case": {"identifier": "testGetSiblings", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetSiblings() throws RepositoryException {\n        // GIVEN\n        Node subFirst0 = first.addNode(\"subFirst0\", NodeTypes.Area.NAME);\n        Node subFirst1 = first.addNode(\"subFirst1\", NodeTypes.Component.NAME);\n        Node subFirst2 = first.addNode(\"subFirst2\", NodeTypes.Area.NAME);\n        Node subFirst3 = first.addNode(\"subFirst3\", NodeTypes.Component.NAME);\n        Node subFirst4 = second.addNode(\"subSecond0\");\n        Iterator<Node> iterator;\n\n        // WHEN\n        iterator = NodeUtil.getSiblings(subFirst0).iterator();\n        // THEN\n        assertEquals(subFirst1, iterator.next());\n        assertEquals(subFirst2, iterator.next());\n        assertEquals(subFirst3, iterator.next());\n        assertFalse(iterator.hasNext());\n\n        // WHEN\n        iterator = NodeUtil.getSiblings(subFirst1).iterator();\n        // THEN\n        assertEquals(subFirst0, iterator.next());\n        assertEquals(subFirst2, iterator.next());\n        assertEquals(subFirst3, iterator.next());\n        assertFalse(iterator.hasNext());\n\n        // WHEN\n        iterator = NodeUtil.getSiblings(subFirst2).iterator();\n        // THEN\n        assertEquals(subFirst0, iterator.next());\n        assertEquals(subFirst1, iterator.next());\n        assertEquals(subFirst3, iterator.next());\n        assertFalse(iterator.hasNext());\n\n        // WHEN\n        iterator = NodeUtil.getSiblings(subFirst3).iterator();\n        // THEN\n        assertEquals(subFirst0, iterator.next());\n        assertEquals(subFirst1, iterator.next());\n        assertEquals(subFirst2, iterator.next());\n        assertFalse(iterator.hasNext());\n\n        // WHEN\n        iterator = NodeUtil.getSiblings(subFirst4).iterator();\n        // THEN\n        assertFalse(iterator.hasNext());\n    }", "signature": "void testGetSiblings()", "full_signature": "@Test public void testGetSiblings()", "class_method_signature": "NodeUtilTest.testGetSiblings()", "testcase": true, "constructor": false, "invocations": ["addNode", "addNode", "addNode", "addNode", "addNode", "iterator", "getSiblings", "assertEquals", "next", "assertEquals", "next", "assertEquals", "next", "assertFalse", "hasNext", "iterator", "getSiblings", "assertEquals", "next", "assertEquals", "next", "assertEquals", "next", "assertFalse", "hasNext", "iterator", "getSiblings", "assertEquals", "next", "assertEquals", "next", "assertEquals", "next", "assertFalse", "hasNext", "iterator", "getSiblings", "assertEquals", "next", "assertEquals", "next", "assertEquals", "next", "assertFalse", "hasNext", "iterator", "getSiblings", "assertFalse", "hasNext"]}, "focal_class": {"identifier": "NodeUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(NodeUtil.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(NodeUtil.class)", "var_name": "log"}, {"original_string": "public static AbstractPredicate<Property> ALL_PROPERTIES_EXCEPT_JCR_AND_MGNL_FILTER = new AbstractPredicate<Property>() {\n\n        @Override\n        public boolean evaluateTyped(Property property) {\n            try {\n                String name = property.getName();\n                return !name.startsWith(NodeTypes.JCR_PREFIX) && !name.startsWith(NodeTypes.MGNL_PREFIX);\n            } catch (RepositoryException e) {\n                String path;\n                try {\n                    path = property.getPath();\n                } catch (RepositoryException e1) {\n                    path = \"<path not available>\";\n                }\n                log.error(\"Unable to read name of property {}\", path);\n                // either invalid or not accessible to the current user\n                return false;\n            }\n        }\n    };", "modifier": "public static", "type": "AbstractPredicate<Property>", "declarator": "ALL_PROPERTIES_EXCEPT_JCR_AND_MGNL_FILTER = new AbstractPredicate<Property>() {\n\n        @Override\n        public boolean evaluateTyped(Property property) {\n            try {\n                String name = property.getName();\n                return !name.startsWith(NodeTypes.JCR_PREFIX) && !name.startsWith(NodeTypes.MGNL_PREFIX);\n            } catch (RepositoryException e) {\n                String path;\n                try {\n                    path = property.getPath();\n                } catch (RepositoryException e1) {\n                    path = \"<path not available>\";\n                }\n                log.error(\"Unable to read name of property {}\", path);\n                // either invalid or not accessible to the current user\n                return false;\n            }\n        }\n    }", "var_name": "ALL_PROPERTIES_EXCEPT_JCR_AND_MGNL_FILTER"}, {"original_string": "public static Predicate ALL_NODES_EXCEPT_JCR_FILTER = new AbstractPredicate<Node>() {\n        @Override\n        public boolean evaluateTyped(Node node) {\n            try {\n                return !node.getName().startsWith(NodeTypes.JCR_PREFIX);\n            } catch (RepositoryException e) {\n                log.error(\"Unable to read name for node {}\", getNodePathIfPossible(node));\n                return false;\n            }\n        }\n    };", "modifier": "public static", "type": "Predicate", "declarator": "ALL_NODES_EXCEPT_JCR_FILTER = new AbstractPredicate<Node>() {\n        @Override\n        public boolean evaluateTyped(Node node) {\n            try {\n                return !node.getName().startsWith(NodeTypes.JCR_PREFIX);\n            } catch (RepositoryException e) {\n                log.error(\"Unable to read name for node {}\", getNodePathIfPossible(node));\n                return false;\n            }\n        }\n    }", "var_name": "ALL_NODES_EXCEPT_JCR_FILTER"}, {"original_string": "public static AbstractPredicate<Node> EXCLUDE_META_DATA_FILTER = new AbstractPredicate<Node>() {\n\n        @Override\n        public boolean evaluateTyped(Node node) {\n            try {\n                return !node.getName().startsWith(NodeTypes.JCR_PREFIX)\n                && !NodeUtil.isNodeType(node, NodeTypes.MetaData.NAME);\n            } catch (RepositoryException e) {\n                log.error(\"Unable to read name or nodeType for node {}\", getNodePathIfPossible(node));\n                return false;\n            }\n        }\n    };", "modifier": "public static", "type": "AbstractPredicate<Node>", "declarator": "EXCLUDE_META_DATA_FILTER = new AbstractPredicate<Node>() {\n\n        @Override\n        public boolean evaluateTyped(Node node) {\n            try {\n                return !node.getName().startsWith(NodeTypes.JCR_PREFIX)\n                && !NodeUtil.isNodeType(node, NodeTypes.MetaData.NAME);\n            } catch (RepositoryException e) {\n                log.error(\"Unable to read name or nodeType for node {}\", getNodePathIfPossible(node));\n                return false;\n            }\n        }\n    }", "var_name": "EXCLUDE_META_DATA_FILTER"}, {"original_string": "public static AbstractPredicate<Node> MAGNOLIA_FILTER = new AbstractPredicate<Node>() {\n\n        @Override\n        public boolean evaluateTyped(Node node) {\n\n            try {\n                String nodeTypeName = node.getPrimaryNodeType().getName();\n                // accept only \"magnolia\" nodes\n                return nodeTypeName.startsWith(NodeTypes.MGNL_PREFIX);\n            } catch (RepositoryException e) {\n                log.error(\"Unable to read nodeType for node {}\", getNodePathIfPossible(node));\n            }\n            return false;\n        }\n    };", "modifier": "public static", "type": "AbstractPredicate<Node>", "declarator": "MAGNOLIA_FILTER = new AbstractPredicate<Node>() {\n\n        @Override\n        public boolean evaluateTyped(Node node) {\n\n            try {\n                String nodeTypeName = node.getPrimaryNodeType().getName();\n                // accept only \"magnolia\" nodes\n                return nodeTypeName.startsWith(NodeTypes.MGNL_PREFIX);\n            } catch (RepositoryException e) {\n                log.error(\"Unable to read nodeType for node {}\", getNodePathIfPossible(node));\n            }\n            return false;\n        }\n    }", "var_name": "MAGNOLIA_FILTER"}], "methods": [{"identifier": "getNodeByIdentifier", "parameters": "(String workspace, String identifier)", "modifiers": "public static", "return": "Node", "signature": "Node getNodeByIdentifier(String workspace, String identifier)", "full_signature": "public static Node getNodeByIdentifier(String workspace, String identifier)", "class_method_signature": "NodeUtil.getNodeByIdentifier(String workspace, String identifier)", "testcase": false, "constructor": false}, {"identifier": "hasMixin", "parameters": "(Node node, String mixinName)", "modifiers": "public static", "return": "boolean", "signature": "boolean hasMixin(Node node, String mixinName)", "full_signature": "public static boolean hasMixin(Node node, String mixinName)", "class_method_signature": "NodeUtil.hasMixin(Node node, String mixinName)", "testcase": false, "constructor": false}, {"identifier": "isNodeType", "parameters": "(Node node, String type)", "modifiers": "public static", "return": "boolean", "signature": "boolean isNodeType(Node node, String type)", "full_signature": "public static boolean isNodeType(Node node, String type)", "class_method_signature": "NodeUtil.isNodeType(Node node, String type)", "testcase": false, "constructor": false}, {"identifier": "unwrap", "parameters": "(Node node)", "modifiers": "public static", "return": "Node", "signature": "Node unwrap(Node node)", "full_signature": "public static Node unwrap(Node node)", "class_method_signature": "NodeUtil.unwrap(Node node)", "testcase": false, "constructor": false}, {"identifier": "deepUnwrap", "parameters": "(Node node, Class<? extends DelegateNodeWrapper> wrapper)", "modifiers": "public static", "return": "Node", "signature": "Node deepUnwrap(Node node, Class<? extends DelegateNodeWrapper> wrapper)", "full_signature": "public static Node deepUnwrap(Node node, Class<? extends DelegateNodeWrapper> wrapper)", "class_method_signature": "NodeUtil.deepUnwrap(Node node, Class<? extends DelegateNodeWrapper> wrapper)", "testcase": false, "constructor": false}, {"identifier": "deepUnwrapAll", "parameters": "(Node node, Class<? extends DelegateNodeWrapper> wrapperClass)", "modifiers": "public static", "return": "Node", "signature": "Node deepUnwrapAll(Node node, Class<? extends DelegateNodeWrapper> wrapperClass)", "full_signature": "public static Node deepUnwrapAll(Node node, Class<? extends DelegateNodeWrapper> wrapperClass)", "class_method_signature": "NodeUtil.deepUnwrapAll(Node node, Class<? extends DelegateNodeWrapper> wrapperClass)", "testcase": false, "constructor": false}, {"identifier": "isWrappedWith", "parameters": "(Node node, Class<? extends DelegateNodeWrapper> wrapper)", "modifiers": "public static", "return": "boolean", "signature": "boolean isWrappedWith(Node node, Class<? extends DelegateNodeWrapper> wrapper)", "full_signature": "public static boolean isWrappedWith(Node node, Class<? extends DelegateNodeWrapper> wrapper)", "class_method_signature": "NodeUtil.isWrappedWith(Node node, Class<? extends DelegateNodeWrapper> wrapper)", "testcase": false, "constructor": false}, {"identifier": "orderBefore", "parameters": "(Node node, String siblingName)", "modifiers": "public static", "return": "void", "signature": "void orderBefore(Node node, String siblingName)", "full_signature": "public static void orderBefore(Node node, String siblingName)", "class_method_signature": "NodeUtil.orderBefore(Node node, String siblingName)", "testcase": false, "constructor": false}, {"identifier": "orderAfter", "parameters": "(Node node, String siblingName)", "modifiers": "public static", "return": "void", "signature": "void orderAfter(Node node, String siblingName)", "full_signature": "public static void orderAfter(Node node, String siblingName)", "class_method_signature": "NodeUtil.orderAfter(Node node, String siblingName)", "testcase": false, "constructor": false}, {"identifier": "orderFirst", "parameters": "(Node node)", "modifiers": "public static", "return": "void", "signature": "void orderFirst(Node node)", "full_signature": "public static void orderFirst(Node node)", "class_method_signature": "NodeUtil.orderFirst(Node node)", "testcase": false, "constructor": false}, {"identifier": "orderLast", "parameters": "(Node node)", "modifiers": "public static", "return": "void", "signature": "void orderLast(Node node)", "full_signature": "public static void orderLast(Node node)", "class_method_signature": "NodeUtil.orderLast(Node node)", "testcase": false, "constructor": false}, {"identifier": "orderNodeUp", "parameters": "(Node node)", "modifiers": "public static", "return": "void", "signature": "void orderNodeUp(Node node)", "full_signature": "public static void orderNodeUp(Node node)", "class_method_signature": "NodeUtil.orderNodeUp(Node node)", "testcase": false, "constructor": false}, {"identifier": "orderNodeDown", "parameters": "(Node node)", "modifiers": "public static", "return": "void", "signature": "void orderNodeDown(Node node)", "full_signature": "public static void orderNodeDown(Node node)", "class_method_signature": "NodeUtil.orderNodeDown(Node node)", "testcase": false, "constructor": false}, {"identifier": "getSiblingBefore", "parameters": "(Node node)", "modifiers": "public static", "return": "Node", "signature": "Node getSiblingBefore(Node node)", "full_signature": "public static Node getSiblingBefore(Node node)", "class_method_signature": "NodeUtil.getSiblingBefore(Node node)", "testcase": false, "constructor": false}, {"identifier": "getSiblingAfter", "parameters": "(Node node)", "modifiers": "public static", "return": "Node", "signature": "Node getSiblingAfter(Node node)", "full_signature": "public static Node getSiblingAfter(Node node)", "class_method_signature": "NodeUtil.getSiblingAfter(Node node)", "testcase": false, "constructor": false}, {"identifier": "getSiblings", "parameters": "(Node node)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> getSiblings(Node node)", "full_signature": "public static Iterable<Node> getSiblings(Node node)", "class_method_signature": "NodeUtil.getSiblings(Node node)", "testcase": false, "constructor": false}, {"identifier": "getSiblings", "parameters": "(Node node, String nodeTypeName)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> getSiblings(Node node, String nodeTypeName)", "full_signature": "public static Iterable<Node> getSiblings(Node node, String nodeTypeName)", "class_method_signature": "NodeUtil.getSiblings(Node node, String nodeTypeName)", "testcase": false, "constructor": false}, {"identifier": "getSiblings", "parameters": "(Node node, Predicate predicate)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> getSiblings(Node node, Predicate predicate)", "full_signature": "public static Iterable<Node> getSiblings(Node node, Predicate predicate)", "class_method_signature": "NodeUtil.getSiblings(Node node, Predicate predicate)", "testcase": false, "constructor": false}, {"identifier": "getSiblingsBefore", "parameters": "(Node node)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> getSiblingsBefore(Node node)", "full_signature": "public static Iterable<Node> getSiblingsBefore(Node node)", "class_method_signature": "NodeUtil.getSiblingsBefore(Node node)", "testcase": false, "constructor": false}, {"identifier": "getSiblingsAfter", "parameters": "(Node node)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> getSiblingsAfter(Node node)", "full_signature": "public static Iterable<Node> getSiblingsAfter(Node node)", "class_method_signature": "NodeUtil.getSiblingsAfter(Node node)", "testcase": false, "constructor": false}, {"identifier": "getSiblingsBefore", "parameters": "(Node node, String nodeTypeName)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> getSiblingsBefore(Node node, String nodeTypeName)", "full_signature": "public static Iterable<Node> getSiblingsBefore(Node node, String nodeTypeName)", "class_method_signature": "NodeUtil.getSiblingsBefore(Node node, String nodeTypeName)", "testcase": false, "constructor": false}, {"identifier": "getSiblingsAfter", "parameters": "(Node node, String nodeTypeName)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> getSiblingsAfter(Node node, String nodeTypeName)", "full_signature": "public static Iterable<Node> getSiblingsAfter(Node node, String nodeTypeName)", "class_method_signature": "NodeUtil.getSiblingsAfter(Node node, String nodeTypeName)", "testcase": false, "constructor": false}, {"identifier": "moveNode", "parameters": "(Node nodeToMove, Node newParent)", "modifiers": "public static", "return": "void", "signature": "void moveNode(Node nodeToMove, Node newParent)", "full_signature": "public static void moveNode(Node nodeToMove, Node newParent)", "class_method_signature": "NodeUtil.moveNode(Node nodeToMove, Node newParent)", "testcase": false, "constructor": false}, {"identifier": "moveNodeBefore", "parameters": "(Node nodeToMove, Node target)", "modifiers": "public static", "return": "void", "signature": "void moveNodeBefore(Node nodeToMove, Node target)", "full_signature": "public static void moveNodeBefore(Node nodeToMove, Node target)", "class_method_signature": "NodeUtil.moveNodeBefore(Node nodeToMove, Node target)", "testcase": false, "constructor": false}, {"identifier": "moveNodeAfter", "parameters": "(Node nodeToMove, Node target)", "modifiers": "public static", "return": "void", "signature": "void moveNodeAfter(Node nodeToMove, Node target)", "full_signature": "public static void moveNodeAfter(Node nodeToMove, Node target)", "class_method_signature": "NodeUtil.moveNodeAfter(Node nodeToMove, Node target)", "testcase": false, "constructor": false}, {"identifier": "isFirstSibling", "parameters": "(Node node)", "modifiers": "public static", "return": "boolean", "signature": "boolean isFirstSibling(Node node)", "full_signature": "public static boolean isFirstSibling(Node node)", "class_method_signature": "NodeUtil.isFirstSibling(Node node)", "testcase": false, "constructor": false}, {"identifier": "isSameNameSiblings", "parameters": "(Node node1, Node node2)", "modifiers": "public static", "return": "boolean", "signature": "boolean isSameNameSiblings(Node node1, Node node2)", "full_signature": "public static boolean isSameNameSiblings(Node node1, Node node2)", "class_method_signature": "NodeUtil.isSameNameSiblings(Node node1, Node node2)", "testcase": false, "constructor": false}, {"identifier": "isLastSibling", "parameters": "(Node node)", "modifiers": "public static", "return": "boolean", "signature": "boolean isLastSibling(Node node)", "full_signature": "public static boolean isLastSibling(Node node)", "class_method_signature": "NodeUtil.isLastSibling(Node node)", "testcase": false, "constructor": false}, {"identifier": "renameNode", "parameters": "(Node node, String newName)", "modifiers": "public static", "return": "void", "signature": "void renameNode(Node node, String newName)", "full_signature": "public static void renameNode(Node node, String newName)", "class_method_signature": "NodeUtil.renameNode(Node node, String newName)", "testcase": false, "constructor": false}, {"identifier": "isGranted", "parameters": "(Node node, long permissions)", "modifiers": "public static", "return": "boolean", "signature": "boolean isGranted(Node node, long permissions)", "full_signature": "public static boolean isGranted(Node node, long permissions)", "class_method_signature": "NodeUtil.isGranted(Node node, long permissions)", "testcase": false, "constructor": false}, {"identifier": "isSame", "parameters": "(Node lhs, Node rhs)", "modifiers": "public static", "return": "boolean", "signature": "boolean isSame(Node lhs, Node rhs)", "full_signature": "public static boolean isSame(Node lhs, Node rhs)", "class_method_signature": "NodeUtil.isSame(Node lhs, Node rhs)", "testcase": false, "constructor": false}, {"identifier": "combinePathAndName", "parameters": "(String path, String name)", "modifiers": "public static", "return": "String", "signature": "String combinePathAndName(String path, String name)", "full_signature": "public static String combinePathAndName(String path, String name)", "class_method_signature": "NodeUtil.combinePathAndName(String path, String name)", "testcase": false, "constructor": false}, {"identifier": "createPath", "parameters": "(Node parent, String relPath, String primaryNodeTypeName)", "modifiers": "public static", "return": "Node", "signature": "Node createPath(Node parent, String relPath, String primaryNodeTypeName)", "full_signature": "public static Node createPath(Node parent, String relPath, String primaryNodeTypeName)", "class_method_signature": "NodeUtil.createPath(Node parent, String relPath, String primaryNodeTypeName)", "testcase": false, "constructor": false}, {"identifier": "createPath", "parameters": "(Node parent, String relPath, String primaryNodeTypeName, boolean save)", "modifiers": "public static", "return": "Node", "signature": "Node createPath(Node parent, String relPath, String primaryNodeTypeName, boolean save)", "full_signature": "public static Node createPath(Node parent, String relPath, String primaryNodeTypeName, boolean save)", "class_method_signature": "NodeUtil.createPath(Node parent, String relPath, String primaryNodeTypeName, boolean save)", "testcase": false, "constructor": false}, {"identifier": "visit", "parameters": "(Node node, NodeVisitor visitor)", "modifiers": "public static", "return": "void", "signature": "void visit(Node node, NodeVisitor visitor)", "full_signature": "public static void visit(Node node, NodeVisitor visitor)", "class_method_signature": "NodeUtil.visit(Node node, NodeVisitor visitor)", "testcase": false, "constructor": false}, {"identifier": "visit", "parameters": "(Node node, NodeVisitor visitor, Predicate predicate)", "modifiers": "public static", "return": "void", "signature": "void visit(Node node, NodeVisitor visitor, Predicate predicate)", "full_signature": "public static void visit(Node node, NodeVisitor visitor, Predicate predicate)", "class_method_signature": "NodeUtil.visit(Node node, NodeVisitor visitor, Predicate predicate)", "testcase": false, "constructor": false}, {"identifier": "getNodes", "parameters": "(Node parent, Predicate predicate)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> getNodes(Node parent, Predicate predicate)", "full_signature": "public static Iterable<Node> getNodes(Node parent, Predicate predicate)", "class_method_signature": "NodeUtil.getNodes(Node parent, Predicate predicate)", "testcase": false, "constructor": false}, {"identifier": "getNodes", "parameters": "(Node parent)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> getNodes(Node parent)", "full_signature": "public static Iterable<Node> getNodes(Node parent)", "class_method_signature": "NodeUtil.getNodes(Node parent)", "testcase": false, "constructor": false}, {"identifier": "getNodes", "parameters": "(Node parent, String nodeTypeName)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> getNodes(Node parent, String nodeTypeName)", "full_signature": "public static Iterable<Node> getNodes(Node parent, String nodeTypeName)", "class_method_signature": "NodeUtil.getNodes(Node parent, String nodeTypeName)", "testcase": false, "constructor": false}, {"identifier": "asIterable", "parameters": "(NodeIterator iterator)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> asIterable(NodeIterator iterator)", "full_signature": "public static Iterable<Node> asIterable(NodeIterator iterator)", "class_method_signature": "NodeUtil.asIterable(NodeIterator iterator)", "testcase": false, "constructor": false}, {"identifier": "asList", "parameters": "(Iterable<Node> nodes)", "modifiers": "public static", "return": "List<Node>", "signature": "List<Node> asList(Iterable<Node> nodes)", "full_signature": "public static List<Node> asList(Iterable<Node> nodes)", "class_method_signature": "NodeUtil.asList(Iterable<Node> nodes)", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "(Node content)", "modifiers": "public static", "return": "String", "signature": "String getName(Node content)", "full_signature": "public static String getName(Node content)", "class_method_signature": "NodeUtil.getName(Node content)", "testcase": false, "constructor": false}, {"identifier": "collectAllChildren", "parameters": "(Node node)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> collectAllChildren(Node node)", "full_signature": "public static Iterable<Node> collectAllChildren(Node node)", "class_method_signature": "NodeUtil.collectAllChildren(Node node)", "testcase": false, "constructor": false}, {"identifier": "collectAllChildren", "parameters": "(Node node, Predicate predicate)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> collectAllChildren(Node node, Predicate predicate)", "full_signature": "public static Iterable<Node> collectAllChildren(Node node, Predicate predicate)", "class_method_signature": "NodeUtil.collectAllChildren(Node node, Predicate predicate)", "testcase": false, "constructor": false}, {"identifier": "collectAllChildren", "parameters": "(List<Node> nodes, Node parent, Predicate predicate)", "modifiers": "public static", "return": "Iterable<Node>", "signature": "Iterable<Node> collectAllChildren(List<Node> nodes, Node parent, Predicate predicate)", "full_signature": "public static Iterable<Node> collectAllChildren(List<Node> nodes, Node parent, Predicate predicate)", "class_method_signature": "NodeUtil.collectAllChildren(List<Node> nodes, Node parent, Predicate predicate)", "testcase": false, "constructor": false}, {"identifier": "getAncestors", "parameters": "(Node node)", "modifiers": "public static", "return": "Collection<Node>", "signature": "Collection<Node> getAncestors(Node node)", "full_signature": "public static Collection<Node> getAncestors(Node node)", "class_method_signature": "NodeUtil.getAncestors(Node node)", "testcase": false, "constructor": false}, {"identifier": "getNodeIdentifierIfPossible", "parameters": "(Node content)", "modifiers": "public static", "return": "String", "signature": "String getNodeIdentifierIfPossible(Node content)", "full_signature": "public static String getNodeIdentifierIfPossible(Node content)", "class_method_signature": "NodeUtil.getNodeIdentifierIfPossible(Node content)", "testcase": false, "constructor": false}, {"identifier": "getNodePathIfPossible", "parameters": "(Node node)", "modifiers": "public static", "return": "String", "signature": "String getNodePathIfPossible(Node node)", "full_signature": "public static String getNodePathIfPossible(Node node)", "class_method_signature": "NodeUtil.getNodePathIfPossible(Node node)", "testcase": false, "constructor": false}, {"identifier": "getPathIfPossible", "parameters": "(Node node)", "modifiers": "public static", "return": "String", "signature": "String getPathIfPossible(Node node)", "full_signature": "public static String getPathIfPossible(Node node)", "class_method_signature": "NodeUtil.getPathIfPossible(Node node)", "testcase": false, "constructor": false}, {"identifier": "filterNodeType", "parameters": "(NodeIterator iterator, String nodeType)", "modifiers": "public static", "return": "NodeIterator", "signature": "NodeIterator filterNodeType(NodeIterator iterator, String nodeType)", "full_signature": "public static NodeIterator filterNodeType(NodeIterator iterator, String nodeType)", "class_method_signature": "NodeUtil.filterNodeType(NodeIterator iterator, String nodeType)", "testcase": false, "constructor": false}, {"identifier": "filterDuplicates", "parameters": "(NodeIterator iterator)", "modifiers": "public static", "return": "NodeIterator", "signature": "NodeIterator filterDuplicates(NodeIterator iterator)", "full_signature": "public static NodeIterator filterDuplicates(NodeIterator iterator)", "class_method_signature": "NodeUtil.filterDuplicates(NodeIterator iterator)", "testcase": false, "constructor": false}, {"identifier": "filterParentNodeType", "parameters": "(NodeIterator iterator, final String nodeType)", "modifiers": "public static", "return": "NodeIterator", "signature": "NodeIterator filterParentNodeType(NodeIterator iterator, final String nodeType)", "full_signature": "public static NodeIterator filterParentNodeType(NodeIterator iterator, final String nodeType)", "class_method_signature": "NodeUtil.filterParentNodeType(NodeIterator iterator, final String nodeType)", "testcase": false, "constructor": false}, {"identifier": "getCollectionFromNodeIterator", "parameters": "(NodeIterator iterator)", "modifiers": "public static", "return": "Collection<Node>", "signature": "Collection<Node> getCollectionFromNodeIterator(NodeIterator iterator)", "full_signature": "public static Collection<Node> getCollectionFromNodeIterator(NodeIterator iterator)", "class_method_signature": "NodeUtil.getCollectionFromNodeIterator(NodeIterator iterator)", "testcase": false, "constructor": false}, {"identifier": "getSortedCollectionFromNodeIterator", "parameters": "(NodeIterator iterator)", "modifiers": "public static", "return": "Collection<Node>", "signature": "Collection<Node> getSortedCollectionFromNodeIterator(NodeIterator iterator)", "full_signature": "public static Collection<Node> getSortedCollectionFromNodeIterator(NodeIterator iterator)", "class_method_signature": "NodeUtil.getSortedCollectionFromNodeIterator(NodeIterator iterator)", "testcase": false, "constructor": false}, {"identifier": "traceNodeProperties", "parameters": "(Node nodeOp)", "modifiers": "public static", "return": "void", "signature": "void traceNodeProperties(Node nodeOp)", "full_signature": "public static void traceNodeProperties(Node nodeOp)", "class_method_signature": "NodeUtil.traceNodeProperties(Node nodeOp)", "testcase": false, "constructor": false}, {"identifier": "traceNodeChildren", "parameters": "(Node nodeOp)", "modifiers": "public static", "return": "void", "signature": "void traceNodeChildren(Node nodeOp)", "full_signature": "public static void traceNodeChildren(Node nodeOp)", "class_method_signature": "NodeUtil.traceNodeChildren(Node nodeOp)", "testcase": false, "constructor": false}, {"identifier": "upToNCharacters", "parameters": "(String s, int n)", "modifiers": "private static", "return": "String", "signature": "String upToNCharacters(String s, int n)", "full_signature": "private static String upToNCharacters(String s, int n)", "class_method_signature": "NodeUtil.upToNCharacters(String s, int n)", "testcase": false, "constructor": false}], "file": "magnolia-core/src/main/java/info/magnolia/jcr/util/NodeUtil.java"}, "focal_method": {"identifier": "getSiblings", "parameters": "(Node node)", "modifiers": "public static", "return": "Iterable<Node>", "body": "public static Iterable<Node> getSiblings(Node node) throws RepositoryException {\n        Node parent = node.getParent();\n        Iterable<Node> allSiblings = NodeUtil.getNodes(parent);\n        List<Node> siblings = new ArrayList<Node>();\n\n        for(Node sibling: allSiblings) {\n            if (!NodeUtil.isSame(node, sibling)) {\n                siblings.add(sibling);\n            }\n        }\n        return siblings;\n    }", "signature": "Iterable<Node> getSiblings(Node node)", "full_signature": "public static Iterable<Node> getSiblings(Node node)", "class_method_signature": "NodeUtil.getSiblings(Node node)", "testcase": false, "constructor": false, "invocations": ["getParent", "getNodes", "isSame", "add"]}, "repository": {"repo_id": 8731044, "url": "https://github.com/ekirkilevics/Magnolia", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 5, "size": 133884, "license": "licensed"}}