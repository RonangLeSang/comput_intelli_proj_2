{"test_class": {"identifier": "TestComputeRays", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(TestComputeRays.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(TestComputeRays.class)", "var_name": "LOGGER"}, {"original_string": "private boolean storeGeoJSONRays = false;", "modifier": "private", "type": "boolean", "declarator": "storeGeoJSONRays = false", "var_name": "storeGeoJSONRays"}], "file": "noisemodelling-propagation/src/test/java/org/noise_planet/noisemodelling/propagation/TestComputeRays.java"}, "test_case": {"identifier": "TestSplitRegression", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void TestSplitRegression() throws ParseException {\n        LineString geom = (LineString)new WKTReader().read(\"LINESTRING (26.3 175.5 0.0000034909259558, 111.9 90.9 0, 123 -70.9 0, 345.2 -137.8 0)\");\n        double constraint = 82.98581729762442;\n        List<Coordinate> pts = new ArrayList<>();\n        ComputeRays.splitLineStringIntoPoints(geom, constraint, pts);\n        for(Coordinate pt : pts) {\n            assertNotNull(pt);\n        }\n        assertEquals(7, pts.size());\n    }", "signature": "void TestSplitRegression()", "full_signature": "@Test public void TestSplitRegression()", "class_method_signature": "TestComputeRays.TestSplitRegression()", "testcase": true, "constructor": false, "invocations": ["read", "splitLineStringIntoPoints", "assertNotNull", "assertEquals", "size"]}, "focal_class": {"identifier": "ComputeRays", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final static double MAX_RATIO_HULL_DIRECT_PATH = 4;", "modifier": "private final static", "type": "double", "declarator": "MAX_RATIO_HULL_DIRECT_PATH = 4", "var_name": "MAX_RATIO_HULL_DIRECT_PATH"}, {"original_string": "private int threadCount;", "modifier": "private", "type": "int", "declarator": "threadCount", "var_name": "threadCount"}, {"original_string": "private PropagationProcessData data;", "modifier": "private", "type": "PropagationProcessData", "declarator": "data", "var_name": "data"}, {"original_string": "private STRtree rTreeOfGeoSoil;", "modifier": "private", "type": "STRtree", "declarator": "rTreeOfGeoSoil", "var_name": "rTreeOfGeoSoil"}, {"original_string": "private final static Logger LOGGER = LoggerFactory.getLogger(ComputeRays.class);", "modifier": "private final static", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ComputeRays.class)", "var_name": "LOGGER"}], "methods": [{"identifier": "sumArrayWithPonderation", "parameters": "(double[] array1, double[] array2, double p)", "modifiers": "public static", "return": "double[]", "signature": "double[] sumArrayWithPonderation(double[] array1, double[] array2, double p)", "full_signature": "public static double[] sumArrayWithPonderation(double[] array1, double[] array2, double p)", "class_method_signature": "ComputeRays.sumArrayWithPonderation(double[] array1, double[] array2, double p)", "testcase": false, "constructor": false}, {"identifier": "sumDbArray", "parameters": "(double[] array1, double[] array2)", "modifiers": "public static", "return": "double[]", "signature": "double[] sumDbArray(double[] array1, double[] array2)", "full_signature": "public static double[] sumDbArray(double[] array1, double[] array2)", "class_method_signature": "ComputeRays.sumDbArray(double[] array1, double[] array2)", "testcase": false, "constructor": false}, {"identifier": "multArray", "parameters": "(double[] array1, double[] array2)", "modifiers": "public static", "return": "double[]", "signature": "double[] multArray(double[] array1, double[] array2)", "full_signature": "public static double[] multArray(double[] array1, double[] array2)", "class_method_signature": "ComputeRays.multArray(double[] array1, double[] array2)", "testcase": false, "constructor": false}, {"identifier": "sumArray", "parameters": "(int nbfreq, double energeticSum[])", "modifiers": "public static", "return": "double", "signature": "double sumArray(int nbfreq, double energeticSum[])", "full_signature": "public static double sumArray(int nbfreq, double energeticSum[])", "class_method_signature": "ComputeRays.sumArray(int nbfreq, double energeticSum[])", "testcase": false, "constructor": false}, {"identifier": "sumArray", "parameters": "(double energeticSum[])", "modifiers": "public static", "return": "double", "signature": "double sumArray(double energeticSum[])", "full_signature": "public static double sumArray(double energeticSum[])", "class_method_signature": "ComputeRays.sumArray(double energeticSum[])", "testcase": false, "constructor": false}, {"identifier": "sumArray", "parameters": "(double array1[], double array2[])", "modifiers": "public static", "return": "double[]", "signature": "double[] sumArray(double array1[], double array2[])", "full_signature": "public static double[] sumArray(double array1[], double array2[])", "class_method_signature": "ComputeRays.sumArray(double array1[], double array2[])", "testcase": false, "constructor": false}, {"identifier": "ComputeRays", "parameters": "(PropagationProcessData data)", "modifiers": "public", "return": "", "signature": " ComputeRays(PropagationProcessData data)", "full_signature": "public  ComputeRays(PropagationProcessData data)", "class_method_signature": "ComputeRays.ComputeRays(PropagationProcessData data)", "testcase": false, "constructor": true}, {"identifier": "getThreadCount", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getThreadCount()", "full_signature": "public int getThreadCount()", "class_method_signature": "ComputeRays.getThreadCount()", "testcase": false, "constructor": false}, {"identifier": "setThreadCount", "parameters": "(int threadCount)", "modifiers": "public", "return": "void", "signature": "void setThreadCount(int threadCount)", "full_signature": "public void setThreadCount(int threadCount)", "class_method_signature": "ComputeRays.setThreadCount(int threadCount)", "testcase": false, "constructor": false}, {"identifier": "makeSourceRelativeZToAbsolute", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void makeSourceRelativeZToAbsolute()", "full_signature": "public void makeSourceRelativeZToAbsolute()", "class_method_signature": "ComputeRays.makeSourceRelativeZToAbsolute()", "testcase": false, "constructor": false}, {"identifier": "makeRelativeZToAbsolute", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void makeRelativeZToAbsolute()", "full_signature": "public void makeRelativeZToAbsolute()", "class_method_signature": "ComputeRays.makeRelativeZToAbsolute()", "testcase": false, "constructor": false}, {"identifier": "makeReceiverRelativeZToAbsolute", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void makeReceiverRelativeZToAbsolute()", "full_signature": "public void makeReceiverRelativeZToAbsolute()", "class_method_signature": "ComputeRays.makeReceiverRelativeZToAbsolute()", "testcase": false, "constructor": false}, {"identifier": "dbaToW", "parameters": "(double dBA)", "modifiers": "public static", "return": "double", "signature": "double dbaToW(double dBA)", "full_signature": "public static double dbaToW(double dBA)", "class_method_signature": "ComputeRays.dbaToW(double dBA)", "testcase": false, "constructor": false}, {"identifier": "dbaToW", "parameters": "(double[] dBA)", "modifiers": "public static", "return": "double[]", "signature": "double[] dbaToW(double[] dBA)", "full_signature": "public static double[] dbaToW(double[] dBA)", "class_method_signature": "ComputeRays.dbaToW(double[] dBA)", "testcase": false, "constructor": false}, {"identifier": "wToDba", "parameters": "(double w)", "modifiers": "public static", "return": "double", "signature": "double wToDba(double w)", "full_signature": "public static double wToDba(double w)", "class_method_signature": "ComputeRays.wToDba(double w)", "testcase": false, "constructor": false}, {"identifier": "wToDba", "parameters": "(double[] w)", "modifiers": "public static", "return": "double[]", "signature": "double[] wToDba(double[] w)", "full_signature": "public static double[] wToDba(double[] w)", "class_method_signature": "ComputeRays.wToDba(double[] w)", "testcase": false, "constructor": false}, {"identifier": "splitLineStringIntoPoints", "parameters": "(LineString geom, double segmentSizeConstraint,\n                                             List<Coordinate> pts)", "modifiers": "public static", "return": "double", "signature": "double splitLineStringIntoPoints(LineString geom, double segmentSizeConstraint,\n                                             List<Coordinate> pts)", "full_signature": "public static double splitLineStringIntoPoints(LineString geom, double segmentSizeConstraint,\n                                             List<Coordinate> pts)", "class_method_signature": "ComputeRays.splitLineStringIntoPoints(LineString geom, double segmentSizeConstraint,\n                                             List<Coordinate> pts)", "testcase": false, "constructor": false}, {"identifier": "computeReflexionOverBuildings", "parameters": "(Coordinate p0, Coordinate p1, List<PointPath> points, List<SegmentPath> segments, List<SegmentPath> srPath)", "modifiers": "public", "return": "void", "signature": "void computeReflexionOverBuildings(Coordinate p0, Coordinate p1, List<PointPath> points, List<SegmentPath> segments, List<SegmentPath> srPath)", "full_signature": "public void computeReflexionOverBuildings(Coordinate p0, Coordinate p1, List<PointPath> points, List<SegmentPath> segments, List<SegmentPath> srPath)", "class_method_signature": "ComputeRays.computeReflexionOverBuildings(Coordinate p0, Coordinate p1, List<PointPath> points, List<SegmentPath> segments, List<SegmentPath> srPath)", "testcase": false, "constructor": false}, {"identifier": "asWallArray", "parameters": "(MirrorReceiverResult res)", "modifiers": "public static", "return": "int[]", "signature": "int[] asWallArray(MirrorReceiverResult res)", "full_signature": "public static int[] asWallArray(MirrorReceiverResult res)", "class_method_signature": "ComputeRays.asWallArray(MirrorReceiverResult res)", "testcase": false, "constructor": false}, {"identifier": "computeReflexion", "parameters": "(Coordinate receiverCoord,\n                                            Coordinate srcCoord, boolean favorable, List<FastObstructionTest.Wall> nearBuildingsWalls)", "modifiers": "public", "return": "List<PropagationPath>", "signature": "List<PropagationPath> computeReflexion(Coordinate receiverCoord,\n                                            Coordinate srcCoord, boolean favorable, List<FastObstructionTest.Wall> nearBuildingsWalls)", "full_signature": "public List<PropagationPath> computeReflexion(Coordinate receiverCoord,\n                                            Coordinate srcCoord, boolean favorable, List<FastObstructionTest.Wall> nearBuildingsWalls)", "class_method_signature": "ComputeRays.computeReflexion(Coordinate receiverCoord,\n                                            Coordinate srcCoord, boolean favorable, List<FastObstructionTest.Wall> nearBuildingsWalls)", "testcase": false, "constructor": false}, {"identifier": "removeDuplicates", "parameters": "(List<Coordinate> coordinates)", "modifiers": "private static", "return": "List<Coordinate>", "signature": "List<Coordinate> removeDuplicates(List<Coordinate> coordinates)", "full_signature": "private static List<Coordinate> removeDuplicates(List<Coordinate> coordinates)", "class_method_signature": "ComputeRays.removeDuplicates(List<Coordinate> coordinates)", "testcase": false, "constructor": false}, {"identifier": "computeFreefield", "parameters": "(Coordinate receiverCoord,\n                                            Coordinate srcCoord,List<TriIdWithIntersection> inters)", "modifiers": "public", "return": "PropagationPath", "signature": "PropagationPath computeFreefield(Coordinate receiverCoord,\n                                            Coordinate srcCoord,List<TriIdWithIntersection> inters)", "full_signature": "public PropagationPath computeFreefield(Coordinate receiverCoord,\n                                            Coordinate srcCoord,List<TriIdWithIntersection> inters)", "class_method_signature": "ComputeRays.computeFreefield(Coordinate receiverCoord,\n                                            Coordinate srcCoord,List<TriIdWithIntersection> inters)", "testcase": false, "constructor": false}, {"identifier": "computeHorizontalEdgeDiffraction", "parameters": "(boolean obstructedSourceReceiver, Coordinate receiverCoord,\n                                                            Coordinate srcCoord, List<TriIdWithIntersection> allInterPoints)", "modifiers": "public", "return": "PropagationPath", "signature": "PropagationPath computeHorizontalEdgeDiffraction(boolean obstructedSourceReceiver, Coordinate receiverCoord,\n                                                            Coordinate srcCoord, List<TriIdWithIntersection> allInterPoints)", "full_signature": "public PropagationPath computeHorizontalEdgeDiffraction(boolean obstructedSourceReceiver, Coordinate receiverCoord,\n                                                            Coordinate srcCoord, List<TriIdWithIntersection> allInterPoints)", "class_method_signature": "ComputeRays.computeHorizontalEdgeDiffraction(boolean obstructedSourceReceiver, Coordinate receiverCoord,\n                                                            Coordinate srcCoord, List<TriIdWithIntersection> allInterPoints)", "testcase": false, "constructor": false}, {"identifier": "ComputeZeroRadPlane", "parameters": "(Coordinate p0, Coordinate p1)", "modifiers": "public static", "return": "Plane", "signature": "Plane ComputeZeroRadPlane(Coordinate p0, Coordinate p1)", "full_signature": "public static Plane ComputeZeroRadPlane(Coordinate p0, Coordinate p1)", "class_method_signature": "ComputeRays.ComputeZeroRadPlane(Coordinate p0, Coordinate p1)", "testcase": false, "constructor": false}, {"identifier": "CoordinateToVector", "parameters": "(Coordinate p)", "modifiers": "public static", "return": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D", "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D CoordinateToVector(Coordinate p)", "full_signature": "public static org.apache.commons.math3.geometry.euclidean.threed.Vector3D CoordinateToVector(Coordinate p)", "class_method_signature": "ComputeRays.CoordinateToVector(Coordinate p)", "testcase": false, "constructor": false}, {"identifier": "cutRoofPointsWithPlane", "parameters": "(Plane plane, List<Coordinate> roofPts)", "modifiers": "public static", "return": "List<Coordinate>", "signature": "List<Coordinate> cutRoofPointsWithPlane(Plane plane, List<Coordinate> roofPts)", "full_signature": "public static List<Coordinate> cutRoofPointsWithPlane(Plane plane, List<Coordinate> roofPts)", "class_method_signature": "ComputeRays.cutRoofPointsWithPlane(Plane plane, List<Coordinate> roofPts)", "testcase": false, "constructor": false}, {"identifier": "computeSideHull", "parameters": "(boolean left, Coordinate p1, Coordinate p2)", "modifiers": "public", "return": "List<Coordinate>", "signature": "List<Coordinate> computeSideHull(boolean left, Coordinate p1, Coordinate p2)", "full_signature": "public List<Coordinate> computeSideHull(boolean left, Coordinate p1, Coordinate p2)", "class_method_signature": "ComputeRays.computeSideHull(boolean left, Coordinate p1, Coordinate p2)", "testcase": false, "constructor": false}, {"identifier": "directPath", "parameters": "(Coordinate srcCoord,\n                                             Coordinate receiverCoord, boolean verticalDiffraction,boolean horizontalDiffraction)", "modifiers": "", "return": "List<PropagationPath>", "signature": "List<PropagationPath> directPath(Coordinate srcCoord,\n                                             Coordinate receiverCoord, boolean verticalDiffraction,boolean horizontalDiffraction)", "full_signature": " List<PropagationPath> directPath(Coordinate srcCoord,\n                                             Coordinate receiverCoord, boolean verticalDiffraction,boolean horizontalDiffraction)", "class_method_signature": "ComputeRays.directPath(Coordinate srcCoord,\n                                             Coordinate receiverCoord, boolean verticalDiffraction,boolean horizontalDiffraction)", "testcase": false, "constructor": false}, {"identifier": "receiverSourcePropa", "parameters": "(Coordinate srcCoord, int srcId, double sourceLi,\n                                     Coordinate receiverCoord, int rcvId,\n                                     List<FastObstructionTest.Wall> nearBuildingsWalls, List<PropagationDebugInfo> debugInfo, IComputeRaysOut dataOut)", "modifiers": "private", "return": "double[]", "signature": "double[] receiverSourcePropa(Coordinate srcCoord, int srcId, double sourceLi,\n                                     Coordinate receiverCoord, int rcvId,\n                                     List<FastObstructionTest.Wall> nearBuildingsWalls, List<PropagationDebugInfo> debugInfo, IComputeRaysOut dataOut)", "full_signature": "private double[] receiverSourcePropa(Coordinate srcCoord, int srcId, double sourceLi,\n                                     Coordinate receiverCoord, int rcvId,\n                                     List<FastObstructionTest.Wall> nearBuildingsWalls, List<PropagationDebugInfo> debugInfo, IComputeRaysOut dataOut)", "class_method_signature": "ComputeRays.receiverSourcePropa(Coordinate srcCoord, int srcId, double sourceLi,\n                                     Coordinate receiverCoord, int rcvId,\n                                     List<FastObstructionTest.Wall> nearBuildingsWalls, List<PropagationDebugInfo> debugInfo, IComputeRaysOut dataOut)", "testcase": false, "constructor": false}, {"identifier": "insertPtSource", "parameters": "(Coordinate receiverPos, Coordinate ptpos, double[] wj, double li, Integer sourceId, List<SourcePointInfo> sourceList)", "modifiers": "private static", "return": "double", "signature": "double insertPtSource(Coordinate receiverPos, Coordinate ptpos, double[] wj, double li, Integer sourceId, List<SourcePointInfo> sourceList)", "full_signature": "private static double insertPtSource(Coordinate receiverPos, Coordinate ptpos, double[] wj, double li, Integer sourceId, List<SourcePointInfo> sourceList)", "class_method_signature": "ComputeRays.insertPtSource(Coordinate receiverPos, Coordinate ptpos, double[] wj, double li, Integer sourceId, List<SourcePointInfo> sourceList)", "testcase": false, "constructor": false}, {"identifier": "addLineSource", "parameters": "(LineString source, Coordinate receiverCoord, int srcIndex, List<SourcePointInfo> sourceList, double[] wj)", "modifiers": "private", "return": "double", "signature": "double addLineSource(LineString source, Coordinate receiverCoord, int srcIndex, List<SourcePointInfo> sourceList, double[] wj)", "full_signature": "private double addLineSource(LineString source, Coordinate receiverCoord, int srcIndex, List<SourcePointInfo> sourceList, double[] wj)", "class_method_signature": "ComputeRays.addLineSource(LineString source, Coordinate receiverCoord, int srcIndex, List<SourcePointInfo> sourceList, double[] wj)", "testcase": false, "constructor": false}, {"identifier": "computeRaysAtPosition", "parameters": "(Coordinate receiverCoord, int idReceiver, List<PropagationDebugInfo> debugInfo, IComputeRaysOut dataOut, ProgressVisitor progressVisitor)", "modifiers": "public", "return": "void", "signature": "void computeRaysAtPosition(Coordinate receiverCoord, int idReceiver, List<PropagationDebugInfo> debugInfo, IComputeRaysOut dataOut, ProgressVisitor progressVisitor)", "full_signature": "public void computeRaysAtPosition(Coordinate receiverCoord, int idReceiver, List<PropagationDebugInfo> debugInfo, IComputeRaysOut dataOut, ProgressVisitor progressVisitor)", "class_method_signature": "ComputeRays.computeRaysAtPosition(Coordinate receiverCoord, int idReceiver, List<PropagationDebugInfo> debugInfo, IComputeRaysOut dataOut, ProgressVisitor progressVisitor)", "testcase": false, "constructor": false}, {"identifier": "initStructures", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void initStructures()", "full_signature": "public void initStructures()", "class_method_signature": "ComputeRays.initStructures()", "testcase": false, "constructor": false}, {"identifier": "runDebug", "parameters": "(IComputeRaysOut computeRaysOut, List<PropagationDebugInfo> debugInfo)", "modifiers": "public", "return": "void", "signature": "void runDebug(IComputeRaysOut computeRaysOut, List<PropagationDebugInfo> debugInfo)", "full_signature": "public void runDebug(IComputeRaysOut computeRaysOut, List<PropagationDebugInfo> debugInfo)", "class_method_signature": "ComputeRays.runDebug(IComputeRaysOut computeRaysOut, List<PropagationDebugInfo> debugInfo)", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "(IComputeRaysOut computeRaysOut)", "modifiers": "public", "return": "void", "signature": "void run(IComputeRaysOut computeRaysOut)", "full_signature": "public void run(IComputeRaysOut computeRaysOut)", "class_method_signature": "ComputeRays.run(IComputeRaysOut computeRaysOut)", "testcase": false, "constructor": false}, {"identifier": "getIntersectedDistance", "parameters": "(Geometry geo)", "modifiers": "private", "return": "double", "signature": "double getIntersectedDistance(Geometry geo)", "full_signature": "private double getIntersectedDistance(Geometry geo)", "class_method_signature": "ComputeRays.getIntersectedDistance(Geometry geo)", "testcase": false, "constructor": false}], "file": "noisemodelling-propagation/src/main/java/org/noise_planet/noisemodelling/propagation/ComputeRays.java"}, "focal_method": {"identifier": "splitLineStringIntoPoints", "parameters": "(LineString geom, double segmentSizeConstraint,\n                                             List<Coordinate> pts)", "modifiers": "public static", "return": "double", "body": "public static double splitLineStringIntoPoints(LineString geom, double segmentSizeConstraint,\n                                             List<Coordinate> pts) {\n        // If the linear sound source length is inferior than half the distance between the nearest point of the sound\n        // source and the receiver then it can be modelled as a single point source\n        double geomLength = geom.getLength();\n        if(geomLength < segmentSizeConstraint) {\n           // Return mid point\n            Coordinate[] points = geom.getCoordinates();\n            double segmentLength = 0;\n            final double targetSegmentSize = geomLength / 2.0;\n            for (int i = 0; i < points.length - 1; i++) {\n                Coordinate a = points[i];\n                final Coordinate b = points[i + 1];\n                double length = a.distance3D(b);\n                if(length + segmentLength > targetSegmentSize) {\n                    double segmentLengthFraction = (targetSegmentSize - segmentLength) / length;\n                    Coordinate midPoint = new Coordinate(a.x + segmentLengthFraction * (b.x - a.x),\n                            a.y + segmentLengthFraction * (b.y - a.y),\n                            a.z + segmentLengthFraction * (b.z - a.z));\n                    pts.add(midPoint);\n                    break;\n                }\n                segmentLength += length;\n            }\n            return geom.getLength();\n        } else {\n            double targetSegmentSize = geomLength / Math.ceil(geomLength / segmentSizeConstraint);\n            Coordinate[] points = geom.getCoordinates();\n            double segmentLength = 0.;\n\n            // Mid point of segmented line source\n            Coordinate midPoint = null;\n            for (int i = 0; i < points.length - 1; i++) {\n                Coordinate a = points[i];\n                final Coordinate b = points[i + 1];\n                double length = a.distance3D(b);\n                if(Double.isNaN(length)) {\n                    length = a.distance(b);\n                }\n                while (length + segmentLength > targetSegmentSize) {\n                    //LineSegment segment = new LineSegment(a, b);\n                    double segmentLengthFraction = (targetSegmentSize - segmentLength) / length;\n                    Coordinate splitPoint = new Coordinate();\n                    splitPoint.x = a.x + segmentLengthFraction * (b.x - a.x);\n                    splitPoint.y = a.y + segmentLengthFraction * (b.y - a.y);\n                    splitPoint.z = a.z + segmentLengthFraction * (b.z - a.z);\n                    if(midPoint == null && length + segmentLength > targetSegmentSize / 2) {\n                        segmentLengthFraction = (targetSegmentSize / 2.0 - segmentLength) / length;\n                        midPoint = new Coordinate(a.x + segmentLengthFraction * (b.x - a.x),\n                                a.y + segmentLengthFraction * (b.y - a.y),\n                                a.z + segmentLengthFraction * (b.z - a.z));\n                    }\n                    pts.add(midPoint);\n                    a = splitPoint;\n                    length = a.distance3D(b);\n                    if(Double.isNaN(length)) {\n                        length = a.distance(b);\n                    }\n                    segmentLength = 0;\n                    midPoint = null;\n                }\n                if(midPoint == null && length + segmentLength > targetSegmentSize / 2) {\n                    double segmentLengthFraction = (targetSegmentSize / 2.0 - segmentLength) / length;\n                    midPoint = new Coordinate(a.x + segmentLengthFraction * (b.x - a.x),\n                            a.y + segmentLengthFraction * (b.y - a.y),\n                            a.z + segmentLengthFraction * (b.z - a.z));\n                }\n                segmentLength += length;\n            }\n            if(midPoint != null) {\n                pts.add(midPoint);\n            }\n            return targetSegmentSize;\n        }\n    }", "signature": "double splitLineStringIntoPoints(LineString geom, double segmentSizeConstraint,\n                                             List<Coordinate> pts)", "full_signature": "public static double splitLineStringIntoPoints(LineString geom, double segmentSizeConstraint,\n                                             List<Coordinate> pts)", "class_method_signature": "ComputeRays.splitLineStringIntoPoints(LineString geom, double segmentSizeConstraint,\n                                             List<Coordinate> pts)", "testcase": false, "constructor": false, "invocations": ["getLength", "getCoordinates", "distance3D", "add", "getLength", "ceil", "getCoordinates", "distance3D", "isNaN", "distance", "add", "distance3D", "isNaN", "distance", "add"]}, "repository": {"repo_id": 5002457, "url": "https://github.com/Ifsttar/NoiseModelling", "language": "Java", "is_fork": false, "fork_count": 33, "stargazer_count": 38, "size": 38887, "license": "licensed"}}