{"test_class": {"identifier": "ComparableMergerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Index INDEX = new Index(\"test\");", "modifier": "private static final", "type": "Index", "declarator": "INDEX = new Index(\"test\")", "var_name": "INDEX"}, {"original_string": "private final ComparableMerger<String> merger = new ComparableMerger<String>(\n      new Converter<String>() {\n\n        @Override\n        public String fromBytes(Index index, byte[] value) throws ConversionException {\n          return bytesToString(value);\n        }\n\n        @Override\n        public String fromLatest(String from) {\n          return from;\n        }\n\n        @Override\n        public byte[] toBytes(String from) {\n          return MessageLibrary.toBytes(from);\n        }\n      });", "modifier": "private final", "type": "ComparableMerger<String>", "declarator": "merger = new ComparableMerger<String>(\n      new Converter<String>() {\n\n        @Override\n        public String fromBytes(Index index, byte[] value) throws ConversionException {\n          return bytesToString(value);\n        }\n\n        @Override\n        public String fromLatest(String from) {\n          return from;\n        }\n\n        @Override\n        public byte[] toBytes(String from) {\n          return MessageLibrary.toBytes(from);\n        }\n      })", "var_name": "merger"}], "file": "client/src/test/java/com/google/nigori/client/ComparableMergerTest.java"}, "test_case": {"identifier": "mergeTwoEquiv", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void mergeTwoEquiv() throws IOException, NigoriCryptographyException,\n      UnauthorisedException {\n    Collection<RevValue> heads = new ArrayList<RevValue>();\n    byte[] test = MessageLibrary.toBytes(\"test\");\n    RevValue rv = new RevValue(Revision.EMPTY, test);\n    RevValue rv1 = new RevValue(Revision.EMPTY, test);\n    heads.add(rv);\n    heads.add(rv1);\n    MigoriDatastore store = createMock(MigoriDatastore.class);\n    expect(store.put(eq(INDEX), aryEq(test), eq(rv), eq(rv1))).andReturn(rv);\n    replay(store);\n    RevValue value = merger.merge(store, INDEX, heads);\n    verify(store);\n    assertEquals(rv, value);\n  }", "signature": "void mergeTwoEquiv()", "full_signature": "@Test public void mergeTwoEquiv()", "class_method_signature": "ComparableMergerTest.mergeTwoEquiv()", "testcase": true, "constructor": false, "invocations": ["toBytes", "add", "add", "createMock", "andReturn", "expect", "put", "eq", "aryEq", "eq", "eq", "replay", "merge", "verify", "assertEquals"]}, "focal_class": {"identifier": "ComparableMerger", "superclass": "", "interfaces": "implements MigoriMerger", "fields": [{"original_string": "private Converter<T> converter;", "modifier": "private", "type": "Converter<T>", "declarator": "converter", "var_name": "converter"}], "methods": [{"identifier": "ComparableMerger", "parameters": "(Converter<T> converter)", "modifiers": "public", "return": "", "signature": " ComparableMerger(Converter<T> converter)", "full_signature": "public  ComparableMerger(Converter<T> converter)", "class_method_signature": "ComparableMerger.ComparableMerger(Converter<T> converter)", "testcase": false, "constructor": true}, {"identifier": "merge", "parameters": "(MigoriDatastore store, Index index, Collection<RevValue> heads)", "modifiers": "@Override public", "return": "RevValue", "signature": "RevValue merge(MigoriDatastore store, Index index, Collection<RevValue> heads)", "full_signature": "@Override public RevValue merge(MigoriDatastore store, Index index, Collection<RevValue> heads)", "class_method_signature": "ComparableMerger.merge(MigoriDatastore store, Index index, Collection<RevValue> heads)", "testcase": false, "constructor": false}, {"identifier": "map", "parameters": "(List<T> items, Map<T, RevValue> mapBack)", "modifiers": "private", "return": "Collection<RevValue>", "signature": "Collection<RevValue> map(List<T> items, Map<T, RevValue> mapBack)", "full_signature": "private Collection<RevValue> map(List<T> items, Map<T, RevValue> mapBack)", "class_method_signature": "ComparableMerger.map(List<T> items, Map<T, RevValue> mapBack)", "testcase": false, "constructor": false}, {"identifier": "findEquivalences", "parameters": "(MigoriDatastore store, Index index, List<T> items,\n      Map<T, RevValue> mapBack)", "modifiers": "private", "return": "void", "signature": "void findEquivalences(MigoriDatastore store, Index index, List<T> items,\n      Map<T, RevValue> mapBack)", "full_signature": "private void findEquivalences(MigoriDatastore store, Index index, List<T> items,\n      Map<T, RevValue> mapBack)", "class_method_signature": "ComparableMerger.findEquivalences(MigoriDatastore store, Index index, List<T> items,\n      Map<T, RevValue> mapBack)", "testcase": false, "constructor": false}, {"identifier": "putEquivalence", "parameters": "(MigoriDatastore store, Index index,\n      Collection<T> equivalence, Map<T, RevValue> mapBack)", "modifiers": "private", "return": "TypeValue<T>", "signature": "TypeValue<T> putEquivalence(MigoriDatastore store, Index index,\n      Collection<T> equivalence, Map<T, RevValue> mapBack)", "full_signature": "private TypeValue<T> putEquivalence(MigoriDatastore store, Index index,\n      Collection<T> equivalence, Map<T, RevValue> mapBack)", "class_method_signature": "ComparableMerger.putEquivalence(MigoriDatastore store, Index index,\n      Collection<T> equivalence, Map<T, RevValue> mapBack)", "testcase": false, "constructor": false}], "file": "client/src/main/java/com/google/nigori/client/ComparableMerger.java"}, "focal_method": {"identifier": "merge", "parameters": "(MigoriDatastore store, Index index, Collection<RevValue> heads)", "modifiers": "@Override public", "return": "RevValue", "body": "@Override\n  public RevValue merge(MigoriDatastore store, Index index, Collection<RevValue> heads)\n      throws IOException, NigoriCryptographyException, UnauthorisedException {\n    assert heads.size() > 1;// caller must ensure that this is true\n    List<T> items = new ArrayList<T>(heads.size());\n    Map<T, RevValue> mapBack = new HashMap<T, RevValue>();\n    for (RevValue value : heads) {\n      T item;\n      try {\n        item = converter.fromBytes(index, value.getValue());\n      } catch (ConversionException e) {\n        throw new IOException(e);\n      }\n      items.add(item);\n      mapBack.put(item, value);\n    }\n    findEquivalences(store, index, items, mapBack);\n    T latest = items.get(items.size() - 1);\n    if (items.size() == 1) {// we have already reduced it to one so don't need to do anything more\n      return mapBack.get(latest);\n    }\n    T newItem = converter.fromLatest(latest);\n    return store.put(index, converter.toBytes(newItem), map(items, mapBack)\n        .toArray(new RevValue[0]));\n  }", "signature": "RevValue merge(MigoriDatastore store, Index index, Collection<RevValue> heads)", "full_signature": "@Override public RevValue merge(MigoriDatastore store, Index index, Collection<RevValue> heads)", "class_method_signature": "ComparableMerger.merge(MigoriDatastore store, Index index, Collection<RevValue> heads)", "testcase": false, "constructor": false, "invocations": ["size", "size", "fromBytes", "getValue", "add", "put", "findEquivalences", "get", "size", "size", "get", "fromLatest", "put", "toBytes", "toArray", "map"]}, "repository": {"repo_id": 4214268, "url": "https://github.com/ucam-cl-dtg/nigori", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 9, "size": 909, "license": "licensed"}}