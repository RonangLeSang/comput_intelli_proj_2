{"test_class": {"identifier": "TestOperationRetryHandler", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Predicate<Throwable> testRetryPredicate = new Predicate<Throwable>() {\n        @Override\n        public boolean test(Throwable input) {\n            return input.getClass() == RuntimeException.class;\n        }\n    };", "modifier": "private final", "type": "Predicate<Throwable>", "declarator": "testRetryPredicate = new Predicate<Throwable>() {\n        @Override\n        public boolean test(Throwable input) {\n            return input.getClass() == RuntimeException.class;\n        }\n    }", "var_name": "testRetryPredicate"}, {"original_string": "private final OperationRetryHandler retryHandler = new OperationRetryHandler(3, 1, 1, testRetryPredicate);", "modifier": "private final", "type": "OperationRetryHandler", "declarator": "retryHandler = new OperationRetryHandler(3, 1, 1, testRetryPredicate)", "var_name": "retryHandler"}], "file": "core/src/test/java/org/apache/oozie/util/db/TestOperationRetryHandler.java"}, "test_case": {"identifier": "testRetriesOnFailure", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRetriesOnFailure() throws Exception {\n        @SuppressWarnings(\"unchecked\")\n        Callable<String> operation = mock(Callable.class);\n        final MutableInt callCount = new MutableInt(0);\n\n        willAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                callCount.increment();\n                throw new RuntimeException();\n            }\n        }).given(operation).call();\n\n        boolean exceptionThrown = false;\n        try {\n            retryHandler.executeWithRetry(operation);\n        } catch (RuntimeException e) {\n            exceptionThrown = true;\n        }\n\n        assertTrue(\"Exception was not thrown\", exceptionThrown);\n        assertCallCount(3, callCount);\n        assertNoRetryAttemptsAreInProgressOrExhausted();\n    }", "signature": "void testRetriesOnFailure()", "full_signature": "@Test public void testRetriesOnFailure()", "class_method_signature": "TestOperationRetryHandler.testRetriesOnFailure()", "testcase": true, "constructor": false, "invocations": ["mock", "call", "given", "willAnswer", "increment", "executeWithRetry", "assertTrue", "assertCallCount", "assertNoRetryAttemptsAreInProgressOrExhausted"]}, "focal_class": {"identifier": "OperationRetryHandler", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static XLog LOG = XLog.getLog(OperationRetryHandler.class);", "modifier": "private static", "type": "XLog", "declarator": "LOG = XLog.getLog(OperationRetryHandler.class)", "var_name": "LOG"}, {"original_string": "@VisibleForTesting\n    static final RetryAttemptState RETRY_ATTEMPT_STATE = new RetryAttemptState();", "modifier": "@VisibleForTesting\n    static final", "type": "RetryAttemptState", "declarator": "RETRY_ATTEMPT_STATE = new RetryAttemptState()", "var_name": "RETRY_ATTEMPT_STATE"}, {"original_string": "private final int maxRetryCount;", "modifier": "private final", "type": "int", "declarator": "maxRetryCount", "var_name": "maxRetryCount"}, {"original_string": "private final long initialWaitTime;", "modifier": "private final", "type": "long", "declarator": "initialWaitTime", "var_name": "initialWaitTime"}, {"original_string": "private final long maxWaitTime;", "modifier": "private final", "type": "long", "declarator": "maxWaitTime", "var_name": "maxWaitTime"}, {"original_string": "private final Predicate<Throwable> retryPredicate;", "modifier": "private final", "type": "Predicate<Throwable>", "declarator": "retryPredicate", "var_name": "retryPredicate"}, {"original_string": "private final boolean shouldRetry;", "modifier": "private final", "type": "boolean", "declarator": "shouldRetry", "var_name": "shouldRetry"}], "methods": [{"identifier": "OperationRetryHandler", "parameters": "(final int maxRetryCount, final long initialWaitTime, final long maxWaitTime,\n                                 final Predicate<Throwable> retryPredicate)", "modifiers": "public", "return": "", "signature": " OperationRetryHandler(final int maxRetryCount, final long initialWaitTime, final long maxWaitTime,\n                                 final Predicate<Throwable> retryPredicate)", "full_signature": "public  OperationRetryHandler(final int maxRetryCount, final long initialWaitTime, final long maxWaitTime,\n                                 final Predicate<Throwable> retryPredicate)", "class_method_signature": "OperationRetryHandler.OperationRetryHandler(final int maxRetryCount, final long initialWaitTime, final long maxWaitTime,\n                                 final Predicate<Throwable> retryPredicate)", "testcase": false, "constructor": true}, {"identifier": "executeWithRetry", "parameters": "(final Callable<V> operation)", "modifiers": "public", "return": "V", "signature": "V executeWithRetry(final Callable<V> operation)", "full_signature": "public V executeWithRetry(final Callable<V> operation)", "class_method_signature": "OperationRetryHandler.executeWithRetry(final Callable<V> operation)", "testcase": false, "constructor": false}, {"identifier": "handleRetry", "parameters": "(long sleepBeforeRetryMs, final int retries)", "modifiers": "private", "return": "long", "signature": "long handleRetry(long sleepBeforeRetryMs, final int retries)", "full_signature": "private long handleRetry(long sleepBeforeRetryMs, final int retries)", "class_method_signature": "OperationRetryHandler.handleRetry(long sleepBeforeRetryMs, final int retries)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/apache/oozie/util/db/OperationRetryHandler.java"}, "focal_method": {"identifier": "executeWithRetry", "parameters": "(final Callable<V> operation)", "modifiers": "public", "return": "V", "body": "public <V> V executeWithRetry(final Callable<V> operation) throws Exception {\n        int retries = 0;\n        long waitTime = initialWaitTime;\n        Exception lastException = null;\n\n        if (!shouldRetry) {\n            try {\n                LOG.trace(\"Configured not to retry, calling operation once.\");\n\n                final V result = operation.call();\n\n                LOG.trace(\"Operation called once successfully.\");\n\n                return result;\n            }\n            catch (final Exception e) {\n                LOG.error(\"An error occurred while calling the operation once. [e.message={0}]\", e.getMessage());\n                throw e;\n            }\n        }\n\n        try {\n            RETRY_ATTEMPT_STATE.signalStart();\n\n            while (retries < maxRetryCount) {\n                try {\n                    LOG.trace(\"Calling operation. [retries={0}]\", retries);\n\n                    retries++;\n                    final V result = operation.call();\n\n                    LOG.trace(\"Operation called successfully.\");\n\n                    return result;\n                } catch (final Exception e) {\n                    LOG.warn(\"Database error\", e);\n\n                    // if retries have been done by an inner retry handler,\n                    // then we won't make any effort to do it again\n                    if (RETRY_ATTEMPT_STATE.isExhausted()) {\n                        LOG.error(\"Retry attempts have been exhausted. [e.message={0}]\", e.getMessage());\n                        throw e;\n                    }\n\n                    if (retryPredicate.test(e)) {\n                        LOG.trace(\"Exception is not on blacklist, handling retry. [retries={0};e.class={1}]\",\n                                retries, e.getClass().getName());\n                        waitTime = handleRetry(waitTime, retries);\n                        lastException = e;\n                    }\n                    else {\n                        LOG.warn(\"Exception is on blacklist, not handling retry. [retries={0};e.class={1}]\",\n                                retries, e.getClass().getName());\n                        throw e;\n                    }\n                }\n            }\n\n            LOG.error(\"Number of maximum retry attempts exhausted\");\n            RETRY_ATTEMPT_STATE.signalExhausted(); // signal to possible outer retry handlers\n            throw lastException;\n        } finally {\n            RETRY_ATTEMPT_STATE.signalEnd();\n        }\n    }", "signature": "V executeWithRetry(final Callable<V> operation)", "full_signature": "public V executeWithRetry(final Callable<V> operation)", "class_method_signature": "OperationRetryHandler.executeWithRetry(final Callable<V> operation)", "testcase": false, "constructor": false, "invocations": ["trace", "call", "trace", "error", "getMessage", "signalStart", "trace", "call", "trace", "warn", "isExhausted", "error", "getMessage", "test", "trace", "getName", "getClass", "handleRetry", "warn", "getName", "getClass", "error", "signalExhausted", "signalEnd"]}, "repository": {"repo_id": 2383782, "url": "https://github.com/apache/oozie", "stars": 542, "created": "9/14/2011 7:00:10 AM +00:00", "updates": "2020-01-18T12:54:24+00:00", "fork": "False", "license": "licensed"}}