{"test_class": {"identifier": "HttpCallTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final HttpCall.BodyConverter<Object> NULL = (parser, contentString) -> null;", "modifier": "static final", "type": "HttpCall.BodyConverter<Object>", "declarator": "NULL = (parser, contentString) -> null", "var_name": "NULL"}, {"original_string": "private static final AggregatedHttpResponse SUCCESS_RESPONSE =\n    AggregatedHttpResponse.of(HttpStatus.OK);", "modifier": "private static final", "type": "AggregatedHttpResponse", "declarator": "SUCCESS_RESPONSE =\n    AggregatedHttpResponse.of(HttpStatus.OK)", "var_name": "SUCCESS_RESPONSE"}, {"original_string": "@RegisterExtension static MockWebServerExtension server = new MockWebServerExtension();", "modifier": "@RegisterExtension static", "type": "MockWebServerExtension", "declarator": "server = new MockWebServerExtension()", "var_name": "server"}, {"original_string": "static final AggregatedHttpRequest REQUEST = AggregatedHttpRequest.of(HttpMethod.GET, \"/\");", "modifier": "static final", "type": "AggregatedHttpRequest", "declarator": "REQUEST = AggregatedHttpRequest.of(HttpMethod.GET, \"/\")", "var_name": "REQUEST"}, {"original_string": "HttpCall.Factory http;", "modifier": "", "type": "HttpCall.Factory", "declarator": "http", "var_name": "http"}], "file": "zipkin-storage/elasticsearch/src/test/java/zipkin2/elasticsearch/internal/client/HttpCallTest.java"}, "test_case": {"identifier": "releasesAllReferencesToByteBuf", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test void releasesAllReferencesToByteBuf() {\n    // Force this to be a ref-counted response\n    byte[] message = \"{\\\"Message\\\":\\\"error\\\"}\".getBytes(UTF_8);\n    ByteBuf encodedBuf = PooledByteBufAllocator.DEFAULT.buffer(message.length);\n    encodedBuf.writeBytes(message);\n    AggregatedHttpResponse response = AggregatedHttpResponse.of(\n      ResponseHeaders.of(HttpStatus.FORBIDDEN),\n      HttpData.wrap(encodedBuf)\n    );\n\n    HttpCall<Object> call = http.newCall(REQUEST, NULL, \"test\");\n\n    // Invoke the parser directly because using the fake server will not result in ref-counted\n    assertThatThrownBy(() -> call.parseResponse(response, NULL)).hasMessage(\"error\");\n    assertThat(encodedBuf.refCnt()).isEqualTo(0);\n  }", "signature": "void releasesAllReferencesToByteBuf()", "full_signature": "@Test void releasesAllReferencesToByteBuf()", "class_method_signature": "HttpCallTest.releasesAllReferencesToByteBuf()", "testcase": true, "constructor": false, "invocations": ["getBytes", "buffer", "writeBytes", "of", "of", "wrap", "newCall", "hasMessage", "assertThatThrownBy", "parseResponse", "isEqualTo", "assertThat", "refCnt"]}, "focal_class": {"identifier": "HttpCall", "superclass": "extends Call.Base<V>", "interfaces": "", "fields": [{"original_string": "public final RequestSupplier request;", "modifier": "public final", "type": "RequestSupplier", "declarator": "request", "var_name": "request"}, {"original_string": "final BodyConverter<V> bodyConverter;", "modifier": "final", "type": "BodyConverter<V>", "declarator": "bodyConverter", "var_name": "bodyConverter"}, {"original_string": "final String name;", "modifier": "final", "type": "String", "declarator": "name", "var_name": "name"}, {"original_string": "final WebClient httpClient;", "modifier": "final", "type": "WebClient", "declarator": "httpClient", "var_name": "httpClient"}, {"original_string": "volatile CompletableFuture<AggregatedHttpResponse> responseFuture;", "modifier": "volatile", "type": "CompletableFuture<AggregatedHttpResponse>", "declarator": "responseFuture", "var_name": "responseFuture"}], "methods": [{"identifier": "HttpCall", "parameters": "(WebClient httpClient, RequestSupplier request, BodyConverter<V> bodyConverter,\n    String name)", "modifiers": "", "return": "", "signature": " HttpCall(WebClient httpClient, RequestSupplier request, BodyConverter<V> bodyConverter,\n    String name)", "full_signature": "  HttpCall(WebClient httpClient, RequestSupplier request, BodyConverter<V> bodyConverter,\n    String name)", "class_method_signature": "HttpCall.HttpCall(WebClient httpClient, RequestSupplier request, BodyConverter<V> bodyConverter,\n    String name)", "testcase": false, "constructor": true}, {"identifier": "doExecute", "parameters": "()", "modifiers": "@Override protected", "return": "V", "signature": "V doExecute()", "full_signature": "@Override protected V doExecute()", "class_method_signature": "HttpCall.doExecute()", "testcase": false, "constructor": false}, {"identifier": "doEnqueue", "parameters": "(Callback<V> callback)", "modifiers": "@SuppressWarnings(\"FutureReturnValueIgnored\") // TODO: errorprone wants us to check this future before returning, but what would be a sensible // check? Say it is somehow canceled, would we take action? Would callback.onError() be redundant? @Override protected", "return": "void", "signature": "void doEnqueue(Callback<V> callback)", "full_signature": "@SuppressWarnings(\"FutureReturnValueIgnored\") // TODO: errorprone wants us to check this future before returning, but what would be a sensible // check? Say it is somehow canceled, would we take action? Would callback.onError() be redundant? @Override protected void doEnqueue(Callback<V> callback)", "class_method_signature": "HttpCall.doEnqueue(Callback<V> callback)", "testcase": false, "constructor": false}, {"identifier": "doCancel", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void doCancel()", "full_signature": "@Override protected void doCancel()", "class_method_signature": "HttpCall.doCancel()", "testcase": false, "constructor": false}, {"identifier": "clone", "parameters": "()", "modifiers": "@Override public", "return": "HttpCall<V>", "signature": "HttpCall<V> clone()", "full_signature": "@Override public HttpCall<V> clone()", "class_method_signature": "HttpCall.clone()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "HttpCall.toString()", "testcase": false, "constructor": false}, {"identifier": "sendRequest", "parameters": "()", "modifiers": "", "return": "CompletableFuture<AggregatedHttpResponse>", "signature": "CompletableFuture<AggregatedHttpResponse> sendRequest()", "full_signature": " CompletableFuture<AggregatedHttpResponse> sendRequest()", "class_method_signature": "HttpCall.sendRequest()", "testcase": false, "constructor": false}, {"identifier": "parseResponse", "parameters": "(AggregatedHttpResponse response, BodyConverter<V> bodyConverter)", "modifiers": "", "return": "V", "signature": "V parseResponse(AggregatedHttpResponse response, BodyConverter<V> bodyConverter)", "full_signature": " V parseResponse(AggregatedHttpResponse response, BodyConverter<V> bodyConverter)", "class_method_signature": "HttpCall.parseResponse(AggregatedHttpResponse response, BodyConverter<V> bodyConverter)", "testcase": false, "constructor": false}], "file": "zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/internal/client/HttpCall.java"}, "focal_method": {"identifier": "parseResponse", "parameters": "(AggregatedHttpResponse response, BodyConverter<V> bodyConverter)", "modifiers": "", "return": "V", "body": "V parseResponse(AggregatedHttpResponse response, BodyConverter<V> bodyConverter)\n    throws IOException {\n    // Handle the case where there is no content, as that means we have no resources to release.\n    HttpStatus status = response.status();\n    if (response.content().isEmpty()) {\n      if (status.codeClass().equals(HttpStatusClass.SUCCESS)) {\n        return null;\n      } else if (status.code() == 404) {\n        throw new FileNotFoundException(request.headers().path());\n      } else {\n        throw new RuntimeException(\n          \"response for \" + request.headers().path() + \" failed: \" + response.status());\n      }\n    }\n\n    // If this is a client or server error, we look for a json message.\n    if ((status.codeClass().equals(HttpStatusClass.CLIENT_ERROR)\n      || status.codeClass().equals(HttpStatusClass.SERVER_ERROR))) {\n      bodyConverter = (parser, contentString) -> {\n        String message = null;\n        try {\n          JsonNode root = OBJECT_MAPPER.readTree(parser);\n          message = root.findPath(\"reason\").textValue();\n          if (message == null) message = root.at(\"/Message\").textValue();\n        } catch (RuntimeException | IOException possiblyParseException) {\n          // EmptyCatch ignored\n        }\n        throw new RuntimeException(message != null ? message\n          : \"response for \" + request.headers().path() + \" failed: \" + contentString.get());\n      };\n    }\n\n    try (HttpData content = response.content();\n         InputStream stream = content.toInputStream();\n         JsonParser parser = JSON_FACTORY.createParser(stream)) {\n\n      if (status.code() == 404) throw new FileNotFoundException(request.headers().path());\n\n      return bodyConverter.convert(parser, content::toStringUtf8);\n    }\n  }", "signature": "V parseResponse(AggregatedHttpResponse response, BodyConverter<V> bodyConverter)", "full_signature": " V parseResponse(AggregatedHttpResponse response, BodyConverter<V> bodyConverter)", "class_method_signature": "HttpCall.parseResponse(AggregatedHttpResponse response, BodyConverter<V> bodyConverter)", "testcase": false, "constructor": false, "invocations": ["status", "isEmpty", "content", "equals", "codeClass", "code", "path", "headers", "path", "headers", "status", "equals", "codeClass", "equals", "codeClass", "readTree", "textValue", "findPath", "textValue", "at", "path", "headers", "get", "content", "toInputStream", "createParser", "code", "path", "headers", "convert"]}, "repository": {"repo_id": 4576305, "url": "https://github.com/openzipkin/zipkin", "stars": 12365, "created": "6/6/2012 6:26:16 PM +00:00", "updates": "2020-01-27T10:22:48+00:00", "fork": "False", "license": "licensed"}}