{"test_class": {"identifier": "CassandraSpanConsumerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "CassandraSpanConsumer consumer = spanConsumer(CassandraStorage.newBuilder());", "modifier": "", "type": "CassandraSpanConsumer", "declarator": "consumer = spanConsumer(CassandraStorage.newBuilder())", "var_name": "consumer"}, {"original_string": "Span spanWithoutAnnotationsOrTags =\n    Span.newBuilder()\n      .traceId(\"a\")\n      .id(\"1\")\n      .name(\"get\")\n      .localEndpoint(FRONTEND)\n      .timestamp(TODAY * 1000L)\n      .duration(207000L)\n      .build();", "modifier": "", "type": "Span", "declarator": "spanWithoutAnnotationsOrTags =\n    Span.newBuilder()\n      .traceId(\"a\")\n      .id(\"1\")\n      .name(\"get\")\n      .localEndpoint(FRONTEND)\n      .timestamp(TODAY * 1000L)\n      .duration(207000L)\n      .build()", "var_name": "spanWithoutAnnotationsOrTags"}], "file": "zipkin-storage/cassandra/src/test/java/zipkin2/storage/cassandra/CassandraSpanConsumerTest.java"}, "test_case": {"identifier": "searchDisabled_doesntIndex", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void searchDisabled_doesntIndex() {\n    consumer = spanConsumer(CassandraStorage.newBuilder().searchEnabled(false));\n\n    Span span =\n      spanWithoutAnnotationsOrTags\n        .toBuilder()\n        .addAnnotation(TODAY * 1000L, \"annotation\")\n        .putTag(\"foo\", \"bar\")\n        .duration(10000L)\n        .build();\n\n    assertThat(consumer.accept(singletonList(span)))\n      .extracting(\"input.annotation_query\")\n      .satisfies(q -> assertThat(q).isNull());\n  }", "signature": "void searchDisabled_doesntIndex()", "full_signature": "@Test public void searchDisabled_doesntIndex()", "class_method_signature": "CassandraSpanConsumerTest.searchDisabled_doesntIndex()", "testcase": true, "constructor": false, "invocations": ["spanConsumer", "searchEnabled", "newBuilder", "build", "duration", "putTag", "addAnnotation", "toBuilder", "satisfies", "extracting", "assertThat", "accept", "singletonList", "isNull", "assertThat"]}, "focal_class": {"identifier": "CassandraSpanConsumer", "superclass": "", "interfaces": "implements SpanConsumer", "fields": [{"original_string": "final Session session;", "modifier": "final", "type": "Session", "declarator": "session", "var_name": "session"}, {"original_string": "final boolean strictTraceId, searchEnabled;", "modifier": "final", "type": "boolean", "declarator": "strictTraceId", "var_name": "strictTraceId"}, {"original_string": "final InsertSpan.Factory insertSpan;", "modifier": "final", "type": "InsertSpan.Factory", "declarator": "insertSpan", "var_name": "insertSpan"}, {"original_string": "final Set<String> autocompleteKeys;", "modifier": "final", "type": "Set<String>", "declarator": "autocompleteKeys", "var_name": "autocompleteKeys"}, {"original_string": "@Nullable final InsertTraceByServiceRemoteService.Factory insertTraceByServiceRemoteService;", "modifier": "@Nullable final", "type": "InsertTraceByServiceRemoteService.Factory", "declarator": "insertTraceByServiceRemoteService", "var_name": "insertTraceByServiceRemoteService"}, {"original_string": "@Nullable final InsertTraceByServiceSpan.Factory insertTraceByServiceSpan;", "modifier": "@Nullable final", "type": "InsertTraceByServiceSpan.Factory", "declarator": "insertTraceByServiceSpan", "var_name": "insertTraceByServiceSpan"}, {"original_string": "@Nullable final InsertServiceSpan.Factory insertServiceSpan;", "modifier": "@Nullable final", "type": "InsertServiceSpan.Factory", "declarator": "insertServiceSpan", "var_name": "insertServiceSpan"}, {"original_string": "@Nullable final InsertServiceRemoteService.Factory insertServiceRemoteService;", "modifier": "@Nullable final", "type": "InsertServiceRemoteService.Factory", "declarator": "insertServiceRemoteService", "var_name": "insertServiceRemoteService"}, {"original_string": "@Nullable final InsertAutocompleteValue.Factory insertAutocompleteValue;", "modifier": "@Nullable final", "type": "InsertAutocompleteValue.Factory", "declarator": "insertAutocompleteValue", "var_name": "insertAutocompleteValue"}], "methods": [{"identifier": "CassandraSpanConsumer", "parameters": "(CassandraStorage storage)", "modifiers": "", "return": "", "signature": " CassandraSpanConsumer(CassandraStorage storage)", "full_signature": "  CassandraSpanConsumer(CassandraStorage storage)", "class_method_signature": "CassandraSpanConsumer.CassandraSpanConsumer(CassandraStorage storage)", "testcase": false, "constructor": true}, {"identifier": "accept", "parameters": "(List<Span> input)", "modifiers": "@Override public", "return": "Call<Void>", "signature": "Call<Void> accept(List<Span> input)", "full_signature": "@Override public Call<Void> accept(List<Span> input)", "class_method_signature": "CassandraSpanConsumer.accept(List<Span> input)", "testcase": false, "constructor": false}, {"identifier": "guessTimestamp", "parameters": "(Span span)", "modifiers": "static", "return": "long", "signature": "long guessTimestamp(Span span)", "full_signature": "static long guessTimestamp(Span span)", "class_method_signature": "CassandraSpanConsumer.guessTimestamp(Span span)", "testcase": false, "constructor": false}], "file": "zipkin-storage/cassandra/src/main/java/zipkin2/storage/cassandra/CassandraSpanConsumer.java"}, "focal_method": {"identifier": "accept", "parameters": "(List<Span> input)", "modifiers": "@Override public", "return": "Call<Void>", "body": "@Override public Call<Void> accept(List<Span> input) {\n    if (input.isEmpty()) return Call.create(null);\n\n    Set<InsertSpan.Input> spans = new LinkedHashSet<>();\n    Set<Entry<String, String>> serviceRemoteServices = new LinkedHashSet<>();\n    Set<Entry<String, String>> serviceSpans = new LinkedHashSet<>();\n    Set<InsertTraceByServiceRemoteService.Input> traceByServiceRemoteServices =\n      new LinkedHashSet<>();\n    Set<InsertTraceByServiceSpan.Input> traceByServiceSpans = new LinkedHashSet<>();\n    Set<Entry<String, String>> autocompleteTags = new LinkedHashSet<>();\n\n    for (Span s : input) {\n      // indexing occurs by timestamp, so derive one if not present.\n      long ts_micro = s.timestampAsLong();\n      if (ts_micro == 0L) ts_micro = guessTimestamp(s);\n\n      // fallback to current time on the ts_uuid for span data, so we know when it was inserted\n      UUID ts_uuid =\n        new UUID(\n          UUIDs.startOf(ts_micro != 0L ? (ts_micro / 1000L) : System.currentTimeMillis())\n            .getMostSignificantBits(),\n          UUIDs.random().getLeastSignificantBits());\n\n      spans.add(insertSpan.newInput(s, ts_uuid));\n\n      if (!searchEnabled) continue;\n\n      // Empty values allow for api queries with blank service or span name\n      String service = s.localServiceName() != null ? s.localServiceName() : \"\";\n      String span =\n        null != s.name() ? s.name() : \"\"; // Empty value allows for api queries without span name\n\n      if (null == s.localServiceName()) continue; // don't index further w/o a service name\n\n      // service span and remote service indexes is refreshed regardless of timestamp\n      String remoteService = s.remoteServiceName();\n      if (insertServiceRemoteService != null && remoteService != null) {\n        serviceRemoteServices.add(new SimpleImmutableEntry<>(service, remoteService));\n      }\n      serviceSpans.add(new SimpleImmutableEntry<>(service, span));\n\n      if (ts_micro == 0L) continue; // search is only valid with a timestamp, don't index w/o it!\n      int bucket = durationIndexBucket(ts_micro); // duration index is milliseconds not microseconds\n      long duration = s.durationAsLong() / 1000L;\n      traceByServiceSpans.add(\n        insertTraceByServiceSpan.newInput(service, span, bucket, ts_uuid, s.traceId(), duration));\n      if (span.isEmpty()) continue;\n\n      if (insertServiceRemoteService != null && remoteService != null) {\n        traceByServiceRemoteServices.add(\n          insertTraceByServiceRemoteService.newInput(service, remoteService, bucket, ts_uuid,\n            s.traceId()));\n      }\n      traceByServiceSpans.add( // Allows lookup without the span name\n        insertTraceByServiceSpan.newInput(service, \"\", bucket, ts_uuid, s.traceId(), duration));\n\n      if (insertAutocompleteValue != null) {\n        for (Entry<String, String> entry : s.tags().entrySet()) {\n          if (autocompleteKeys.contains(entry.getKey())) autocompleteTags.add(entry);\n        }\n      }\n    }\n    List<Call<Void>> calls = new ArrayList<>();\n    for (InsertSpan.Input span : spans) {\n      calls.add(insertSpan.create(span));\n    }\n    for (Entry<String, String> serviceSpan : serviceSpans) {\n      insertServiceSpan.maybeAdd(serviceSpan, calls);\n    }\n    for (Entry<String, String> serviceRemoteService : serviceRemoteServices) {\n      insertServiceRemoteService.maybeAdd(serviceRemoteService, calls);\n    }\n    for (InsertTraceByServiceSpan.Input serviceSpan : traceByServiceSpans) {\n      calls.add(insertTraceByServiceSpan.create(serviceSpan));\n    }\n    for (InsertTraceByServiceRemoteService.Input serviceRemoteService : traceByServiceRemoteServices) {\n      calls.add(insertTraceByServiceRemoteService.create(serviceRemoteService));\n    }\n    for (Entry<String, String> autocompleteTag : autocompleteTags) {\n      insertAutocompleteValue.maybeAdd(autocompleteTag, calls);\n    }\n    return calls.isEmpty() ? Call.create(null) : AggregateCall.newVoidCall(calls);\n  }", "signature": "Call<Void> accept(List<Span> input)", "full_signature": "@Override public Call<Void> accept(List<Span> input)", "class_method_signature": "CassandraSpanConsumer.accept(List<Span> input)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "create", "timestampAsLong", "guessTimestamp", "getMostSignificantBits", "startOf", "currentTimeMillis", "getLeastSignificantBits", "random", "add", "newInput", "localServiceName", "localServiceName", "name", "name", "localServiceName", "remoteServiceName", "add", "add", "durationIndexBucket", "durationAsLong", "add", "newInput", "traceId", "isEmpty", "add", "newInput", "traceId", "add", "newInput", "traceId", "entrySet", "tags", "contains", "getKey", "add", "add", "create", "maybeAdd", "maybeAdd", "add", "create", "add", "create", "maybeAdd", "isEmpty", "create", "newVoidCall"]}, "repository": {"repo_id": 4576305, "url": "https://github.com/openzipkin/zipkin", "stars": 12365, "created": "6/6/2012 6:26:16 PM +00:00", "updates": "2020-01-27T10:22:48+00:00", "fork": "False", "license": "licensed"}}