{"test_class": {"identifier": "CassandraSpanStoreTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "CassandraSpanStore spanStore = spanStore(CassandraStorage.newBuilder());", "modifier": "", "type": "CassandraSpanStore", "declarator": "spanStore = spanStore(CassandraStorage.newBuilder())", "var_name": "spanStore"}, {"original_string": "QueryRequest.Builder queryBuilder = QueryRequest.newBuilder().endTs(TODAY).lookback(DAY).limit(5);", "modifier": "", "type": "QueryRequest.Builder", "declarator": "queryBuilder = QueryRequest.newBuilder().endTs(TODAY).lookback(DAY).limit(5)", "var_name": "queryBuilder"}], "file": "zipkin-storage/cassandra/src/test/java/zipkin2/storage/cassandra/CassandraSpanStoreTest.java"}, "test_case": {"identifier": "getTraces", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void getTraces() {\n    Call<List<List<Span>>> call = spanStore.getTraces(queryBuilder.serviceName(\"frontend\").build());\n\n    assertThat(call.toString()).contains(\"service=frontend, span=,\");\n  }", "signature": "void getTraces()", "full_signature": "@Test public void getTraces()", "class_method_signature": "CassandraSpanStoreTest.getTraces()", "testcase": true, "constructor": false, "invocations": ["getTraces", "build", "serviceName", "contains", "assertThat", "toString"]}, "focal_class": {"identifier": "CassandraSpanStore", "superclass": "", "interfaces": "implements SpanStore, Traces, ServiceAndSpanNames", "fields": [{"original_string": "static final Logger LOG = LoggerFactory.getLogger(CassandraSpanStore.class);", "modifier": "static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(CassandraSpanStore.class)", "var_name": "LOG"}, {"original_string": "final int indexFetchMultiplier;", "modifier": "final", "type": "int", "declarator": "indexFetchMultiplier", "var_name": "indexFetchMultiplier"}, {"original_string": "final boolean searchEnabled;", "modifier": "final", "type": "boolean", "declarator": "searchEnabled", "var_name": "searchEnabled"}, {"original_string": "final SelectFromSpan.Factory spans;", "modifier": "final", "type": "SelectFromSpan.Factory", "declarator": "spans", "var_name": "spans"}, {"original_string": "final SelectDependencies.Factory dependencies;", "modifier": "final", "type": "SelectDependencies.Factory", "declarator": "dependencies", "var_name": "dependencies"}, {"original_string": "final int indexTtl;", "modifier": "final", "type": "int", "declarator": "indexTtl", "var_name": "indexTtl"}, {"original_string": "@Nullable final Call<List<String>> serviceNames;", "modifier": "@Nullable final", "type": "Call<List<String>>", "declarator": "serviceNames", "var_name": "serviceNames"}, {"original_string": "@Nullable final SelectRemoteServiceNames.Factory remoteServiceNames;", "modifier": "@Nullable final", "type": "SelectRemoteServiceNames.Factory", "declarator": "remoteServiceNames", "var_name": "remoteServiceNames"}, {"original_string": "@Nullable final SelectSpanNames.Factory spanNames;", "modifier": "@Nullable final", "type": "SelectSpanNames.Factory", "declarator": "spanNames", "var_name": "spanNames"}, {"original_string": "@Nullable final SelectTraceIdsFromSpan.Factory spanTable;", "modifier": "@Nullable final", "type": "SelectTraceIdsFromSpan.Factory", "declarator": "spanTable", "var_name": "spanTable"}, {"original_string": "@Nullable final SelectTraceIdsFromServiceSpan.Factory traceIdsFromServiceSpan;", "modifier": "@Nullable final", "type": "SelectTraceIdsFromServiceSpan.Factory", "declarator": "traceIdsFromServiceSpan", "var_name": "traceIdsFromServiceSpan"}, {"original_string": "@Nullable final SelectTraceIdsFromServiceRemoteService.Factory traceIdsFromServiceRemoteService;", "modifier": "@Nullable final", "type": "SelectTraceIdsFromServiceRemoteService.Factory", "declarator": "traceIdsFromServiceRemoteService", "var_name": "traceIdsFromServiceRemoteService"}], "methods": [{"identifier": "CassandraSpanStore", "parameters": "(CassandraStorage storage)", "modifiers": "", "return": "", "signature": " CassandraSpanStore(CassandraStorage storage)", "full_signature": "  CassandraSpanStore(CassandraStorage storage)", "class_method_signature": "CassandraSpanStore.CassandraSpanStore(CassandraStorage storage)", "testcase": false, "constructor": true}, {"identifier": "initialiseSelectTraceIdsFromSpan", "parameters": "(Session session)", "modifiers": "static", "return": "SelectTraceIdsFromSpan.Factory", "signature": "SelectTraceIdsFromSpan.Factory initialiseSelectTraceIdsFromSpan(Session session)", "full_signature": "static SelectTraceIdsFromSpan.Factory initialiseSelectTraceIdsFromSpan(Session session)", "class_method_signature": "CassandraSpanStore.initialiseSelectTraceIdsFromSpan(Session session)", "testcase": false, "constructor": false}, {"identifier": "getTraces", "parameters": "(QueryRequest request)", "modifiers": "@Override public", "return": "Call<List<List<Span>>>", "signature": "Call<List<List<Span>>> getTraces(QueryRequest request)", "full_signature": "@Override public Call<List<List<Span>>> getTraces(QueryRequest request)", "class_method_signature": "CassandraSpanStore.getTraces(QueryRequest request)", "testcase": false, "constructor": false}, {"identifier": "newBucketedTraceIdCall", "parameters": "(\n    QueryRequest request, TimestampRange timestampRange, int traceIndexFetchSize)", "modifiers": "", "return": "Call<Map<String, Long>>", "signature": "Call<Map<String, Long>> newBucketedTraceIdCall(\n    QueryRequest request, TimestampRange timestampRange, int traceIndexFetchSize)", "full_signature": " Call<Map<String, Long>> newBucketedTraceIdCall(\n    QueryRequest request, TimestampRange timestampRange, int traceIndexFetchSize)", "class_method_signature": "CassandraSpanStore.newBucketedTraceIdCall(\n    QueryRequest request, TimestampRange timestampRange, int traceIndexFetchSize)", "testcase": false, "constructor": false}, {"identifier": "getTrace", "parameters": "(String traceId)", "modifiers": "@Override public", "return": "Call<List<Span>>", "signature": "Call<List<Span>> getTrace(String traceId)", "full_signature": "@Override public Call<List<Span>> getTrace(String traceId)", "class_method_signature": "CassandraSpanStore.getTrace(String traceId)", "testcase": false, "constructor": false}, {"identifier": "getTraces", "parameters": "(Iterable<String> traceIds)", "modifiers": "@Override public", "return": "Call<List<List<Span>>>", "signature": "Call<List<List<Span>>> getTraces(Iterable<String> traceIds)", "full_signature": "@Override public Call<List<List<Span>>> getTraces(Iterable<String> traceIds)", "class_method_signature": "CassandraSpanStore.getTraces(Iterable<String> traceIds)", "testcase": false, "constructor": false}, {"identifier": "getServiceNames", "parameters": "()", "modifiers": "@Override public", "return": "Call<List<String>>", "signature": "Call<List<String>> getServiceNames()", "full_signature": "@Override public Call<List<String>> getServiceNames()", "class_method_signature": "CassandraSpanStore.getServiceNames()", "testcase": false, "constructor": false}, {"identifier": "getRemoteServiceNames", "parameters": "(String serviceName)", "modifiers": "@Override public", "return": "Call<List<String>>", "signature": "Call<List<String>> getRemoteServiceNames(String serviceName)", "full_signature": "@Override public Call<List<String>> getRemoteServiceNames(String serviceName)", "class_method_signature": "CassandraSpanStore.getRemoteServiceNames(String serviceName)", "testcase": false, "constructor": false}, {"identifier": "getSpanNames", "parameters": "(String serviceName)", "modifiers": "@Override public", "return": "Call<List<String>>", "signature": "Call<List<String>> getSpanNames(String serviceName)", "full_signature": "@Override public Call<List<String>> getSpanNames(String serviceName)", "class_method_signature": "CassandraSpanStore.getSpanNames(String serviceName)", "testcase": false, "constructor": false}, {"identifier": "getDependencies", "parameters": "(long endTs, long lookback)", "modifiers": "@Override public", "return": "Call<List<DependencyLink>>", "signature": "Call<List<DependencyLink>> getDependencies(long endTs, long lookback)", "full_signature": "@Override public Call<List<DependencyLink>> getDependencies(long endTs, long lookback)", "class_method_signature": "CassandraSpanStore.getDependencies(long endTs, long lookback)", "testcase": false, "constructor": false}, {"identifier": "timestampRange", "parameters": "(QueryRequest request)", "modifiers": "", "return": "TimestampRange", "signature": "TimestampRange timestampRange(QueryRequest request)", "full_signature": " TimestampRange timestampRange(QueryRequest request)", "class_method_signature": "CassandraSpanStore.timestampRange(QueryRequest request)", "testcase": false, "constructor": false}], "file": "zipkin-storage/cassandra/src/main/java/zipkin2/storage/cassandra/CassandraSpanStore.java"}, "focal_method": {"identifier": "getTraces", "parameters": "(QueryRequest request)", "modifiers": "@Override public", "return": "Call<List<List<Span>>>", "body": "@Override\n  public Call<List<List<Span>>> getTraces(QueryRequest request) {\n    if (!searchEnabled) return Call.emptyList();\n\n    TimestampRange timestampRange = timestampRange(request);\n    // If we have to make multiple queries, over fetch on indexes as they don't return distinct\n    // (trace id, timestamp) rows. This mitigates intersection resulting in < limit traces\n    final int traceIndexFetchSize = request.limit() * indexFetchMultiplier;\n    List<Call<Map<String, Long>>> callsToIntersect = new ArrayList<>();\n\n    List<String> annotationKeys = CassandraUtil.annotationKeys(request);\n    for (String annotationKey : annotationKeys) {\n      if (spanTable == null) {\n        throw new IllegalArgumentException(request.annotationQueryString()\n          + \" query unsupported due to missing annotation_query index\");\n      }\n      callsToIntersect.add(\n        spanTable.newCall(request.serviceName(), annotationKey, timestampRange, traceIndexFetchSize)\n      );\n    }\n\n    // Bucketed calls can be expensive when service name isn't specified. This guards against abuse.\n    if (request.remoteServiceName() != null\n      || request.spanName() != null\n      || request.minDuration() != null\n      || callsToIntersect.isEmpty()) {\n      callsToIntersect.add(newBucketedTraceIdCall(request, timestampRange, traceIndexFetchSize));\n    }\n\n    if (callsToIntersect.size() == 1) {\n      return callsToIntersect\n        .get(0)\n        .map(traceIdsSortedByDescTimestamp())\n        .flatMap(spans.newFlatMapper(request));\n    }\n\n    // We achieve the AND goal, by intersecting each of the key sets.\n    IntersectKeySets intersectedTraceIds = new IntersectKeySets(callsToIntersect);\n    // @xxx the sorting by timestamp desc is broken here^\n    return intersectedTraceIds.flatMap(spans.newFlatMapper(request));\n  }", "signature": "Call<List<List<Span>>> getTraces(QueryRequest request)", "full_signature": "@Override public Call<List<List<Span>>> getTraces(QueryRequest request)", "class_method_signature": "CassandraSpanStore.getTraces(QueryRequest request)", "testcase": false, "constructor": false, "invocations": ["emptyList", "timestampRange", "limit", "annotationKeys", "annotationQueryString", "add", "newCall", "serviceName", "remoteServiceName", "spanName", "minDuration", "isEmpty", "add", "newBucketedTraceIdCall", "size", "flatMap", "map", "get", "traceIdsSortedByDescTimestamp", "newFlatMapper", "flatMap", "newFlatMapper"]}, "repository": {"repo_id": 4576305, "url": "https://github.com/openzipkin/zipkin", "stars": 12365, "created": "6/6/2012 6:26:16 PM +00:00", "updates": "2020-01-27T10:22:48+00:00", "fork": "False", "license": "licensed"}}