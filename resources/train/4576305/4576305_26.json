{"test_class": {"identifier": "ScribeSpanConsumerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "InMemoryCollectorMetrics scribeMetrics = new InMemoryCollectorMetrics().forTransport(\"scribe\");", "modifier": "", "type": "InMemoryCollectorMetrics", "declarator": "scribeMetrics = new InMemoryCollectorMetrics().forTransport(\"scribe\")", "var_name": "scribeMetrics"}, {"original_string": "InMemoryStorage storage = InMemoryStorage.newBuilder().build();", "modifier": "", "type": "InMemoryStorage", "declarator": "storage = InMemoryStorage.newBuilder().build()", "var_name": "storage"}, {"original_string": "SpanConsumer consumer = storage.spanConsumer();", "modifier": "", "type": "SpanConsumer", "declarator": "consumer = storage.spanConsumer()", "var_name": "consumer"}, {"original_string": "static String reallyLongAnnotation;", "modifier": "static", "type": "String", "declarator": "reallyLongAnnotation", "var_name": "reallyLongAnnotation"}, {"original_string": "Endpoint zipkinQuery =\n    Endpoint.newBuilder().serviceName(\"zipkin-query\").ip(\"127.0.0.1\").port(9411).build();", "modifier": "", "type": "Endpoint", "declarator": "zipkinQuery =\n    Endpoint.newBuilder().serviceName(\"zipkin-query\").ip(\"127.0.0.1\").port(9411).build()", "var_name": "zipkinQuery"}, {"original_string": "Endpoint zipkinQuery0 = zipkinQuery.toBuilder().port(null).build();", "modifier": "", "type": "Endpoint", "declarator": "zipkinQuery0 = zipkinQuery.toBuilder().port(null).build()", "var_name": "zipkinQuery0"}, {"original_string": "V1Span v1 = V1Span.newBuilder()\n    .traceId(-6054243957716233329L)\n    .name(\"getTracesByIds\")\n    .id(-3615651937927048332L)\n    .parentId(-6054243957716233329L)\n    .addAnnotation(1442493420635000L, \"sr\", zipkinQuery)\n    .addAnnotation(1442493420747000L, reallyLongAnnotation, zipkinQuery)\n    .addAnnotation(\n      1442493422583586L,\n      \"Gc(9,0.PSScavenge,2015-09-17 12:37:02 +0000,304.milliseconds+762.microseconds)\",\n      zipkinQuery)\n    .addAnnotation(1442493422680000L, \"ss\", zipkinQuery)\n    .addBinaryAnnotation(\"srv/finagle.version\", \"6.28.0\", zipkinQuery0)\n    .addBinaryAnnotation(\"sa\", zipkinQuery)\n    .addBinaryAnnotation(\"ca\", zipkinQuery.toBuilder().port(63840).build())\n    .debug(false)\n    .build();", "modifier": "", "type": "V1Span", "declarator": "v1 = V1Span.newBuilder()\n    .traceId(-6054243957716233329L)\n    .name(\"getTracesByIds\")\n    .id(-3615651937927048332L)\n    .parentId(-6054243957716233329L)\n    .addAnnotation(1442493420635000L, \"sr\", zipkinQuery)\n    .addAnnotation(1442493420747000L, reallyLongAnnotation, zipkinQuery)\n    .addAnnotation(\n      1442493422583586L,\n      \"Gc(9,0.PSScavenge,2015-09-17 12:37:02 +0000,304.milliseconds+762.microseconds)\",\n      zipkinQuery)\n    .addAnnotation(1442493422680000L, \"ss\", zipkinQuery)\n    .addBinaryAnnotation(\"srv/finagle.version\", \"6.28.0\", zipkinQuery0)\n    .addBinaryAnnotation(\"sa\", zipkinQuery)\n    .addBinaryAnnotation(\"ca\", zipkinQuery.toBuilder().port(63840).build())\n    .debug(false)\n    .build()", "var_name": "v1"}, {"original_string": "Span v2 = V1SpanConverter.create().convert(v1).get(0);", "modifier": "", "type": "Span", "declarator": "v2 = V1SpanConverter.create().convert(v1).get(0)", "var_name": "v2"}, {"original_string": "byte[] bytes = SpanBytesEncoder.THRIFT.encode(v2);", "modifier": "", "type": "byte[]", "declarator": "bytes = SpanBytesEncoder.THRIFT.encode(v2)", "var_name": "bytes"}, {"original_string": "String encodedSpan = new String(Base64.getEncoder().encode(bytes), UTF_8);", "modifier": "", "type": "String", "declarator": "encodedSpan = new String(Base64.getEncoder().encode(bytes), UTF_8)", "var_name": "encodedSpan"}], "file": "zipkin-collector/scribe/src/test/java/zipkin2/collector/scribe/ScribeSpanConsumerTest.java"}, "test_case": {"identifier": "malformedDataIsDropped", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test void malformedDataIsDropped() {\n    ScribeSpanConsumer scribe = newScribeSpanConsumer(\"zipkin\", consumer);\n\n    LogEntry entry = new LogEntry();\n    entry.category = \"zipkin\";\n    entry.message = \"notbase64\";\n\n    CaptureAsyncMethodCallback callback = new CaptureAsyncMethodCallback();\n    scribe.Log(asList(entry), callback);\n    assertThat(callback.error).isInstanceOf(IllegalArgumentException.class);\n\n    // Storage finishes after callback so wait for it.\n    await().untilAsserted(() -> assertThat(scribeMetrics.messages()).isEqualTo(1));\n    assertThat(scribeMetrics.messagesDropped()).isEqualTo(1);\n    assertThat(scribeMetrics.bytes()).isZero();\n    assertThat(scribeMetrics.spans()).isZero();\n    assertThat(scribeMetrics.spansDropped()).isZero();\n  }", "signature": "void malformedDataIsDropped()", "full_signature": "@Test void malformedDataIsDropped()", "class_method_signature": "ScribeSpanConsumerTest.malformedDataIsDropped()", "testcase": true, "constructor": false, "invocations": ["newScribeSpanConsumer", "Log", "asList", "isInstanceOf", "assertThat", "untilAsserted", "await", "isEqualTo", "assertThat", "messages", "isEqualTo", "assertThat", "messagesDropped", "isZero", "assertThat", "bytes", "isZero", "assertThat", "spans", "isZero", "assertThat", "spansDropped"]}, "focal_class": {"identifier": "ScribeSpanConsumer", "superclass": "", "interfaces": "implements Scribe.AsyncIface", "fields": [{"original_string": "final Collector collector;", "modifier": "final", "type": "Collector", "declarator": "collector", "var_name": "collector"}, {"original_string": "final CollectorMetrics metrics;", "modifier": "final", "type": "CollectorMetrics", "declarator": "metrics", "var_name": "metrics"}, {"original_string": "final String category;", "modifier": "final", "type": "String", "declarator": "category", "var_name": "category"}], "methods": [{"identifier": "ScribeSpanConsumer", "parameters": "(Collector collector, CollectorMetrics metrics, String category)", "modifiers": "", "return": "", "signature": " ScribeSpanConsumer(Collector collector, CollectorMetrics metrics, String category)", "full_signature": "  ScribeSpanConsumer(Collector collector, CollectorMetrics metrics, String category)", "class_method_signature": "ScribeSpanConsumer.ScribeSpanConsumer(Collector collector, CollectorMetrics metrics, String category)", "testcase": false, "constructor": true}, {"identifier": "Log", "parameters": "(List<LogEntry> messages, AsyncMethodCallback<ResultCode> resultHandler)", "modifiers": "@Override public", "return": "void", "signature": "void Log(List<LogEntry> messages, AsyncMethodCallback<ResultCode> resultHandler)", "full_signature": "@Override public void Log(List<LogEntry> messages, AsyncMethodCallback<ResultCode> resultHandler)", "class_method_signature": "ScribeSpanConsumer.Log(List<LogEntry> messages, AsyncMethodCallback<ResultCode> resultHandler)", "testcase": false, "constructor": false}], "file": "zipkin-collector/scribe/src/main/java/zipkin2/collector/scribe/ScribeSpanConsumer.java"}, "focal_method": {"identifier": "Log", "parameters": "(List<LogEntry> messages, AsyncMethodCallback<ResultCode> resultHandler)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void Log(List<LogEntry> messages, AsyncMethodCallback<ResultCode> resultHandler) {\n    metrics.incrementMessages();\n    List<Span> spans = new ArrayList<>();\n    int byteCount = 0;\n    try {\n      for (LogEntry logEntry : messages) {\n        if (!category.equals(logEntry.category)) continue;\n        byte[] bytes = logEntry.message.getBytes(StandardCharsets.ISO_8859_1);\n        bytes = Base64.getMimeDecoder().decode(bytes); // finagle-zipkin uses mime encoding\n        byteCount += bytes.length;\n        spans.add(SpanBytesDecoder.THRIFT.decodeOne(bytes));\n      }\n    } catch (RuntimeException e) {\n      metrics.incrementMessagesDropped();\n      resultHandler.onError(e);\n      return;\n    } finally {\n      metrics.incrementBytes(byteCount);\n    }\n\n    collector.accept(spans, new Callback<Void>() {\n      @Override public void onSuccess(Void value) {\n        resultHandler.onComplete(ResultCode.OK);\n      }\n\n      @Override public void onError(Throwable t) {\n        Exception error = t instanceof Exception ? (Exception) t : new RuntimeException(t);\n        resultHandler.onError(error);\n      }\n    // Collectors may not be asynchronous so switch to blocking executor here.\n    }, CommonPools.blockingTaskExecutor());\n  }", "signature": "void Log(List<LogEntry> messages, AsyncMethodCallback<ResultCode> resultHandler)", "full_signature": "@Override public void Log(List<LogEntry> messages, AsyncMethodCallback<ResultCode> resultHandler)", "class_method_signature": "ScribeSpanConsumer.Log(List<LogEntry> messages, AsyncMethodCallback<ResultCode> resultHandler)", "testcase": false, "constructor": false, "invocations": ["incrementMessages", "equals", "getBytes", "decode", "getMimeDecoder", "add", "decodeOne", "incrementMessagesDropped", "onError", "incrementBytes", "accept", "onComplete", "onError", "blockingTaskExecutor"]}, "repository": {"repo_id": 4576305, "url": "https://github.com/openzipkin/zipkin", "stars": 12365, "created": "6/6/2012 6:26:16 PM +00:00", "updates": "2020-01-27T10:22:48+00:00", "fork": "False", "license": "licensed"}}