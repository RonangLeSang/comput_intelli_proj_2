{"test_class": {"identifier": "TestQuiescingStreamManager", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final QuiescingStreamManager manager = new QuiescingStreamManager();", "modifier": "private final", "type": "QuiescingStreamManager", "declarator": "manager = new QuiescingStreamManager()", "var_name": "manager"}], "file": "akubra-qsc/src/test/java/org/akubraproject/qsc/TestQuiescingStreamManager.java"}, "test_case": {"identifier": "testGoUnquiescentBlocking", "parameters": "()", "modifiers": "@Test(dependsOnGroups = { \"init\" }) public", "return": "void", "body": "@Test(dependsOnGroups = { \"init\" })\n  public void testGoUnquiescentBlocking() throws Exception {\n    assertTrue(manager.setQuiescent(true));\n    LockUnquiescedThread thread = new LockUnquiescedThread(manager);\n    thread.start();\n    Thread.sleep(100);\n    assertTrue(thread.isAlive()); // thread should be blocking\n    assertTrue(manager.setQuiescent(false));\n    thread.join();                // thread will now terminate; wait for it\n    assertNull(thread.getException());\n  }", "signature": "void testGoUnquiescentBlocking()", "full_signature": "@Test(dependsOnGroups = { \"init\" }) public void testGoUnquiescentBlocking()", "class_method_signature": "TestQuiescingStreamManager.testGoUnquiescentBlocking()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "setQuiescent", "start", "sleep", "assertTrue", "isAlive", "assertTrue", "setQuiescent", "join", "assertNull", "getException"]}, "focal_class": {"identifier": "QuiescingStreamManager", "superclass": "extends StreamManager", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(QuiescingStreamManager.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(QuiescingStreamManager.class)", "var_name": "log"}, {"original_string": "private final ReentrantLock stateLock = new ReentrantLock(true);", "modifier": "private final", "type": "ReentrantLock", "declarator": "stateLock = new ReentrantLock(true)", "var_name": "stateLock"}, {"original_string": "private final Condition becameUnquiescent = stateLock.newCondition();", "modifier": "private final", "type": "Condition", "declarator": "becameUnquiescent = stateLock.newCondition()", "var_name": "becameUnquiescent"}, {"original_string": "private boolean quiescent;", "modifier": "private", "type": "boolean", "declarator": "quiescent", "var_name": "quiescent"}, {"original_string": "private final Set<QuiescingBlobStoreConnection> txnCons = new HashSet<QuiescingBlobStoreConnection>();", "modifier": "private final", "type": "Set<QuiescingBlobStoreConnection>", "declarator": "txnCons = new HashSet<QuiescingBlobStoreConnection>()", "var_name": "txnCons"}, {"original_string": "private final Set<QuiescingBlobStoreConnection> rawCons = new HashSet<QuiescingBlobStoreConnection>();", "modifier": "private final", "type": "Set<QuiescingBlobStoreConnection>", "declarator": "rawCons = new HashSet<QuiescingBlobStoreConnection>()", "var_name": "rawCons"}], "methods": [{"identifier": "register", "parameters": "(final QuiescingBlobStoreConnection con, Transaction tx)", "modifiers": "", "return": "void", "signature": "void register(final QuiescingBlobStoreConnection con, Transaction tx)", "full_signature": " void register(final QuiescingBlobStoreConnection con, Transaction tx)", "class_method_signature": "QuiescingStreamManager.register(final QuiescingBlobStoreConnection con, Transaction tx)", "testcase": false, "constructor": false}, {"identifier": "unregister", "parameters": "(QuiescingBlobStoreConnection con, boolean transactional)", "modifiers": "", "return": "void", "signature": "void unregister(QuiescingBlobStoreConnection con, boolean transactional)", "full_signature": " void unregister(QuiescingBlobStoreConnection con, boolean transactional)", "class_method_signature": "QuiescingStreamManager.unregister(QuiescingBlobStoreConnection con, boolean transactional)", "testcase": false, "constructor": false}, {"identifier": "lockUnquiesced", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void lockUnquiesced()", "full_signature": "public void lockUnquiesced()", "class_method_signature": "QuiescingStreamManager.lockUnquiesced()", "testcase": false, "constructor": false}, {"identifier": "unlockState", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void unlockState()", "full_signature": "public void unlockState()", "class_method_signature": "QuiescingStreamManager.unlockState()", "testcase": false, "constructor": false}, {"identifier": "setQuiescent", "parameters": "(boolean quiescent)", "modifiers": "public", "return": "boolean", "signature": "boolean setQuiescent(boolean quiescent)", "full_signature": "public boolean setQuiescent(boolean quiescent)", "class_method_signature": "QuiescingStreamManager.setQuiescent(boolean quiescent)", "testcase": false, "constructor": false}, {"identifier": "countWriteTransactions", "parameters": "()", "modifiers": "private", "return": "int", "signature": "int countWriteTransactions()", "full_signature": "private int countWriteTransactions()", "class_method_signature": "QuiescingStreamManager.countWriteTransactions()", "testcase": false, "constructor": false}, {"identifier": "manageOutputStream", "parameters": "(BlobStoreConnection con, OutputStream stream)", "modifiers": "@Override public", "return": "OutputStream", "signature": "OutputStream manageOutputStream(BlobStoreConnection con, OutputStream stream)", "full_signature": "@Override public OutputStream manageOutputStream(BlobStoreConnection con, OutputStream stream)", "class_method_signature": "QuiescingStreamManager.manageOutputStream(BlobStoreConnection con, OutputStream stream)", "testcase": false, "constructor": false}, {"identifier": "lockIOE", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void lockIOE()", "full_signature": "private void lockIOE()", "class_method_signature": "QuiescingStreamManager.lockIOE()", "testcase": false, "constructor": false}, {"identifier": "isQuiescent", "parameters": "()", "modifiers": "", "return": "boolean", "signature": "boolean isQuiescent()", "full_signature": " boolean isQuiescent()", "class_method_signature": "QuiescingStreamManager.isQuiescent()", "testcase": false, "constructor": false}], "file": "akubra-qsc/src/main/java/org/akubraproject/qsc/QuiescingStreamManager.java"}, "focal_method": {"identifier": "setQuiescent", "parameters": "(boolean quiescent)", "modifiers": "public", "return": "boolean", "body": "public boolean setQuiescent(boolean quiescent) throws IOException {\n    try {\n      stateLock.lockInterruptibly();\n\n      if (quiescent && !this.quiescent) {\n        synchronized (openOutputStreams) {\n          while (!openOutputStreams.isEmpty()) {\n            log.info(\"setQuiescent: Waiting for \" + openOutputStreams.size() +\n                     \" output streams to close...\");\n            openOutputStreams.wait(); // wake up when next one is closed\n          }\n        }\n\n        synchronized (txnCons) {\n          int cnt;\n          while ((cnt = countWriteTransactions()) > 0) {\n            log.info(\"setQuiescent: Waiting for \" + cnt + \" write transactions to close...\");\n            txnCons.wait(); // wake up when next one is completed\n          }\n        }\n\n        synchronized (rawCons) {\n          for (QuiescingBlobStoreConnection con : rawCons) {\n            if (con.hasModifications())\n              con.sync();\n          }\n        }\n\n        log.info(\"setQuiescent: No open output streams or active write transactions. \" +\n                 \"Entering quiescent state.\");\n      }\n\n      if (!quiescent && this.quiescent) {\n        log.info(\"setQuiescent: Exiting quiescent state.\");\n        becameUnquiescent.signalAll();\n      }\n\n      this.quiescent = quiescent;\n      return true;\n    } catch (InterruptedException ie) {\n      if (quiescent)\n        log.warn(\"Interrupted while waiting to enter quiescent state\", ie);\n      else\n        log.warn(\"Interrupted while waiting to exit quiescent state\", ie);\n      return false;\n    } finally {\n      if (stateLock.isHeldByCurrentThread())\n        stateLock.unlock();\n    }\n  }", "signature": "boolean setQuiescent(boolean quiescent)", "full_signature": "public boolean setQuiescent(boolean quiescent)", "class_method_signature": "QuiescingStreamManager.setQuiescent(boolean quiescent)", "testcase": false, "constructor": false, "invocations": ["lockInterruptibly", "isEmpty", "info", "size", "wait", "countWriteTransactions", "info", "wait", "hasModifications", "sync", "info", "info", "signalAll", "warn", "warn", "isHeldByCurrentThread", "unlock"]}, "repository": {"repo_id": 1146205, "url": "https://github.com/akubra/akubra", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 11, "size": 5955, "license": "licensed"}}