{"test_class": {"identifier": "NormalizationTransformTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double DELTA = 1e-6;", "modifier": "private static final", "type": "double", "declarator": "DELTA = 1e-6", "var_name": "DELTA"}], "file": "servo-core/src/test/java/com/netflix/servo/publish/NormalizationTransformTest.java"}, "test_case": {"identifier": "testUpdate", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testUpdate() throws Exception {\n    BasicCounter basicCounter = new BasicCounter(MonitorConfig.builder(\"basicCounter\").build());\n    ManualClock manualClock = new ManualClock(0);\n    StepCounter stepCounter = new StepCounter(MonitorConfig.builder(\"stepCounter\").build(),\n        manualClock);\n    LongGauge gauge = new LongGauge(MonitorConfig.builder(\"longGauge\").build());\n\n    List<? extends AbstractMonitor<? extends Number>> monitors = UnmodifiableList.of(basicCounter,\n        stepCounter, gauge);\n\n    MemoryMetricObserver observer = new MemoryMetricObserver(\"normalization-test\", 1);\n    NormalizationTransform normalizationTransform = new NormalizationTransform(observer, 60,\n        120, TimeUnit.SECONDS, manualClock);\n    CounterToRateMetricTransform toRateMetricTransform =\n        new CounterToRateMetricTransform(normalizationTransform, 60,\n            120, TimeUnit.SECONDS, manualClock);\n\n    double[] rates = {0.5 / 60.0, 2 / 60.0, 3 / 60.0, 4 / 60.0};\n    double[] expectedNormalized = {\n        rates[0] * (2.0 / 3.0), // 20000L over stepBoundary\n        rates[0] * (1.0 / 3.0) + rates[1] * (2.0 / 3.0),\n        rates[1] * (1.0 / 3.0) + rates[2] * (2.0 / 3.0),\n        rates[2] * (1.0 / 3.0) + rates[3] * (2.0 / 3.0)};\n\n    for (int i = 1; i < 5; ++i) {\n      long now = 20000L + i * 60000L;\n      long stepBoundary = i * 60000L;\n      manualClock.set(now);\n      basicCounter.increment(i);\n      stepCounter.increment(i);\n      gauge.set((long) i);\n      List<Metric> metrics = getValue(monitors, manualClock);\n      toRateMetricTransform.update(metrics);\n\n      List<Metric> o = observer.getObservations().get(0);\n      assertEquals(o.size(), 3);\n      double basicCounterVal = o.get(0).getNumberValue().doubleValue();\n      double stepCounterVal = o.get(1).getNumberValue().doubleValue();\n      double gaugeVal = o.get(2).getNumberValue().doubleValue();\n      assertEquals(gaugeVal, (double) i, DELTA);\n      // rate per second for the prev interval\n      assertEquals(stepCounterVal, (i - 1) / 60.0, DELTA);\n      assertEquals(basicCounterVal, expectedNormalized[i - 1], DELTA);\n\n      for (Metric m : o) {\n        assertEquals(m.getTimestamp(), stepBoundary);\n      }\n    }\n\n    // no updates to anything, just clock forward\n    int i = 5;\n    manualClock.set(i * 60000L + 20000L);\n    List<Metric> metrics = getValue(monitors, manualClock);\n    toRateMetricTransform.update(metrics);\n    List<Metric> o = observer.getObservations().get(0);\n    assertEquals(o.size(), 3);\n\n    double basicCounterVal = o.get(0).getNumberValue().doubleValue();\n    double stepCounterVal = o.get(1).getNumberValue().doubleValue();\n    double gaugeVal = o.get(2).getNumberValue().doubleValue();\n\n    assertEquals(gaugeVal, (double) 4, DELTA); // last set value\n    assertEquals(stepCounterVal, 4 / 60.0, DELTA);\n    assertEquals(basicCounterVal, (1 / 3.0) * rates[3]);\n  }", "signature": "void testUpdate()", "full_signature": "@Test public void testUpdate()", "class_method_signature": "NormalizationTransformTest.testUpdate()", "testcase": true, "constructor": false, "invocations": ["build", "builder", "build", "builder", "build", "builder", "of", "set", "increment", "increment", "set", "getValue", "update", "get", "getObservations", "assertEquals", "size", "doubleValue", "getNumberValue", "get", "doubleValue", "getNumberValue", "get", "doubleValue", "getNumberValue", "get", "assertEquals", "assertEquals", "assertEquals", "assertEquals", "getTimestamp", "set", "getValue", "update", "get", "getObservations", "assertEquals", "size", "doubleValue", "getNumberValue", "get", "doubleValue", "getNumberValue", "get", "doubleValue", "getNumberValue", "get", "assertEquals", "assertEquals", "assertEquals"]}, "focal_class": {"identifier": "NormalizationTransform", "superclass": "", "interfaces": "implements MetricObserver", "fields": [{"original_string": "private static final Logger LOGGER =\n      LoggerFactory.getLogger(NormalizationTransform.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER =\n      LoggerFactory.getLogger(NormalizationTransform.class)", "var_name": "LOGGER"}, {"original_string": "private static final String DEFAULT_DSTYPE = DataSourceType.RATE.name();", "modifier": "private static final", "type": "String", "declarator": "DEFAULT_DSTYPE = DataSourceType.RATE.name()", "var_name": "DEFAULT_DSTYPE"}, {"original_string": "@VisibleForTesting\n  static final Counter HEARTBEAT_EXCEEDED = newCounter(\"servo.norm.heartbeatExceeded\");", "modifier": "@VisibleForTesting\n  static final", "type": "Counter", "declarator": "HEARTBEAT_EXCEEDED = newCounter(\"servo.norm.heartbeatExceeded\")", "var_name": "HEARTBEAT_EXCEEDED"}, {"original_string": "private final MetricObserver observer;", "modifier": "private final", "type": "MetricObserver", "declarator": "observer", "var_name": "observer"}, {"original_string": "private final long heartbeatMillis;", "modifier": "private final", "type": "long", "declarator": "heartbeatMillis", "var_name": "heartbeatMillis"}, {"original_string": "private final long stepMillis;", "modifier": "private final", "type": "long", "declarator": "stepMillis", "var_name": "stepMillis"}, {"original_string": "private final Map<MonitorConfig, NormalizedValue> cache;", "modifier": "private final", "type": "Map<MonitorConfig, NormalizedValue>", "declarator": "cache", "var_name": "cache"}, {"original_string": "private static final long NO_PREVIOUS_UPDATE = -1L;", "modifier": "private static final", "type": "long", "declarator": "NO_PREVIOUS_UPDATE = -1L", "var_name": "NO_PREVIOUS_UPDATE"}], "methods": [{"identifier": "newCounter", "parameters": "(String name)", "modifiers": "static", "return": "Counter", "signature": "Counter newCounter(String name)", "full_signature": "static Counter newCounter(String name)", "class_method_signature": "NormalizationTransform.newCounter(String name)", "testcase": false, "constructor": false}, {"identifier": "NormalizationTransform", "parameters": "(MetricObserver observer, long step, long heartbeat)", "modifiers": "@Deprecated public", "return": "", "signature": " NormalizationTransform(MetricObserver observer, long step, long heartbeat)", "full_signature": "@Deprecated public  NormalizationTransform(MetricObserver observer, long step, long heartbeat)", "class_method_signature": "NormalizationTransform.NormalizationTransform(MetricObserver observer, long step, long heartbeat)", "testcase": false, "constructor": true}, {"identifier": "NormalizationTransform", "parameters": "(MetricObserver observer, long step, final long heartbeat,\n                                final Clock clock)", "modifiers": "@Deprecated public", "return": "", "signature": " NormalizationTransform(MetricObserver observer, long step, final long heartbeat,\n                                final Clock clock)", "full_signature": "@Deprecated public  NormalizationTransform(MetricObserver observer, long step, final long heartbeat,\n                                final Clock clock)", "class_method_signature": "NormalizationTransform.NormalizationTransform(MetricObserver observer, long step, final long heartbeat,\n                                final Clock clock)", "testcase": false, "constructor": true}, {"identifier": "NormalizationTransform", "parameters": "(MetricObserver observer, long step, long heartbeat,\n                                TimeUnit unit)", "modifiers": "public", "return": "", "signature": " NormalizationTransform(MetricObserver observer, long step, long heartbeat,\n                                TimeUnit unit)", "full_signature": "public  NormalizationTransform(MetricObserver observer, long step, long heartbeat,\n                                TimeUnit unit)", "class_method_signature": "NormalizationTransform.NormalizationTransform(MetricObserver observer, long step, long heartbeat,\n                                TimeUnit unit)", "testcase": false, "constructor": true}, {"identifier": "NormalizationTransform", "parameters": "(MetricObserver observer, long step, final long heartbeat,\n                                TimeUnit unit, final Clock clock)", "modifiers": "public", "return": "", "signature": " NormalizationTransform(MetricObserver observer, long step, final long heartbeat,\n                                TimeUnit unit, final Clock clock)", "full_signature": "public  NormalizationTransform(MetricObserver observer, long step, final long heartbeat,\n                                TimeUnit unit, final Clock clock)", "class_method_signature": "NormalizationTransform.NormalizationTransform(MetricObserver observer, long step, final long heartbeat,\n                                TimeUnit unit, final Clock clock)", "testcase": false, "constructor": true}, {"identifier": "getDataSourceType", "parameters": "(Metric m)", "modifiers": "private static", "return": "String", "signature": "String getDataSourceType(Metric m)", "full_signature": "private static String getDataSourceType(Metric m)", "class_method_signature": "NormalizationTransform.getDataSourceType(Metric m)", "testcase": false, "constructor": false}, {"identifier": "isGauge", "parameters": "(String dsType)", "modifiers": "private static", "return": "boolean", "signature": "boolean isGauge(String dsType)", "full_signature": "private static boolean isGauge(String dsType)", "class_method_signature": "NormalizationTransform.isGauge(String dsType)", "testcase": false, "constructor": false}, {"identifier": "isRate", "parameters": "(String dsType)", "modifiers": "private static", "return": "boolean", "signature": "boolean isRate(String dsType)", "full_signature": "private static boolean isRate(String dsType)", "class_method_signature": "NormalizationTransform.isRate(String dsType)", "testcase": false, "constructor": false}, {"identifier": "isNormalized", "parameters": "(String dsType)", "modifiers": "private static", "return": "boolean", "signature": "boolean isNormalized(String dsType)", "full_signature": "private static boolean isNormalized(String dsType)", "class_method_signature": "NormalizationTransform.isNormalized(String dsType)", "testcase": false, "constructor": false}, {"identifier": "isInformational", "parameters": "(String dsType)", "modifiers": "private static", "return": "boolean", "signature": "boolean isInformational(String dsType)", "full_signature": "private static boolean isInformational(String dsType)", "class_method_signature": "NormalizationTransform.isInformational(String dsType)", "testcase": false, "constructor": false}, {"identifier": "normalize", "parameters": "(Metric m, long stepBoundary)", "modifiers": "private", "return": "Metric", "signature": "Metric normalize(Metric m, long stepBoundary)", "full_signature": "private Metric normalize(Metric m, long stepBoundary)", "class_method_signature": "NormalizationTransform.normalize(Metric m, long stepBoundary)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(List<Metric> metrics)", "modifiers": "@Override public", "return": "void", "signature": "void update(List<Metric> metrics)", "full_signature": "@Override public void update(List<Metric> metrics)", "class_method_signature": "NormalizationTransform.update(List<Metric> metrics)", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "NormalizationTransform.getName()", "testcase": false, "constructor": false}], "file": "servo-core/src/main/java/com/netflix/servo/publish/NormalizationTransform.java"}, "focal_method": {"identifier": "update", "parameters": "(List<Metric> metrics)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void update(List<Metric> metrics) {\n    Preconditions.checkNotNull(metrics, \"metrics\");\n    final List<Metric> newMetrics = new ArrayList<>(metrics.size());\n\n    for (Metric m : metrics) {\n      long offset = m.getTimestamp() % stepMillis;\n      long stepBoundary = m.getTimestamp() - offset;\n      String dsType = getDataSourceType(m);\n      if (isGauge(dsType) || isNormalized(dsType)) {\n        Metric atStepBoundary = new Metric(m.getConfig(), stepBoundary, m.getValue());\n        newMetrics.add(atStepBoundary); // gauges are not normalized\n      } else if (isRate(dsType)) {\n        Metric normalized = normalize(m, stepBoundary);\n        if (normalized != null) {\n          newMetrics.add(normalized);\n        }\n      } else if (!isInformational(dsType)) {\n        // unknown type - use a safe fallback\n        newMetrics.add(m); // we cannot normalize this\n      }\n    }\n    observer.update(newMetrics);\n  }", "signature": "void update(List<Metric> metrics)", "full_signature": "@Override public void update(List<Metric> metrics)", "class_method_signature": "NormalizationTransform.update(List<Metric> metrics)", "testcase": false, "constructor": false, "invocations": ["checkNotNull", "size", "getTimestamp", "getTimestamp", "getDataSourceType", "isGauge", "isNormalized", "getConfig", "getValue", "add", "isRate", "normalize", "add", "isInformational", "add", "update"]}, "repository": {"repo_id": 2997701, "url": "https://github.com/Netflix/servo", "language": "Java", "is_fork": false, "fork_count": 281, "stargazer_count": 1326, "size": 5380, "license": "licensed"}}