{"test_class": {"identifier": "IndexNodeByOtherNodeIndexerTest", "superclass": "", "interfaces": "", "fields": [], "file": "queries/src/test/java/org/neo4j/graphdatabases/queries/helpers/IndexNodeByOtherNodeIndexerTest.java"}, "test_case": {"identifier": "shouldIndexNodesByOtherNodes", "parameters": "()", "modifiers": "@Test @Ignore(\"Doesn't work like that, the code used to index multiple children under one parent, not possible with the new indexes\") public", "return": "void", "body": "@Test\n    @Ignore(\"Doesn't work like that, the code used to index multiple children under one parent, not possible with the new indexes\")\n    public void shouldIndexNodesByOtherNodes() throws Exception\n    {\n        // given\n        String cypher = \"CREATE (a:Parent {name:'a'}), \\n\" +\n                \"(b:Child {name:'b'}), \\n\" +\n                \"(c:Child {name:'c'}), \\n\" +\n                \"(d:Child {name:'d'}), \\n\" +\n                \"(e:Child {name:'e'}), \\n\" +\n                \"(f:Child {name:'f'}),\\n\" +\n                \"(g:Child {name:'g'}),\\n\" +\n                \"(h:Child {name:'h'}),\\n\" +\n                \"a-[:CONNECTED_TO]->b,\\n\" +\n                \"a-[:CONNECTED_TO]->c,\\n\" +\n                \"a-[:CONNECTED_TO]->g,\\n\" +\n                \"d-[:CONNECTED_TO]->e,\\n\" +\n                \"d-[:CONNECTED_TO]->f,\\n\" +\n                \"d-[:CONNECTED_TO]->h\";\n\n        final GraphDatabaseService db = createFromCypher(\n                \"Example\",\n                cypher,\n                IndexParam.indexParam( \"Parent\", \"name\" ) );\n        ExecutionEngine executionEngine = new ExecutionEngine(db);\n\n        IndexNodeByOtherNodeIndexer.GraphTraversal traversal1 = new IndexNodeByOtherNodeIndexer.GraphTraversal(){\n            @Override\n            public Iterable<Node> execute( Node startNode )\n            {\n                return GlobalGraphOperations.at(db).getAllNodesWithLabel(DynamicLabel.label(\"Parent\"));\n            }\n        };\n\n        IndexNodeByOtherNodeIndexer.GraphTraversal traversal2 = new IndexNodeByOtherNodeIndexer.GraphTraversal(){\n                    @Override\n                    public Iterable<Node> execute( Node startNode )\n                    {\n                        TraversalDescription traversalDescription = db.traversalDescription().breadthFirst().relationships(\n                                withName( \"CONNECTED_TO\" ), Direction.OUTGOING ).evaluator( new Evaluator()\n                        {\n                            @Override\n                            public Evaluation evaluate( Path path )\n                            {\n                                if ( path.endNode().equals( path.startNode() ) )\n                                {\n                                    return Evaluation.EXCLUDE_AND_CONTINUE;\n                                }\n                                return Evaluation.INCLUDE_AND_CONTINUE;\n                            }\n                        } );\n                        return traversalDescription.traverse( startNode ).nodes();\n                    }\n                };\n\n        IndexNodeByOtherNodeIndexer indexer = new IndexNodeByOtherNodeIndexer( traversal1, traversal2, \"Parent\", \"child\", \"name\" );\n\n        // when\n        indexer.execute( db, null, 2 );\n\n        // then\n        Map<String, String> indexValueToResult = new HashMap<>(  );\n        indexValueToResult.put( \"b\", \"a\" );\n        indexValueToResult.put( \"c\", \"a\" );\n        indexValueToResult.put( \"g\", \"a\" );\n        indexValueToResult.put( \"e\", \"d\" );\n        indexValueToResult.put( \"f\", \"d\" );\n        indexValueToResult.put( \"h\", \"d\" );\n\n        for ( String indexValue : indexValueToResult.keySet() )\n        {\n            String query = \"MATCH (n:Parent {child:'\"+indexValue+\"'}) RETURN n.name AS parent\";\n\n            ExecutionResult result = executionEngine.execute(query);\n            assertEquals(indexValueToResult.get( indexValue ), result.iterator().next().get( \"parent\" ));\n        }\n    }", "signature": "void shouldIndexNodesByOtherNodes()", "full_signature": "@Test @Ignore(\"Doesn't work like that, the code used to index multiple children under one parent, not possible with the new indexes\") public void shouldIndexNodesByOtherNodes()", "class_method_signature": "IndexNodeByOtherNodeIndexerTest.shouldIndexNodesByOtherNodes()", "testcase": true, "constructor": false, "invocations": ["createFromCypher", "indexParam", "getAllNodesWithLabel", "at", "label", "evaluator", "relationships", "breadthFirst", "traversalDescription", "withName", "equals", "endNode", "startNode", "nodes", "traverse", "execute", "put", "put", "put", "put", "put", "put", "keySet", "execute", "assertEquals", "get", "get", "next", "iterator"]}, "focal_class": {"identifier": "IndexNodeByOtherNodeIndexer", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final GraphTraversal findIndexableNodes;", "modifier": "private final", "type": "GraphTraversal", "declarator": "findIndexableNodes", "var_name": "findIndexableNodes"}, {"original_string": "private final GraphTraversal findOtherNodesForIndexableNode;", "modifier": "private final", "type": "GraphTraversal", "declarator": "findOtherNodesForIndexableNode", "var_name": "findOtherNodesForIndexableNode"}, {"original_string": "private final String indexName;", "modifier": "private final", "type": "String", "declarator": "indexName", "var_name": "indexName"}, {"original_string": "private final String indexKey;", "modifier": "private final", "type": "String", "declarator": "indexKey", "var_name": "indexKey"}, {"original_string": "private final String nodeToIndexByPropertyName;", "modifier": "private final", "type": "String", "declarator": "nodeToIndexByPropertyName", "var_name": "nodeToIndexByPropertyName"}], "methods": [{"identifier": "IndexNodeByOtherNodeIndexer", "parameters": "( GraphTraversal findIndexableNodes, GraphTraversal\n            findOtherNodesForIndexableNode,\n                                        String indexName, String indexKey, String nodeToIndexByPropertyName )", "modifiers": "public", "return": "", "signature": " IndexNodeByOtherNodeIndexer( GraphTraversal findIndexableNodes, GraphTraversal\n            findOtherNodesForIndexableNode,\n                                        String indexName, String indexKey, String nodeToIndexByPropertyName )", "full_signature": "public  IndexNodeByOtherNodeIndexer( GraphTraversal findIndexableNodes, GraphTraversal\n            findOtherNodesForIndexableNode,\n                                        String indexName, String indexKey, String nodeToIndexByPropertyName )", "class_method_signature": "IndexNodeByOtherNodeIndexer.IndexNodeByOtherNodeIndexer( GraphTraversal findIndexableNodes, GraphTraversal\n            findOtherNodesForIndexableNode,\n                                        String indexName, String indexKey, String nodeToIndexByPropertyName )", "testcase": false, "constructor": true}, {"identifier": "execute", "parameters": "( GraphDatabaseService db, Node startNode, int batchSize )", "modifiers": "public", "return": "void", "signature": "void execute( GraphDatabaseService db, Node startNode, int batchSize )", "full_signature": "public void execute( GraphDatabaseService db, Node startNode, int batchSize )", "class_method_signature": "IndexNodeByOtherNodeIndexer.execute( GraphDatabaseService db, Node startNode, int batchSize )", "testcase": false, "constructor": false}], "file": "queries/src/main/java/org/neo4j/graphdatabases/queries/helpers/IndexNodeByOtherNodeIndexer.java"}, "focal_method": {"identifier": "execute", "parameters": "( GraphDatabaseService db, Node startNode, int batchSize )", "modifiers": "public", "return": "void", "body": "public void execute( GraphDatabaseService db, Node startNode, int batchSize )\n    {\n\n        Transaction tx = db.beginTx();\n\n        Label label = DynamicLabel.label(indexName);\n        Iterable<Node> indexableNodes = findIndexableNodes.execute( startNode );\n        int currentBatchSize = 0;\n\n        try\n        {\n            for ( Node indexableNode : indexableNodes )\n            {\n                Iterable<Node> nodesToIndexBy = findOtherNodesForIndexableNode.execute( indexableNode );\n                for ( Node node : nodesToIndexBy )\n                {\n                    indexableNode.addLabel(label);\n                    indexableNode.setProperty(indexKey, node.getProperty( nodeToIndexByPropertyName ) );\n                    if ( currentBatchSize++ > batchSize )\n                    {\n                        tx.success();\n                        tx.close();\n                        tx = db.beginTx();\n                        currentBatchSize = 0;\n                    }\n                }\n            }\n            tx.success();\n        }\n        finally\n        {\n            tx.close();\n        }\n\n    }", "signature": "void execute( GraphDatabaseService db, Node startNode, int batchSize )", "full_signature": "public void execute( GraphDatabaseService db, Node startNode, int batchSize )", "class_method_signature": "IndexNodeByOtherNodeIndexer.execute( GraphDatabaseService db, Node startNode, int batchSize )", "testcase": false, "constructor": false, "invocations": ["beginTx", "label", "execute", "execute", "addLabel", "setProperty", "getProperty", "success", "close", "beginTx", "success", "close"]}, "repository": {"repo_id": 9667687, "url": "https://github.com/iansrobinson/graph-databases-use-cases", "language": "Java", "is_fork": false, "fork_count": 116, "stargazer_count": 264, "size": 388, "license": "licensed"}}