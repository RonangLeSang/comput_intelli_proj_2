{"test_class": {"identifier": "BridgeMethodCompilerTest", "superclass": "", "interfaces": "", "fields": [], "file": "compiler/src/test/java/org/robovm/compiler/BridgeMethodCompilerTest.java"}, "test_case": {"identifier": "testCreateBridgeCWrapperNestedStructByValParameter", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCreateBridgeCWrapperNestedStructByValParameter() {\n        FunctionType functionType = new FunctionType(VOID, \n                new StructureType(\n                        new StructureType(I32), \n                        new StructureType(I32)));\n        assertEquals(\n                \"void f(void* target, void* p0) {\\n\" +\n                \"    struct f_0001_0001 {int m0;};\\n\" +\n                \"    struct f_0001_0000 {int m0;};\\n\" +\n                \"    struct f_0001 {struct f_0001_0000 m0;struct f_0001_0001 m1;};\\n\" +\n                \"    ((void (*)(struct f_0001)) target)(*((struct f_0001*)p0));\\n\" +\n                \"}\\n\",\n                BridgeMethodCompiler.createBridgeCWrapper(functionType.getReturnType(),\n                        functionType.getParameterTypes(), functionType.getParameterTypes(), \"f\"));\n    }", "signature": "void testCreateBridgeCWrapperNestedStructByValParameter()", "full_signature": "@Test public void testCreateBridgeCWrapperNestedStructByValParameter()", "class_method_signature": "BridgeMethodCompilerTest.testCreateBridgeCWrapperNestedStructByValParameter()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "createBridgeCWrapper", "getReturnType", "getParameterTypes", "getParameterTypes"]}, "focal_class": {"identifier": "BridgeMethodCompiler", "superclass": "extends BroMethodCompiler", "interfaces": "", "fields": [], "methods": [{"identifier": "BridgeMethodCompiler", "parameters": "(Config config)", "modifiers": "public", "return": "", "signature": " BridgeMethodCompiler(Config config)", "full_signature": "public  BridgeMethodCompiler(Config config)", "class_method_signature": "BridgeMethodCompiler.BridgeMethodCompiler(Config config)", "testcase": false, "constructor": true}, {"identifier": "validateBridgeMethod", "parameters": "(SootMethod method)", "modifiers": "private", "return": "void", "signature": "void validateBridgeMethod(SootMethod method)", "full_signature": "private void validateBridgeMethod(SootMethod method)", "class_method_signature": "BridgeMethodCompiler.validateBridgeMethod(SootMethod method)", "testcase": false, "constructor": false}, {"identifier": "getBridgeCWrapperRef", "parameters": "(FunctionType functionType, String name)", "modifiers": "protected static", "return": "FunctionRef", "signature": "FunctionRef getBridgeCWrapperRef(FunctionType functionType, String name)", "full_signature": "protected static FunctionRef getBridgeCWrapperRef(FunctionType functionType, String name)", "class_method_signature": "BridgeMethodCompiler.getBridgeCWrapperRef(FunctionType functionType, String name)", "testcase": false, "constructor": false}, {"identifier": "createBridgeCWrapper", "parameters": "(Type returnType, Type[] hiParameterTypes, Type[] loParameterTypes, String name)", "modifiers": "protected static", "return": "String", "signature": "String createBridgeCWrapper(Type returnType, Type[] hiParameterTypes, Type[] loParameterTypes, String name)", "full_signature": "protected static String createBridgeCWrapper(Type returnType, Type[] hiParameterTypes, Type[] loParameterTypes, String name)", "class_method_signature": "BridgeMethodCompiler.createBridgeCWrapper(Type returnType, Type[] hiParameterTypes, Type[] loParameterTypes, String name)", "testcase": false, "constructor": false}, {"identifier": "doCompile", "parameters": "(ModuleBuilder moduleBuilder, SootMethod method)", "modifiers": "protected", "return": "Function", "signature": "Function doCompile(ModuleBuilder moduleBuilder, SootMethod method)", "full_signature": "protected Function doCompile(ModuleBuilder moduleBuilder, SootMethod method)", "class_method_signature": "BridgeMethodCompiler.doCompile(ModuleBuilder moduleBuilder, SootMethod method)", "testcase": false, "constructor": false}, {"identifier": "updateObject", "parameters": "(SootMethod method, Function fn, Value env, long flags, List<MarshaledArg> marshaledArgs)", "modifiers": "private", "return": "void", "signature": "void updateObject(SootMethod method, Function fn, Value env, long flags, List<MarshaledArg> marshaledArgs)", "full_signature": "private void updateObject(SootMethod method, Function fn, Value env, long flags, List<MarshaledArg> marshaledArgs)", "class_method_signature": "BridgeMethodCompiler.updateObject(SootMethod method, Function fn, Value env, long flags, List<MarshaledArg> marshaledArgs)", "testcase": false, "constructor": false}], "file": "compiler/src/main/java/org/robovm/compiler/BridgeMethodCompiler.java"}, "focal_method": {"identifier": "createBridgeCWrapper", "parameters": "(Type returnType, Type[] hiParameterTypes, Type[] loParameterTypes, String name)", "modifiers": "protected static", "return": "String", "body": "protected static String createBridgeCWrapper(Type returnType, Type[] hiParameterTypes, Type[] loParameterTypes, String name) {\n        if (hiParameterTypes.length != loParameterTypes.length) {\n            // Varargs\n            if (hiParameterTypes.length < loParameterTypes.length) {\n                throw new IllegalArgumentException(\"For va_arg functions lo's types parameter types must be a prefix of the hi type's parameters\");\n            }\n            if (!Arrays.asList(hiParameterTypes).subList(0, loParameterTypes.length).equals(Arrays.asList(loParameterTypes))) {\n                throw new IllegalArgumentException(\"For va_arg functions lo's types parameter types must be a prefix of the hi type's parameters\");\n            }\n        } else {\n            if (!Arrays.equals(hiParameterTypes, loParameterTypes)) {\n                throw new IllegalArgumentException(\"hi and lo parameter types must be equal\");\n            }\n        }\n        \n        // We order structs by name in reverse order. The names are constructed\n        // such that nested structs get names which are naturally ordered after\n        // their parent struct.\n        Map<String, String> structs = new TreeMap<String, String>(Collections.reverseOrder());\n        \n        String hiReturnType = returnType instanceof StructureType \n                ? \"void\" : getHiType(returnType);\n\n        StringBuilder hiSignature = new StringBuilder();\n        hiSignature\n            .append(hiReturnType)\n            .append(' ')\n            .append(name)\n            .append(\"(void* target\");\n        if (returnType instanceof StructureType) {\n            hiSignature.append(\", void* ret\");\n        }\n\n        StringBuilder loSignature = new StringBuilder();\n        String loReturnType = getLoType(returnType, name, 0, structs);\n        loSignature\n            .append(loReturnType)\n            .append(' ')\n            .append(\"(*)(\");\n        \n        StringBuilder body = new StringBuilder(\" {\\n\");\n        StringBuilder args = new StringBuilder();\n        \n        for (int i = 0; i < hiParameterTypes.length; i++) {\n            String arg = \"p\" + i;\n            if (i > 0) {\n                args.append(\", \");\n            }\n\n            String hiParamType = getHiType(hiParameterTypes[i]);\n            hiSignature.append(\", \");\n            hiSignature.append(hiParamType).append(' ').append(arg);\n\n            if (i < loParameterTypes.length) {\n                String loParamType = getLoType(hiParameterTypes[i], name, i + 1, structs);\n                if (i > 0) {\n                    loSignature.append(\", \");\n                }\n                loSignature.append(loParamType);\n    \n                if (hiParameterTypes[i] instanceof StructureType) {\n                    args.append(\"*((\").append(loParamType).append(\"*)\").append(arg).append(')');\n                } else {\n                    args.append(arg);\n                }\n            } else {\n                args.append(arg);\n            }\n        }\n        hiSignature.append(')');\n        if (loParameterTypes.length == 0) {\n            loSignature.append(\"void\");\n        } else if (loParameterTypes.length < hiParameterTypes.length) {\n            loSignature.append(\", ...\");\n        }\n        loSignature.append(')');\n        \n        for (Entry<String, String> struct : structs.entrySet()) {\n            body.append(\"    struct \" + struct.getKey() + \" \" + struct.getValue() + \";\\n\");\n        }\n        \n        if (returnType instanceof StructureType) {\n            body.append(\"    *((\" + loReturnType + \"*)ret) = ((\" + loSignature + \") target)(\" + args + \");\\n\");\n        } else if (returnType != Type.VOID) {\n            body.append(\"    return ((\" + loSignature + \") target)(\" + args + \");\\n\");\n        } else {\n            body.append(\"    ((\" + loSignature + \") target)(\" + args + \");\\n\");\n        }\n        body.append(\"}\\n\");\n\n        return hiSignature.toString() + body.toString();\n    }", "signature": "String createBridgeCWrapper(Type returnType, Type[] hiParameterTypes, Type[] loParameterTypes, String name)", "full_signature": "protected static String createBridgeCWrapper(Type returnType, Type[] hiParameterTypes, Type[] loParameterTypes, String name)", "class_method_signature": "BridgeMethodCompiler.createBridgeCWrapper(Type returnType, Type[] hiParameterTypes, Type[] loParameterTypes, String name)", "testcase": false, "constructor": false, "invocations": ["equals", "subList", "asList", "asList", "equals", "reverseOrder", "getHiType", "append", "append", "append", "append", "append", "getLoType", "append", "append", "append", "append", "getHiType", "append", "append", "append", "append", "getLoType", "append", "append", "append", "append", "append", "append", "append", "append", "append", "append", "append", "append", "append", "entrySet", "append", "getKey", "getValue", "append", "append", "append", "append", "toString", "toString"]}, "repository": {"repo_id": 7480345, "url": "https://github.com/robovm/robovm", "language": "Java", "is_fork": false, "fork_count": 414, "stargazer_count": 1613, "size": 377573, "license": "licensed"}}