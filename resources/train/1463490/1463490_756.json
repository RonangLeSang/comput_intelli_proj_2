{"test_class": {"identifier": "DefaultModelBridgeTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@RegisterExtension\n    LogCaptureExtension logCapture = new LogCaptureExtension();", "modifier": "@RegisterExtension", "type": "LogCaptureExtension", "declarator": "logCapture = new LogCaptureExtension()", "var_name": "logCapture"}, {"original_string": "@InjectMockComponents\n    private DefaultModelBridge modelBridge;", "modifier": "@InjectMockComponents\n    private", "type": "DefaultModelBridge", "declarator": "modelBridge", "var_name": "modelBridge"}, {"original_string": "@MockComponent\n    @Named(\"relative\")\n    private EntityReferenceResolver<String> relativeStringEntityReferenceResolver;", "modifier": "@MockComponent\n    @Named(\"relative\")\n    private", "type": "EntityReferenceResolver<String>", "declarator": "relativeStringEntityReferenceResolver", "var_name": "relativeStringEntityReferenceResolver"}, {"original_string": "@MockComponent\n    @Named(\"compact\")\n    private EntityReferenceSerializer<String> compactEntityReferenceSerializer;", "modifier": "@MockComponent\n    @Named(\"compact\")\n    private", "type": "EntityReferenceSerializer<String>", "declarator": "compactEntityReferenceSerializer", "var_name": "compactEntityReferenceSerializer"}, {"original_string": "@MockComponent\n    private JobProgressManager progressManager;", "modifier": "@MockComponent\n    private", "type": "JobProgressManager", "declarator": "progressManager", "var_name": "progressManager"}, {"original_string": "@MockComponent\n    private AuthorizationManager authorization;", "modifier": "@MockComponent\n    private", "type": "AuthorizationManager", "declarator": "authorization", "var_name": "authorization"}, {"original_string": "@InjectComponentManager\n    private MockitoComponentManager componentManager;", "modifier": "@InjectComponentManager\n    private", "type": "MockitoComponentManager", "declarator": "componentManager", "var_name": "componentManager"}, {"original_string": "@Mock\n    private XWikiContext xcontext;", "modifier": "@Mock\n    private", "type": "XWikiContext", "declarator": "xcontext", "var_name": "xcontext"}, {"original_string": "@Mock\n    private XWiki xwiki;", "modifier": "@Mock\n    private", "type": "XWiki", "declarator": "xwiki", "var_name": "xwiki"}, {"original_string": "@Mock\n    private XWikiRecycleBinStoreInterface recycleBin;", "modifier": "@Mock\n    private", "type": "XWikiRecycleBinStoreInterface", "declarator": "recycleBin", "var_name": "recycleBin"}, {"original_string": "@Mock\n    private XWikiStoreInterface store;", "modifier": "@Mock\n    private", "type": "XWikiStoreInterface", "declarator": "store", "var_name": "store"}, {"original_string": "@Mock\n    private AbstractCheckRightsRequest request;", "modifier": "@Mock\n    private", "type": "AbstractCheckRightsRequest", "declarator": "request", "var_name": "request"}], "file": "xwiki-platform-core/xwiki-platform-refactoring/xwiki-platform-refactoring-default/src/test/java/org/xwiki/refactoring/internal/DefaultModelBridgeTest.java"}, "test_case": {"identifier": "dontUpdateParentDifferentWikiSameSpace", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n    void dontUpdateParentDifferentWikiSameSpace() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, xcontext)).thenReturn(document);\n\n        DocumentReference parentReference = new DocumentReference(\"subwiki\", Arrays.asList(\"Path\", \"To\"), \"WebHome\");\n        when(document.getParentReference()).thenReturn(parentReference);\n        when(document.getRelativeParentReference()).thenReturn(parentReference.getLocalDocumentReference());\n\n        DocumentReference hierarchicalParent = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"WebHome\");\n        String serializedParent = \"wiki:Path.To.WebHome\";\n        when(this.compactEntityReferenceSerializer.serialize(hierarchicalParent, documentReference))\n            .thenReturn(serializedParent);\n        when(this.relativeStringEntityReferenceResolver.resolve(serializedParent, EntityType.DOCUMENT))\n            .thenReturn(hierarchicalParent.getLocalDocumentReference());\n\n        this.modelBridge.update(documentReference, Collections.emptyMap());\n\n        // no need to update the parent: different wiki but same relative reference\n        verify(document, never()).setParentReference(hierarchicalParent.getLocalDocumentReference());\n        verify(this.xcontext.getWiki(), never()).saveDocument(document, \"Update document after refactoring.\", true,\n            xcontext);\n    }", "signature": "void dontUpdateParentDifferentWikiSameSpace()", "full_signature": "@Test void dontUpdateParentDifferentWikiSameSpace()", "class_method_signature": "DefaultModelBridgeTest.dontUpdateParentDifferentWikiSameSpace()", "testcase": true, "constructor": false, "invocations": ["asList", "mock", "thenReturn", "when", "getDocument", "getWiki", "asList", "thenReturn", "when", "getParentReference", "thenReturn", "when", "getRelativeParentReference", "getLocalDocumentReference", "asList", "thenReturn", "when", "serialize", "thenReturn", "when", "resolve", "getLocalDocumentReference", "update", "emptyMap", "setParentReference", "verify", "never", "getLocalDocumentReference", "saveDocument", "verify", "getWiki", "never"]}, "focal_class": {"identifier": "DefaultModelBridge", "superclass": "", "interfaces": "implements ModelBridge", "fields": [{"original_string": "private static final Pattern LIKE_SPECIAL_CHARS = Pattern.compile(\"([%_/])\");", "modifier": "private static final", "type": "Pattern", "declarator": "LIKE_SPECIAL_CHARS = Pattern.compile(\"([%_/])\")", "var_name": "LIKE_SPECIAL_CHARS"}, {"original_string": "private static final LocalDocumentReference REDIRECT_CLASS_REFERENCE =\n        new LocalDocumentReference(XWiki.SYSTEM_SPACE, \"RedirectClass\");", "modifier": "private static final", "type": "LocalDocumentReference", "declarator": "REDIRECT_CLASS_REFERENCE =\n        new LocalDocumentReference(XWiki.SYSTEM_SPACE, \"RedirectClass\")", "var_name": "REDIRECT_CLASS_REFERENCE"}, {"original_string": "@Inject\n    private Logger logger;", "modifier": "@Inject\n    private", "type": "Logger", "declarator": "logger", "var_name": "logger"}, {"original_string": "@Inject\n    private Provider<XWikiContext> xcontextProvider;", "modifier": "@Inject\n    private", "type": "Provider<XWikiContext>", "declarator": "xcontextProvider", "var_name": "xcontextProvider"}, {"original_string": "@Inject\n    private QueryManager queryManager;", "modifier": "@Inject\n    private", "type": "QueryManager", "declarator": "queryManager", "var_name": "queryManager"}, {"original_string": "@Inject\n    @Named(\"local\")\n    private EntityReferenceSerializer<String> localEntityReferenceSerializer;", "modifier": "@Inject\n    @Named(\"local\")\n    private", "type": "EntityReferenceSerializer<String>", "declarator": "localEntityReferenceSerializer", "var_name": "localEntityReferenceSerializer"}, {"original_string": "@Inject\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;", "modifier": "@Inject\n    private", "type": "EntityReferenceSerializer<String>", "declarator": "defaultEntityReferenceSerializer", "var_name": "defaultEntityReferenceSerializer"}, {"original_string": "@Inject\n    @Named(\"explicit\")\n    private DocumentReferenceResolver<String> explicitDocumentReferenceResolver;", "modifier": "@Inject\n    @Named(\"explicit\")\n    private", "type": "DocumentReferenceResolver<String>", "declarator": "explicitDocumentReferenceResolver", "var_name": "explicitDocumentReferenceResolver"}, {"original_string": "@Inject\n    @Named(\"compact\")\n    private EntityReferenceSerializer<String> compactEntityReferenceSerializer;", "modifier": "@Inject\n    @Named(\"compact\")\n    private", "type": "EntityReferenceSerializer<String>", "declarator": "compactEntityReferenceSerializer", "var_name": "compactEntityReferenceSerializer"}, {"original_string": "@Inject\n    @Named(\"relative\")\n    private EntityReferenceResolver<String> relativeStringEntityReferenceResolver;", "modifier": "@Inject\n    @Named(\"relative\")\n    private", "type": "EntityReferenceResolver<String>", "declarator": "relativeStringEntityReferenceResolver", "var_name": "relativeStringEntityReferenceResolver"}, {"original_string": "@Inject\n    private JobProgressManager progressManager;", "modifier": "@Inject\n    private", "type": "JobProgressManager", "declarator": "progressManager", "var_name": "progressManager"}, {"original_string": "@Inject\n    private ParentChildConfiguration parentChildConfiguration;", "modifier": "@Inject\n    private", "type": "ParentChildConfiguration", "declarator": "parentChildConfiguration", "var_name": "parentChildConfiguration"}, {"original_string": "@Inject\n    private EntityReferenceProvider entityReferenceProvider;", "modifier": "@Inject\n    private", "type": "EntityReferenceProvider", "declarator": "entityReferenceProvider", "var_name": "entityReferenceProvider"}], "methods": [{"identifier": "create", "parameters": "(DocumentReference documentReference)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean create(DocumentReference documentReference)", "full_signature": "@Override public boolean create(DocumentReference documentReference)", "class_method_signature": "DefaultModelBridge.create(DocumentReference documentReference)", "testcase": false, "constructor": false}, {"identifier": "copy", "parameters": "(DocumentReference source, DocumentReference destination)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean copy(DocumentReference source, DocumentReference destination)", "full_signature": "@Override public boolean copy(DocumentReference source, DocumentReference destination)", "class_method_signature": "DefaultModelBridge.copy(DocumentReference source, DocumentReference destination)", "testcase": false, "constructor": false}, {"identifier": "delete", "parameters": "(DocumentReference reference)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean delete(DocumentReference reference)", "full_signature": "@Override public boolean delete(DocumentReference reference)", "class_method_signature": "DefaultModelBridge.delete(DocumentReference reference)", "testcase": false, "constructor": false}, {"identifier": "delete", "parameters": "(DocumentReference reference, boolean skipRecycleBin)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean delete(DocumentReference reference, boolean skipRecycleBin)", "full_signature": "@Override public boolean delete(DocumentReference reference, boolean skipRecycleBin)", "class_method_signature": "DefaultModelBridge.delete(DocumentReference reference, boolean skipRecycleBin)", "testcase": false, "constructor": false}, {"identifier": "removeLock", "parameters": "(DocumentReference reference)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean removeLock(DocumentReference reference)", "full_signature": "@Override public boolean removeLock(DocumentReference reference)", "class_method_signature": "DefaultModelBridge.removeLock(DocumentReference reference)", "testcase": false, "constructor": false}, {"identifier": "createRedirect", "parameters": "(DocumentReference oldReference, DocumentReference newReference)", "modifiers": "@Override public", "return": "void", "signature": "void createRedirect(DocumentReference oldReference, DocumentReference newReference)", "full_signature": "@Override public void createRedirect(DocumentReference oldReference, DocumentReference newReference)", "class_method_signature": "DefaultModelBridge.createRedirect(DocumentReference oldReference, DocumentReference newReference)", "testcase": false, "constructor": false}, {"identifier": "canOverwriteSilently", "parameters": "(DocumentReference documentReference)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean canOverwriteSilently(DocumentReference documentReference)", "full_signature": "@Override public boolean canOverwriteSilently(DocumentReference documentReference)", "class_method_signature": "DefaultModelBridge.canOverwriteSilently(DocumentReference documentReference)", "testcase": false, "constructor": false}, {"identifier": "exists", "parameters": "(DocumentReference reference)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean exists(DocumentReference reference)", "full_signature": "@Override public boolean exists(DocumentReference reference)", "class_method_signature": "DefaultModelBridge.exists(DocumentReference reference)", "testcase": false, "constructor": false}, {"identifier": "getBackLinkedReferences", "parameters": "(DocumentReference documentReference, String wikiId)", "modifiers": "@Override public", "return": "List<DocumentReference>", "signature": "List<DocumentReference> getBackLinkedReferences(DocumentReference documentReference, String wikiId)", "full_signature": "@Override public List<DocumentReference> getBackLinkedReferences(DocumentReference documentReference, String wikiId)", "class_method_signature": "DefaultModelBridge.getBackLinkedReferences(DocumentReference documentReference, String wikiId)", "testcase": false, "constructor": false}, {"identifier": "getDocumentReferences", "parameters": "(SpaceReference spaceReference)", "modifiers": "@Override public", "return": "List<DocumentReference>", "signature": "List<DocumentReference> getDocumentReferences(SpaceReference spaceReference)", "full_signature": "@Override public List<DocumentReference> getDocumentReferences(SpaceReference spaceReference)", "class_method_signature": "DefaultModelBridge.getDocumentReferences(SpaceReference spaceReference)", "testcase": false, "constructor": false}, {"identifier": "updateParentField", "parameters": "(final DocumentReference oldParentReference,\n        final DocumentReference newParentReference)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean updateParentField(final DocumentReference oldParentReference,\n        final DocumentReference newParentReference)", "full_signature": "@Override public boolean updateParentField(final DocumentReference oldParentReference,\n        final DocumentReference newParentReference)", "class_method_signature": "DefaultModelBridge.updateParentField(final DocumentReference oldParentReference,\n        final DocumentReference newParentReference)", "testcase": false, "constructor": false}, {"identifier": "setContextUserReference", "parameters": "(DocumentReference userReference)", "modifiers": "@Override public", "return": "DocumentReference", "signature": "DocumentReference setContextUserReference(DocumentReference userReference)", "full_signature": "@Override public DocumentReference setContextUserReference(DocumentReference userReference)", "class_method_signature": "DefaultModelBridge.setContextUserReference(DocumentReference userReference)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(DocumentReference documentReference, Map<String, String> parameters)", "modifiers": "@Override public", "return": "void", "signature": "void update(DocumentReference documentReference, Map<String, String> parameters)", "full_signature": "@Override public void update(DocumentReference documentReference, Map<String, String> parameters)", "class_method_signature": "DefaultModelBridge.update(DocumentReference documentReference, Map<String, String> parameters)", "testcase": false, "constructor": false}, {"identifier": "getHierarchicalParent", "parameters": "(DocumentReference documentReference)", "modifiers": "private", "return": "DocumentReference", "signature": "DocumentReference getHierarchicalParent(DocumentReference documentReference)", "full_signature": "private DocumentReference getHierarchicalParent(DocumentReference documentReference)", "class_method_signature": "DefaultModelBridge.getHierarchicalParent(DocumentReference documentReference)", "testcase": false, "constructor": false}, {"identifier": "getDeletedDocument", "parameters": "(XWikiContext context, long deletedDocumentId)", "modifiers": "private", "return": "XWikiDeletedDocument", "signature": "XWikiDeletedDocument getDeletedDocument(XWikiContext context, long deletedDocumentId)", "full_signature": "private XWikiDeletedDocument getDeletedDocument(XWikiContext context, long deletedDocumentId)", "class_method_signature": "DefaultModelBridge.getDeletedDocument(XWikiContext context, long deletedDocumentId)", "testcase": false, "constructor": false}, {"identifier": "restoreDeletedDocument", "parameters": "(long deletedDocumentId, AbstractCheckRightsRequest request)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean restoreDeletedDocument(long deletedDocumentId, AbstractCheckRightsRequest request)", "full_signature": "@Override public boolean restoreDeletedDocument(long deletedDocumentId, AbstractCheckRightsRequest request)", "class_method_signature": "DefaultModelBridge.restoreDeletedDocument(long deletedDocumentId, AbstractCheckRightsRequest request)", "testcase": false, "constructor": false}, {"identifier": "getDeletedDocumentIds", "parameters": "(String batchId)", "modifiers": "@Override public", "return": "List<Long>", "signature": "List<Long> getDeletedDocumentIds(String batchId)", "full_signature": "@Override public List<Long> getDeletedDocumentIds(String batchId)", "class_method_signature": "DefaultModelBridge.getDeletedDocumentIds(String batchId)", "testcase": false, "constructor": false}, {"identifier": "canRestoreDeletedDocument", "parameters": "(XWikiDeletedDocument deletedDocument, DocumentReference userReference)", "modifiers": "protected", "return": "boolean", "signature": "boolean canRestoreDeletedDocument(XWikiDeletedDocument deletedDocument, DocumentReference userReference)", "full_signature": "protected boolean canRestoreDeletedDocument(XWikiDeletedDocument deletedDocument, DocumentReference userReference)", "class_method_signature": "DefaultModelBridge.canRestoreDeletedDocument(XWikiDeletedDocument deletedDocument, DocumentReference userReference)", "testcase": false, "constructor": false}, {"identifier": "canPermanentlyDeleteDocument", "parameters": "(XWikiDeletedDocument deletedDocument,\n        DocumentReference userReference)", "modifiers": "protected", "return": "boolean", "signature": "boolean canPermanentlyDeleteDocument(XWikiDeletedDocument deletedDocument,\n        DocumentReference userReference)", "full_signature": "protected boolean canPermanentlyDeleteDocument(XWikiDeletedDocument deletedDocument,\n        DocumentReference userReference)", "class_method_signature": "DefaultModelBridge.canPermanentlyDeleteDocument(XWikiDeletedDocument deletedDocument,\n        DocumentReference userReference)", "testcase": false, "constructor": false}, {"identifier": "permanentlyDeleteDocument", "parameters": "(long deletedDocumentId, AbstractCheckRightsRequest request)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean permanentlyDeleteDocument(long deletedDocumentId, AbstractCheckRightsRequest request)", "full_signature": "@Override public boolean permanentlyDeleteDocument(long deletedDocumentId, AbstractCheckRightsRequest request)", "class_method_signature": "DefaultModelBridge.permanentlyDeleteDocument(long deletedDocumentId, AbstractCheckRightsRequest request)", "testcase": false, "constructor": false}, {"identifier": "permanentlyDeleteAllDocuments", "parameters": "(PermanentlyDeleteJob deleteJob, AbstractCheckRightsRequest request)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean permanentlyDeleteAllDocuments(PermanentlyDeleteJob deleteJob, AbstractCheckRightsRequest request)", "full_signature": "@Override public boolean permanentlyDeleteAllDocuments(PermanentlyDeleteJob deleteJob, AbstractCheckRightsRequest request)", "class_method_signature": "DefaultModelBridge.permanentlyDeleteAllDocuments(PermanentlyDeleteJob deleteJob, AbstractCheckRightsRequest request)", "testcase": false, "constructor": false}, {"identifier": "rename", "parameters": "(DocumentReference source, DocumentReference destination)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean rename(DocumentReference source, DocumentReference destination)", "full_signature": "@Override public boolean rename(DocumentReference source, DocumentReference destination)", "class_method_signature": "DefaultModelBridge.rename(DocumentReference source, DocumentReference destination)", "testcase": false, "constructor": false}], "file": "xwiki-platform-core/xwiki-platform-refactoring/xwiki-platform-refactoring-default/src/main/java/org/xwiki/refactoring/internal/DefaultModelBridge.java"}, "focal_method": {"identifier": "update", "parameters": "(DocumentReference documentReference, Map<String, String> parameters)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void update(DocumentReference documentReference, Map<String, String> parameters)\n    {\n        try {\n            XWikiContext context = xcontextProvider.get();\n            XWiki wiki = context.getWiki();\n            XWikiDocument document = wiki.getDocument(documentReference, context);\n            boolean save = false;\n\n            String title = parameters.get(\"title\");\n            if (title != null && !title.equals(document.getTitle())) {\n                document.setTitle(title);\n                save = true;\n            }\n\n            // Some old applications still rely on the parent/child links between documents.\n            // For the retro-compatibility, we synchronize the \"parent\" field of the document with the (real)\n            // hierarchical parent.\n            //\n            // But if the user has voluntary enabled the legacy \"parent/child\" mechanism for the breadcrumbs, we keep\n            // the old behaviour when location and parent/child mechanism were not linked.\n            //\n            // More information: https://jira.xwiki.org/browse/XWIKI-13493\n            if (!parentChildConfiguration.isParentChildMechanismEnabled()) {\n\n                // we compute the new hierarchical parent\n                DocumentReference hierarchicalParent = getHierarchicalParent(documentReference);\n\n                // we compute a relative reference for the hierarchical parent\n                String hierarchicalParentSerialized =\n                    this.compactEntityReferenceSerializer.serialize(hierarchicalParent, documentReference);\n                EntityReference relativeHierarchicalReference = this.relativeStringEntityReferenceResolver\n                    .resolve(hierarchicalParentSerialized, EntityType.DOCUMENT);\n\n                // we can rely on the current document parent ref, as after the copy the encoded parent is not changed.\n                EntityReference newDocumentParentRef = document.getRelativeParentReference();\n\n                // all cases are supported:\n                //   1. if we move on a same wiki but on a different space: the relative ref are different, the\n                //      parent will be updated\n                //   2. if we move on a same wiki, same space: the relative ref are the same, we keep the parent\n                //   3. if we move on a different wiki, different space: we don't care about the wiki, we are in the\n                //      same case as 1\n                //   4. if we move on a different wiki, same space: actually we can keep the old parent relative\n                //      reference, as it's relative of the document reference. So the parent reference will be well\n                //      computed with the already existing relative reference.\n                if (!relativeHierarchicalReference.equals(newDocumentParentRef)) {\n                    document.setParentReference(relativeHierarchicalReference);\n                    save = true;\n                }\n            }\n\n            if (save) {\n                wiki.saveDocument(document, \"Update document after refactoring.\", true, context);\n                this.logger.info(\"Document [{}] has been updated.\", documentReference);\n            }\n        } catch (Exception e) {\n            this.logger.error(\"Failed to update the document [{}] after refactoring.\", documentReference, e);\n        }\n    }", "signature": "void update(DocumentReference documentReference, Map<String, String> parameters)", "full_signature": "@Override public void update(DocumentReference documentReference, Map<String, String> parameters)", "class_method_signature": "DefaultModelBridge.update(DocumentReference documentReference, Map<String, String> parameters)", "testcase": false, "constructor": false, "invocations": ["get", "getWiki", "getDocument", "get", "equals", "getTitle", "setTitle", "isParentChildMechanismEnabled", "getHierarchicalParent", "serialize", "resolve", "getRelativeParentReference", "equals", "setParentReference", "saveDocument", "info", "error"]}, "repository": {"repo_id": 1463490, "url": "https://github.com/xwiki/xwiki-platform", "stars": 495, "created": "3/10/2011 1:26:41 PM +00:00", "updates": "2020-01-27T14:12:16+00:00", "fork": "False", "license": "licensed"}}