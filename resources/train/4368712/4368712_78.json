{"test_class": {"identifier": "SslFilterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int PORT = 8321;", "modifier": "private static final", "type": "int", "declarator": "PORT = 8321", "var_name": "PORT"}], "file": "connectors/jdk-connector/src/test/java/org/glassfish/jersey/jdk/connector/internal/SslFilterTest.java"}, "test_case": {"identifier": "testCloseServer", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCloseServer() throws Throwable {\n        CountDownLatch latch = new CountDownLatch(1);\n        SslEchoServer server = new SslEchoServer();\n        try {\n            server.start();\n            String message = \"Hello world\\n\";\n            ByteBuffer readBuffer = ByteBuffer.allocate(message.length());\n            Filter<ByteBuffer, ByteBuffer, ByteBuffer, ByteBuffer> clientSocket = openClientSocket(\"localhost\", readBuffer, latch,\n                    null);\n\n            clientSocket.write(stringToBuffer(message), new CompletionHandler<ByteBuffer>() {\n                @Override\n                public void failed(Throwable t) {\n                    t.printStackTrace();\n                }\n            });\n\n            assertTrue(latch.await(5, TimeUnit.SECONDS));\n            server.stop();\n            readBuffer.flip();\n            String received = bufferToString(readBuffer);\n            assertEquals(message, received);\n        } finally {\n            server.stop();\n        }\n    }", "signature": "void testCloseServer()", "full_signature": "@Test public void testCloseServer()", "class_method_signature": "SslFilterTest.testCloseServer()", "testcase": true, "constructor": false, "invocations": ["start", "allocate", "length", "openClientSocket", "write", "stringToBuffer", "printStackTrace", "assertTrue", "await", "stop", "flip", "bufferToString", "assertEquals", "stop"]}, "focal_class": {"identifier": "SslFilter", "superclass": "extends Filter<ByteBuffer, ByteBuffer, ByteBuffer, ByteBuffer>", "interfaces": "", "fields": [{"original_string": "private static final ByteBuffer emptyBuffer = ByteBuffer.allocate(0);", "modifier": "private static final", "type": "ByteBuffer", "declarator": "emptyBuffer = ByteBuffer.allocate(0)", "var_name": "emptyBuffer"}, {"original_string": "private final ByteBuffer applicationInputBuffer;", "modifier": "private final", "type": "ByteBuffer", "declarator": "applicationInputBuffer", "var_name": "applicationInputBuffer"}, {"original_string": "private final ByteBuffer networkOutputBuffer;", "modifier": "private final", "type": "ByteBuffer", "declarator": "networkOutputBuffer", "var_name": "networkOutputBuffer"}, {"original_string": "private final SSLEngine sslEngine;", "modifier": "private final", "type": "SSLEngine", "declarator": "sslEngine", "var_name": "sslEngine"}, {"original_string": "private final HostnameVerifier customHostnameVerifier;", "modifier": "private final", "type": "HostnameVerifier", "declarator": "customHostnameVerifier", "var_name": "customHostnameVerifier"}, {"original_string": "private final String serverHost;", "modifier": "private final", "type": "String", "declarator": "serverHost", "var_name": "serverHost"}, {"original_string": "private final WriteQueue writeQueue = new WriteQueue();", "modifier": "private final", "type": "WriteQueue", "declarator": "writeQueue = new WriteQueue()", "var_name": "writeQueue"}, {"original_string": "private volatile State state = State.NOT_STARTED;", "modifier": "private volatile", "type": "State", "declarator": "state = State.NOT_STARTED", "var_name": "state"}, {"original_string": "private Runnable pendingApplicationWrite = null;", "modifier": "private", "type": "Runnable", "declarator": "pendingApplicationWrite = null", "var_name": "pendingApplicationWrite"}], "methods": [{"identifier": "SslFilter", "parameters": "(Filter<ByteBuffer, ByteBuffer, ?, ?> downstreamFilter,\n              SSLContext sslContext,\n              String serverHost,\n              HostnameVerifier customHostnameVerifier)", "modifiers": "", "return": "", "signature": " SslFilter(Filter<ByteBuffer, ByteBuffer, ?, ?> downstreamFilter,\n              SSLContext sslContext,\n              String serverHost,\n              HostnameVerifier customHostnameVerifier)", "full_signature": "  SslFilter(Filter<ByteBuffer, ByteBuffer, ?, ?> downstreamFilter,\n              SSLContext sslContext,\n              String serverHost,\n              HostnameVerifier customHostnameVerifier)", "class_method_signature": "SslFilter.SslFilter(Filter<ByteBuffer, ByteBuffer, ?, ?> downstreamFilter,\n              SSLContext sslContext,\n              String serverHost,\n              HostnameVerifier customHostnameVerifier)", "testcase": false, "constructor": true}, {"identifier": "write", "parameters": "(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "modifiers": "@Override synchronized", "return": "void", "signature": "void write(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "full_signature": "@Override synchronized void write(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "class_method_signature": "SslFilter.write(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "testcase": false, "constructor": false}, {"identifier": "handleWrite", "parameters": "(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "modifiers": "private", "return": "void", "signature": "void handleWrite(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "full_signature": "private void handleWrite(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "class_method_signature": "SslFilter.handleWrite(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "testcase": false, "constructor": false}, {"identifier": "handlePostWrite", "parameters": "(final ByteBuffer applicationData,\n                                              final CompletionHandler<ByteBuffer> completionHandler)", "modifiers": "private synchronized", "return": "void", "signature": "void handlePostWrite(final ByteBuffer applicationData,\n                                              final CompletionHandler<ByteBuffer> completionHandler)", "full_signature": "private synchronized void handlePostWrite(final ByteBuffer applicationData,\n                                              final CompletionHandler<ByteBuffer> completionHandler)", "class_method_signature": "SslFilter.handlePostWrite(final ByteBuffer applicationData,\n                                              final CompletionHandler<ByteBuffer> completionHandler)", "testcase": false, "constructor": false}, {"identifier": "storePendingApplicationWrite", "parameters": "(final ByteBuffer applicationData,\n                                              final CompletionHandler<ByteBuffer> completionHandler)", "modifiers": "private", "return": "void", "signature": "void storePendingApplicationWrite(final ByteBuffer applicationData,\n                                              final CompletionHandler<ByteBuffer> completionHandler)", "full_signature": "private void storePendingApplicationWrite(final ByteBuffer applicationData,\n                                              final CompletionHandler<ByteBuffer> completionHandler)", "class_method_signature": "SslFilter.storePendingApplicationWrite(final ByteBuffer applicationData,\n                                              final CompletionHandler<ByteBuffer> completionHandler)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override synchronized", "return": "void", "signature": "void close()", "full_signature": "@Override synchronized void close()", "class_method_signature": "SslFilter.close()", "testcase": false, "constructor": false}, {"identifier": "processRead", "parameters": "(ByteBuffer networkData)", "modifiers": "@Override", "return": "boolean", "signature": "boolean processRead(ByteBuffer networkData)", "full_signature": "@Override boolean processRead(ByteBuffer networkData)", "class_method_signature": "SslFilter.processRead(ByteBuffer networkData)", "testcase": false, "constructor": false}, {"identifier": "handleRead", "parameters": "(ByteBuffer networkData)", "modifiers": "private", "return": "boolean", "signature": "boolean handleRead(ByteBuffer networkData)", "full_signature": "private boolean handleRead(ByteBuffer networkData)", "class_method_signature": "SslFilter.handleRead(ByteBuffer networkData)", "testcase": false, "constructor": false}, {"identifier": "doHandshakeStep", "parameters": "(ByteBuffer networkData)", "modifiers": "private", "return": "boolean", "signature": "boolean doHandshakeStep(ByteBuffer networkData)", "full_signature": "private boolean doHandshakeStep(ByteBuffer networkData)", "class_method_signature": "SslFilter.doHandshakeStep(ByteBuffer networkData)", "testcase": false, "constructor": false}, {"identifier": "handleHandshakeFinished", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void handleHandshakeFinished()", "full_signature": "private void handleHandshakeFinished()", "class_method_signature": "SslFilter.handleHandshakeFinished()", "testcase": false, "constructor": false}, {"identifier": "handleSslError", "parameters": "(Throwable t)", "modifiers": "private", "return": "void", "signature": "void handleSslError(Throwable t)", "full_signature": "private void handleSslError(Throwable t)", "class_method_signature": "SslFilter.handleSslError(Throwable t)", "testcase": false, "constructor": false}, {"identifier": "startSsl", "parameters": "()", "modifiers": "@Override", "return": "void", "signature": "void startSsl()", "full_signature": "@Override void startSsl()", "class_method_signature": "SslFilter.startSsl()", "testcase": false, "constructor": false}, {"identifier": "rehandshake", "parameters": "()", "modifiers": "", "return": "void", "signature": "void rehandshake()", "full_signature": " void rehandshake()", "class_method_signature": "SslFilter.rehandshake()", "testcase": false, "constructor": false}, {"identifier": "getDebugState", "parameters": "()", "modifiers": "private", "return": "String", "signature": "String getDebugState()", "full_signature": "private String getDebugState()", "class_method_signature": "SslFilter.getDebugState()", "testcase": false, "constructor": false}], "file": "connectors/jdk-connector/src/main/java/org/glassfish/jersey/jdk/connector/internal/SslFilter.java"}, "focal_method": {"identifier": "write", "parameters": "(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "modifiers": "@Override synchronized", "return": "void", "body": "@Override\n    synchronized void write(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler) {\n        switch (state) {\n            // before SSL is started, write just passes through\n            case NOT_STARTED: {\n                writeQueue.write(applicationData, completionHandler);\n                return;\n            }\n\n            /* TODO:\n             The current model does not permit calling write before SSL handshake has completed, if we allow this\n             we could easily get rid of the onSslHandshakeCompleted event. The SSL filter can simply store the write until\n             the handshake has completed like during re-handshake. With such a change HANDSHAKING and REHANDSHAKING could\n             be collapsed into one state. */\n            case HANDSHAKING: {\n                completionHandler.failed(new IllegalStateException(\"Cannot write until SSL handshake has been completed\"));\n                break;\n            }\n\n            /* Suspend all writes until the re-handshaking is done. Data are permitted during re-handshake in SSL, but this\n             would only complicate things */\n            case REHANDSHAKING: {\n                storePendingApplicationWrite(applicationData, completionHandler);\n                break;\n            }\n\n            case DATA: {\n                handleWrite(applicationData, completionHandler);\n                break;\n            }\n\n            case CLOSED: {\n                // the engine is closed just abort with failure\n                completionHandler.failed(new IllegalStateException(LocalizationMessages.SSL_SESSION_CLOSED()));\n                break;\n            }\n        }\n    }", "signature": "void write(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "full_signature": "@Override synchronized void write(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "class_method_signature": "SslFilter.write(final ByteBuffer applicationData, final CompletionHandler<ByteBuffer> completionHandler)", "testcase": false, "constructor": false, "invocations": ["write", "failed", "storePendingApplicationWrite", "handleWrite", "failed", "SSL_SESSION_CLOSED"]}, "repository": {"repo_id": 4368712, "url": "https://github.com/jersey/jersey", "language": "Java", "is_fork": false, "fork_count": 2540, "stargazer_count": 2919, "size": 38964, "license": "licensed"}}