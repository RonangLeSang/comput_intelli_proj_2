{"test_class": {"identifier": "SocketTransportCommandProcessorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final OperationKey key = new OperationKey(new ServiceVersion(\"v1.0\"), \"TestingService\", \"TestCall\");", "modifier": "private static final", "type": "OperationKey", "declarator": "key = new OperationKey(new ServiceVersion(\"v1.0\"), \"TestingService\", \"TestCall\")", "var_name": "key"}, {"original_string": "private static final ParameterType returnType = new ParameterType(String.class, null);", "modifier": "private static final", "type": "ParameterType", "declarator": "returnType = new ParameterType(String.class, null)", "var_name": "returnType"}, {"original_string": "private static final Object[] args = { \"arg1\", new Integer(2), Boolean.TRUE};", "modifier": "private static final", "type": "Object[]", "declarator": "args = { \"arg1\", new Integer(2), Boolean.TRUE}", "var_name": "args"}, {"original_string": "private static final long CORRELATION_ID = 9999L;", "modifier": "private static final", "type": "long", "declarator": "CORRELATION_ID = 9999L", "var_name": "CORRELATION_ID"}, {"original_string": "private Date receivedTime = new Date();", "modifier": "private", "type": "Date", "declarator": "receivedTime = new Date()", "var_name": "receivedTime"}, {"original_string": "private Date requestTime = new Date();", "modifier": "private", "type": "Date", "declarator": "requestTime = new Date()", "var_name": "requestTime"}, {"original_string": "private final DehydratedExecutionContext ctx = new DehydratedExecutionContext() {\n\n        @Override\n        public GeoLocationDetails getLocation() {\n            return null;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n\n        @Override\n        public IdentityChain getIdentity() {\n            return null;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n\n        @Override\n        public RequestUUID getRequestUUID() {\n            return new RequestUUIDImpl();\n        }\n\n        @Override\n        public Date getReceivedTime() {\n            return receivedTime;\n        }\n\n        @Override\n        public Date getRequestTime() {\n            return requestTime;\n        }\n\n        @Override\n        public boolean traceLoggingEnabled() {\n            return false;\n        }\n\n        @Override\n        public List<IdentityToken> getIdentityTokens() {\n            return null;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n\n        @Override\n        public void setIdentityChain(IdentityChain chain) {\n            //To change body of implemented methods use File | Settings | File Templates.\n        }\n\n        @Override\n        public int getTransportSecurityStrengthFactor() {\n            return 0;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n\n        @Override\n        public boolean isTransportSecure() {\n            return false;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n    };", "modifier": "private final", "type": "DehydratedExecutionContext", "declarator": "ctx = new DehydratedExecutionContext() {\n\n        @Override\n        public GeoLocationDetails getLocation() {\n            return null;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n\n        @Override\n        public IdentityChain getIdentity() {\n            return null;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n\n        @Override\n        public RequestUUID getRequestUUID() {\n            return new RequestUUIDImpl();\n        }\n\n        @Override\n        public Date getReceivedTime() {\n            return receivedTime;\n        }\n\n        @Override\n        public Date getRequestTime() {\n            return requestTime;\n        }\n\n        @Override\n        public boolean traceLoggingEnabled() {\n            return false;\n        }\n\n        @Override\n        public List<IdentityToken> getIdentityTokens() {\n            return null;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n\n        @Override\n        public void setIdentityChain(IdentityChain chain) {\n            //To change body of implemented methods use File | Settings | File Templates.\n        }\n\n        @Override\n        public int getTransportSecurityStrengthFactor() {\n            return 0;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n\n        @Override\n        public boolean isTransportSecure() {\n            return false;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n    }", "var_name": "ctx"}, {"original_string": "private SocketTransportCommandProcessor commandProcessor;", "modifier": "private", "type": "SocketTransportCommandProcessor", "declarator": "commandProcessor", "var_name": "commandProcessor"}, {"original_string": "@Mock\n    private Tracer tracer;", "modifier": "@Mock\n    private", "type": "Tracer", "declarator": "tracer", "var_name": "tracer"}, {"original_string": "@Mock\n    private ExecutionVenue ev;", "modifier": "@Mock\n    private", "type": "ExecutionVenue", "declarator": "ev", "var_name": "ev"}, {"original_string": "@Mock\n    private Executor executor;", "modifier": "@Mock\n    private", "type": "Executor", "declarator": "executor", "var_name": "executor"}, {"original_string": "@Mock\n    private RemotableMethodInvocationMarshaller marshaller;", "modifier": "@Mock\n    private", "type": "RemotableMethodInvocationMarshaller", "declarator": "marshaller", "var_name": "marshaller"}, {"original_string": "@Mock\n    private EventLoggingRegistry eventLoggingRegistry;", "modifier": "@Mock\n    private", "type": "EventLoggingRegistry", "declarator": "eventLoggingRegistry", "var_name": "eventLoggingRegistry"}, {"original_string": "private ByteArrayOutputStream out = new ByteArrayOutputStream();", "modifier": "private", "type": "ByteArrayOutputStream", "declarator": "out = new ByteArrayOutputStream()", "var_name": "out"}], "file": "cougar-framework/socket-transport/src/test/java/com/betfair/cougar/transport/socket/SocketTransportCommandProcessorTest.java"}, "test_case": {"identifier": "createCommandResolver_WithTimeout", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void createCommandResolver_WithTimeout() throws IOException {\n        // resolve the command\n        CommandResolver<SocketTransportCommand> cr = createCommandResolver(DefaultTimeConstraints.fromTimeout(10000), tracer);\n        Iterable<ExecutionCommand> executionCommands = cr.resolveExecutionCommands();\n\n        // check the output\n        ExecutionCommand executionCommand = executionCommands.iterator().next();\n        TimeConstraints constraints = executionCommand.getTimeConstraints();\n        assertNotNull(constraints.getExpiryTime());\n    }", "signature": "void createCommandResolver_WithTimeout()", "full_signature": "@Test public void createCommandResolver_WithTimeout()", "class_method_signature": "SocketTransportCommandProcessorTest.createCommandResolver_WithTimeout()", "testcase": true, "constructor": false, "invocations": ["createCommandResolver", "fromTimeout", "resolveExecutionCommands", "next", "iterator", "getTimeConstraints", "assertNotNull", "getExpiryTime"]}, "focal_class": {"identifier": "SocketTransportCommandProcessor", "superclass": "extends AbstractCommandProcessor<SocketTransportCommand>", "interfaces": "implements GateListener", "fields": [{"original_string": "private static Logger LOGGER = LoggerFactory.getLogger(SocketTransportCommandProcessor.class);", "modifier": "private static", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(SocketTransportCommandProcessor.class)", "var_name": "LOGGER"}, {"original_string": "private RemotableMethodInvocationMarshaller marshaller;", "modifier": "private", "type": "RemotableMethodInvocationMarshaller", "declarator": "marshaller", "var_name": "marshaller"}, {"original_string": "private EventLoggingRegistry registry;", "modifier": "private", "type": "EventLoggingRegistry", "declarator": "registry", "var_name": "registry"}, {"original_string": "private IdentityResolverFactory identityResolverFactory;", "modifier": "private", "type": "IdentityResolverFactory", "declarator": "identityResolverFactory", "var_name": "identityResolverFactory"}, {"original_string": "private ServerConnectedObjectManager connectedObjectManager;", "modifier": "private", "type": "ServerConnectedObjectManager", "declarator": "connectedObjectManager", "var_name": "connectedObjectManager"}, {"original_string": "private Map<String, ServiceBindingDescriptor> serviceBindingDescriptors = new HashMap<String, ServiceBindingDescriptor>();", "modifier": "private", "type": "Map<String, ServiceBindingDescriptor>", "declarator": "serviceBindingDescriptors = new HashMap<String, ServiceBindingDescriptor>()", "var_name": "serviceBindingDescriptors"}, {"original_string": "private Map<OperationKey, OperationDefinition> bindings = new HashMap<OperationKey, OperationDefinition>();", "modifier": "private", "type": "Map<OperationKey, OperationDefinition>", "declarator": "bindings = new HashMap<OperationKey, OperationDefinition>()", "var_name": "bindings"}, {"original_string": "private Map<String, OperationKey> namedOperations = new HashMap<String, OperationKey>();", "modifier": "private", "type": "Map<String, OperationKey>", "declarator": "namedOperations = new HashMap<String, OperationKey>()", "var_name": "namedOperations"}, {"original_string": "private int priority = 1;", "modifier": "private", "type": "int", "declarator": "priority = 1", "var_name": "priority"}, {"original_string": "private NioLogger nioLogger;", "modifier": "private", "type": "NioLogger", "declarator": "nioLogger", "var_name": "nioLogger"}, {"original_string": "private AtomicLong outstandingRequests = new AtomicLong();", "modifier": "private", "type": "AtomicLong", "declarator": "outstandingRequests = new AtomicLong()", "var_name": "outstandingRequests"}, {"original_string": "private int unknownCipherKeyLength;", "modifier": "private", "type": "int", "declarator": "unknownCipherKeyLength", "var_name": "unknownCipherKeyLength"}], "methods": [{"identifier": "setStartingGate", "parameters": "(CougarStartingGate startingGate)", "modifiers": "public", "return": "void", "signature": "void setStartingGate(CougarStartingGate startingGate)", "full_signature": "public void setStartingGate(CougarStartingGate startingGate)", "class_method_signature": "SocketTransportCommandProcessor.setStartingGate(CougarStartingGate startingGate)", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "SocketTransportCommandProcessor.getName()", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "(SocketTransportCommand command)", "modifiers": "@Override public", "return": "void", "signature": "void process(SocketTransportCommand command)", "full_signature": "@Override public void process(SocketTransportCommand command)", "class_method_signature": "SocketTransportCommandProcessor.process(SocketTransportCommand command)", "testcase": false, "constructor": false}, {"identifier": "createCommandResolver", "parameters": "(SocketTransportCommand command, final Tracer tracer)", "modifiers": "@Override protected", "return": "CommandResolver<SocketTransportCommand>", "signature": "CommandResolver<SocketTransportCommand> createCommandResolver(SocketTransportCommand command, final Tracer tracer)", "full_signature": "@Override protected CommandResolver<SocketTransportCommand> createCommandResolver(SocketTransportCommand command, final Tracer tracer)", "class_method_signature": "SocketTransportCommandProcessor.createCommandResolver(SocketTransportCommand command, final Tracer tracer)", "testcase": false, "constructor": false}, {"identifier": "findCompatibleBinding", "parameters": "(OperationKey remoteOperationKey)", "modifiers": "private", "return": "OperationDefinition", "signature": "OperationDefinition findCompatibleBinding(OperationKey remoteOperationKey)", "full_signature": "private OperationDefinition findCompatibleBinding(OperationKey remoteOperationKey)", "class_method_signature": "SocketTransportCommandProcessor.findCompatibleBinding(OperationKey remoteOperationKey)", "testcase": false, "constructor": false}, {"identifier": "writeSuccessResponse", "parameters": "(SocketTransportRPCCommand command, ExecutionResult result, DehydratedExecutionContext context)", "modifiers": "protected", "return": "boolean", "signature": "boolean writeSuccessResponse(SocketTransportRPCCommand command, ExecutionResult result, DehydratedExecutionContext context)", "full_signature": "protected boolean writeSuccessResponse(SocketTransportRPCCommand command, ExecutionResult result, DehydratedExecutionContext context)", "class_method_signature": "SocketTransportCommandProcessor.writeSuccessResponse(SocketTransportRPCCommand command, ExecutionResult result, DehydratedExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "writeErrorResponse", "parameters": "(SocketTransportCommand command, DehydratedExecutionContext context, CougarException e, boolean traceStarted)", "modifiers": "@Override protected", "return": "void", "signature": "void writeErrorResponse(SocketTransportCommand command, DehydratedExecutionContext context, CougarException e, boolean traceStarted)", "full_signature": "@Override protected void writeErrorResponse(SocketTransportCommand command, DehydratedExecutionContext context, CougarException e, boolean traceStarted)", "class_method_signature": "SocketTransportCommandProcessor.writeErrorResponse(SocketTransportCommand command, DehydratedExecutionContext context, CougarException e, boolean traceStarted)", "testcase": false, "constructor": false}, {"identifier": "getCommandValidators", "parameters": "()", "modifiers": "@Override protected", "return": "List<CommandValidator<SocketTransportCommand>>", "signature": "List<CommandValidator<SocketTransportCommand>> getCommandValidators()", "full_signature": "@Override protected List<CommandValidator<SocketTransportCommand>> getCommandValidators()", "class_method_signature": "SocketTransportCommandProcessor.getCommandValidators()", "testcase": false, "constructor": false}, {"identifier": "onCougarStart", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void onCougarStart()", "full_signature": "@Override public void onCougarStart()", "class_method_signature": "SocketTransportCommandProcessor.onCougarStart()", "testcase": false, "constructor": false}, {"identifier": "getServiceBindingDescriptors", "parameters": "()", "modifiers": "private", "return": "Iterable<ServiceBindingDescriptor>", "signature": "Iterable<ServiceBindingDescriptor> getServiceBindingDescriptors()", "full_signature": "private Iterable<ServiceBindingDescriptor> getServiceBindingDescriptors()", "class_method_signature": "SocketTransportCommandProcessor.getServiceBindingDescriptors()", "testcase": false, "constructor": false}, {"identifier": "bindOperation", "parameters": "(OperationBindingDescriptor bindingDescriptor)", "modifiers": "public", "return": "void", "signature": "void bindOperation(OperationBindingDescriptor bindingDescriptor)", "full_signature": "public void bindOperation(OperationBindingDescriptor bindingDescriptor)", "class_method_signature": "SocketTransportCommandProcessor.bindOperation(OperationBindingDescriptor bindingDescriptor)", "testcase": false, "constructor": false}, {"identifier": "bind", "parameters": "(ServiceBindingDescriptor bindingDescriptor)", "modifiers": "@Override public", "return": "void", "signature": "void bind(ServiceBindingDescriptor bindingDescriptor)", "full_signature": "@Override public void bind(ServiceBindingDescriptor bindingDescriptor)", "class_method_signature": "SocketTransportCommandProcessor.bind(ServiceBindingDescriptor bindingDescriptor)", "testcase": false, "constructor": false}, {"identifier": "setMarshaller", "parameters": "(RemotableMethodInvocationMarshaller marshaller)", "modifiers": "@Required public", "return": "void", "signature": "void setMarshaller(RemotableMethodInvocationMarshaller marshaller)", "full_signature": "@Required public void setMarshaller(RemotableMethodInvocationMarshaller marshaller)", "class_method_signature": "SocketTransportCommandProcessor.setMarshaller(RemotableMethodInvocationMarshaller marshaller)", "testcase": false, "constructor": false}, {"identifier": "getMarshaller", "parameters": "()", "modifiers": "public", "return": "RemotableMethodInvocationMarshaller", "signature": "RemotableMethodInvocationMarshaller getMarshaller()", "full_signature": "public RemotableMethodInvocationMarshaller getMarshaller()", "class_method_signature": "SocketTransportCommandProcessor.getMarshaller()", "testcase": false, "constructor": false}, {"identifier": "getRegistry", "parameters": "()", "modifiers": "public", "return": "EventLoggingRegistry", "signature": "EventLoggingRegistry getRegistry()", "full_signature": "public EventLoggingRegistry getRegistry()", "class_method_signature": "SocketTransportCommandProcessor.getRegistry()", "testcase": false, "constructor": false}, {"identifier": "getIdentityResolverFactory", "parameters": "()", "modifiers": "public", "return": "IdentityResolverFactory", "signature": "IdentityResolverFactory getIdentityResolverFactory()", "full_signature": "public IdentityResolverFactory getIdentityResolverFactory()", "class_method_signature": "SocketTransportCommandProcessor.getIdentityResolverFactory()", "testcase": false, "constructor": false}, {"identifier": "setIdentityResolverFactory", "parameters": "(IdentityResolverFactory identityResolverFactory)", "modifiers": "public", "return": "void", "signature": "void setIdentityResolverFactory(IdentityResolverFactory identityResolverFactory)", "full_signature": "public void setIdentityResolverFactory(IdentityResolverFactory identityResolverFactory)", "class_method_signature": "SocketTransportCommandProcessor.setIdentityResolverFactory(IdentityResolverFactory identityResolverFactory)", "testcase": false, "constructor": false}, {"identifier": "setRegistry", "parameters": "(EventLoggingRegistry registry)", "modifiers": "@Required public", "return": "void", "signature": "void setRegistry(EventLoggingRegistry registry)", "full_signature": "@Required public void setRegistry(EventLoggingRegistry registry)", "class_method_signature": "SocketTransportCommandProcessor.setRegistry(EventLoggingRegistry registry)", "testcase": false, "constructor": false}, {"identifier": "setConnectedObjectManager", "parameters": "(ServerConnectedObjectManager connectedObjectManager)", "modifiers": "public", "return": "void", "signature": "void setConnectedObjectManager(ServerConnectedObjectManager connectedObjectManager)", "full_signature": "public void setConnectedObjectManager(ServerConnectedObjectManager connectedObjectManager)", "class_method_signature": "SocketTransportCommandProcessor.setConnectedObjectManager(ServerConnectedObjectManager connectedObjectManager)", "testcase": false, "constructor": false}, {"identifier": "getPriority", "parameters": "()", "modifiers": "@Override @ManagedAttribute public", "return": "int", "signature": "int getPriority()", "full_signature": "@Override @ManagedAttribute public int getPriority()", "class_method_signature": "SocketTransportCommandProcessor.getPriority()", "testcase": false, "constructor": false}, {"identifier": "setPriority", "parameters": "(int priority)", "modifiers": "public", "return": "void", "signature": "void setPriority(int priority)", "full_signature": "public void setPriority(int priority)", "class_method_signature": "SocketTransportCommandProcessor.setPriority(int priority)", "testcase": false, "constructor": false}, {"identifier": "setNioLogger", "parameters": "(NioLogger nioLogger)", "modifiers": "public", "return": "void", "signature": "void setNioLogger(NioLogger nioLogger)", "full_signature": "public void setNioLogger(NioLogger nioLogger)", "class_method_signature": "SocketTransportCommandProcessor.setNioLogger(NioLogger nioLogger)", "testcase": false, "constructor": false}, {"identifier": "incrementOutstandingRequests", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void incrementOutstandingRequests()", "full_signature": "private void incrementOutstandingRequests()", "class_method_signature": "SocketTransportCommandProcessor.incrementOutstandingRequests()", "testcase": false, "constructor": false}, {"identifier": "decrementOutstandingRequests", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void decrementOutstandingRequests()", "full_signature": "private void decrementOutstandingRequests()", "class_method_signature": "SocketTransportCommandProcessor.decrementOutstandingRequests()", "testcase": false, "constructor": false}, {"identifier": "getOutstandingRequests", "parameters": "()", "modifiers": "@ManagedAttribute public", "return": "long", "signature": "long getOutstandingRequests()", "full_signature": "@ManagedAttribute public long getOutstandingRequests()", "class_method_signature": "SocketTransportCommandProcessor.getOutstandingRequests()", "testcase": false, "constructor": false}, {"identifier": "setUnknownCipherKeyLength", "parameters": "(int unknownCipherKeyLength)", "modifiers": "public", "return": "void", "signature": "void setUnknownCipherKeyLength(int unknownCipherKeyLength)", "full_signature": "public void setUnknownCipherKeyLength(int unknownCipherKeyLength)", "class_method_signature": "SocketTransportCommandProcessor.setUnknownCipherKeyLength(int unknownCipherKeyLength)", "testcase": false, "constructor": false}, {"identifier": "getUnknownCipherKeyLength", "parameters": "()", "modifiers": "@ManagedAttribute public", "return": "int", "signature": "int getUnknownCipherKeyLength()", "full_signature": "@ManagedAttribute public int getUnknownCipherKeyLength()", "class_method_signature": "SocketTransportCommandProcessor.getUnknownCipherKeyLength()", "testcase": false, "constructor": false}], "file": "cougar-framework/socket-transport/src/main/java/com/betfair/cougar/transport/socket/SocketTransportCommandProcessor.java"}, "focal_method": {"identifier": "createCommandResolver", "parameters": "(SocketTransportCommand command, final Tracer tracer)", "modifiers": "@Override protected", "return": "CommandResolver<SocketTransportCommand>", "body": "@Override\n    protected CommandResolver<SocketTransportCommand> createCommandResolver(SocketTransportCommand command, final Tracer tracer) {\n        try {\n\n            final CougarObjectInput in = command.getInput();\n\n            // rpc call\n            if (command instanceof SocketTransportRPCCommand) {\n                final SocketTransportRPCCommand rpcCommand = (SocketTransportRPCCommand) command;\n\n                // we only want to do this once ideally\n                X509Certificate[] clientCertChain = (X509Certificate[]) rpcCommand.getSession().getAttribute(CougarProtocol.CLIENT_CERTS_ATTR_NAME);\n                Integer transportSecurityStrengthFactor = (Integer) rpcCommand.getSession().getAttribute(CougarProtocol.TSSF_ATTR_NAME);\n                Object sslSession = rpcCommand.getSession().getAttribute(SSLFilter.SSL_SESSION);\n                if (sslSession != null) {\n                    if (clientCertChain == null) {\n                        SSLSession session = (SSLSession) sslSession;\n                        try {\n                            clientCertChain = X509CertificateUtils.convert(session.getPeerCertificateChain());\n                        }\n                        catch (SSLPeerUnverifiedException spue) {\n                            // since we don't know in here that the client cert was required, we'll just ignore this..\n                            LOGGER.debug(\"SSL peer unverified\");\n                            clientCertChain = new X509Certificate[0];\n                        }\n                        rpcCommand.getSession().setAttribute(CougarProtocol.CLIENT_CERTS_ATTR_NAME, clientCertChain);\n                    }\n                    if (transportSecurityStrengthFactor == null) {\n                        SSLSession session = (SSLSession) sslSession;\n\n                        transportSecurityStrengthFactor = SSLCipherUtils.deduceKeyLength(session.getCipherSuite(), unknownCipherKeyLength);\n                        rpcCommand.getSession().setAttribute(CougarProtocol.TSSF_ATTR_NAME, transportSecurityStrengthFactor);\n                    }\n                }\n                else {\n                    if (clientCertChain == null) {\n                        clientCertChain = new X509Certificate[0];\n                        rpcCommand.getSession().setAttribute(CougarProtocol.CLIENT_CERTS_ATTR_NAME, clientCertChain);\n                    }\n                    if (transportSecurityStrengthFactor == null) {\n                        transportSecurityStrengthFactor = 0;\n                        rpcCommand.getSession().setAttribute(CougarProtocol.TSSF_ATTR_NAME, transportSecurityStrengthFactor);\n                    }\n                }\n                byte protocolVersion = CougarProtocol.getProtocolVersion(command.getSession());\n                final DehydratedExecutionContext context = marshaller.readExecutionContext(in, command.getRemoteAddress(), clientCertChain, transportSecurityStrengthFactor, protocolVersion);\n                final SocketRequestContextImpl requestContext = new SocketRequestContextImpl(context);\n                OperationKey remoteOperationKey = marshaller.readOperationKey(in);\n                OperationDefinition opDef = findCompatibleBinding(remoteOperationKey);\n                if (opDef == null) {\n                    throw new CougarFrameworkException(\"Can't find operation definition in bindings for operation named '\" + remoteOperationKey.getOperationName() + \"'\");\n                }\n                final OperationKey operationKey = opDef.getOperationKey(); // safer to read it from locally\n                final OperationDefinition operationDefinition = getExecutionVenue().getOperationDefinition(operationKey);\n                final Object[] args = marshaller.readArgs(operationDefinition.getParameters(), in);\n                TimeConstraints rawTimeConstraints = marshaller.readTimeConstraintsIfPresent(in, protocolVersion);\n                final TimeConstraints timeConstraints = DefaultTimeConstraints.rebaseFromNewStartTime(context.getRequestTime(), rawTimeConstraints);\n                final ExecutionCommand exec = new ExecutionCommand() {\n\n                    @Override\n                    public Object[] getArgs() {\n                        return args;\n                    }\n\n                    @Override\n                    public OperationKey getOperationKey() {\n                        return operationKey;\n                    }\n\n                    @Override\n                    public void onResult(ExecutionResult result) {\n                        if (result.getResultType() == ExecutionResult.ResultType.Success) {\n                            if (operationKey.getType() == OperationKey.Type.ConnectedObject) {\n                                connectedObjectManager.addSubscription(SocketTransportCommandProcessor.this, rpcCommand, (ConnectedResponse) result.getResult(), operationDefinition, requestContext, requestContext.getConnectedObjectLogExtension());\n                            } else {\n                                writeSuccessResponse(rpcCommand, result, requestContext);\n                            }\n                        } else if (result.getResultType() == ExecutionResult.ResultType.Fault) {\n                            writeErrorResponse(rpcCommand, requestContext, result.getFault(), true);\n                        }\n                    }\n\n                    @Override\n                    public TimeConstraints getTimeConstraints() {\n                        return timeConstraints;\n                    }\n                };\n\n                return new SingleExecutionCommandResolver<SocketTransportCommand>(tracer) {\n\n                    @Override\n                    public ExecutionCommand resolveExecutionCommand(Tracer tracer) {\n                        return exec;\n                    }\n\n                    @Override\n                    public DehydratedExecutionContext resolveExecutionContext() {\n                        return requestContext;\n                    }\n                };\n            } else {\n                LOGGER.error(\"SocketTransportCommandProcessor - Received an event request for processing like an rpc request, closing session\");\n                nioLogger.log(NioLogger.LoggingLevel.SESSION, command.getSession(), \"SocketTransportCommandProcessor - Received an event request for processing like an rpc request, closing session\");\n                command.getSession().close();\n                throw new IllegalStateException(\"Received an event request for processing like an rpc request\");\n            }\n        } catch (EnumDerialisationException ede) {\n            final String message = ede.getMessage();\n            LOGGER.debug(message, ede);\n            throw CougarMarshallingException.unmarshallingException(\"binary\",message,ede,false);\n        } catch (CougarException ce) {\n            throw ce;\n        } catch (TranscriptionException e) {\n            final String message = \"transcription exception deserialising invocation\";\n            LOGGER.debug(message, e);\n            throw CougarMarshallingException.unmarshallingException(\"binary\",message,e,false);\n        } catch (Exception e) {\n            final String message = \"Unable to deserialise invocation\";\n            LOGGER.debug(message, e);\n            throw CougarMarshallingException.unmarshallingException(\"binary\",message,e,false);\n        }\n\n    }", "signature": "CommandResolver<SocketTransportCommand> createCommandResolver(SocketTransportCommand command, final Tracer tracer)", "full_signature": "@Override protected CommandResolver<SocketTransportCommand> createCommandResolver(SocketTransportCommand command, final Tracer tracer)", "class_method_signature": "SocketTransportCommandProcessor.createCommandResolver(SocketTransportCommand command, final Tracer tracer)", "testcase": false, "constructor": false, "invocations": ["getInput", "getAttribute", "getSession", "getAttribute", "getSession", "getAttribute", "getSession", "convert", "getPeerCertificateChain", "debug", "setAttribute", "getSession", "deduceKeyLength", "getCipherSuite", "setAttribute", "getSession", "setAttribute", "getSession", "setAttribute", "getSession", "getProtocolVersion", "getSession", "readExecutionContext", "getRemoteAddress", "readOperationKey", "findCompatibleBinding", "getOperationName", "getOperationKey", "getOperationDefinition", "getExecutionVenue", "readArgs", "getParameters", "readTimeConstraintsIfPresent", "rebaseFromNewStartTime", "getRequestTime", "getResultType", "getType", "addSubscription", "getResult", "getConnectedObjectLogExtension", "writeSuccessResponse", "getResultType", "writeErrorResponse", "getFault", "error", "log", "getSession", "close", "getSession", "getMessage", "debug", "unmarshallingException", "debug", "unmarshallingException", "debug", "unmarshallingException"]}, "repository": {"repo_id": 13865967, "url": "https://github.com/betfair/cougar", "language": "Java", "is_fork": false, "fork_count": 18, "stargazer_count": 25, "size": 49594, "license": "licensed"}}