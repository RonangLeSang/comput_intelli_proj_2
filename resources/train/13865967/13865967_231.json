{"test_class": {"identifier": "PooledServerConnectedObjectManagerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger LOGGER = LoggerFactory.getLogger(PooledServerConnectedObjectManagerTest.class);", "modifier": "private static", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(PooledServerConnectedObjectManagerTest.class)", "var_name": "LOGGER"}, {"original_string": "private PooledServerConnectedObjectManager subject;", "modifier": "private", "type": "PooledServerConnectedObjectManager", "declarator": "subject", "var_name": "subject"}, {"original_string": "private ExpectingOutput cougarOutput;", "modifier": "private", "type": "ExpectingOutput", "declarator": "cougarOutput", "var_name": "cougarOutput"}, {"original_string": "private int ioSessionId;", "modifier": "private", "type": "int", "declarator": "ioSessionId", "var_name": "ioSessionId"}, {"original_string": "private int numThreads;", "modifier": "private", "type": "int", "declarator": "numThreads", "var_name": "numThreads"}], "file": "cougar-framework/socket-transport/src/test/java/com/betfair/cougar/transport/socket/PooledServerConnectedObjectManagerTest.java"}, "test_case": {"identifier": "addSecondSubscriptionMidStream", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void addSecondSubscriptionMidStream() throws Exception {\n        SocketTransportCommandProcessor commandProcessor = mock(SocketTransportCommandProcessor.class);\n        when(commandProcessor.writeSuccessResponse(any(SocketTransportRPCCommand.class), any(ExecutionResult.class), any(DehydratedExecutionContext.class))).thenReturn(true);\n\n        SocketTransportRPCCommand command = mock(SocketTransportRPCCommand.class);\n\n        DehydratedExecutionContext requestContext = mock(DehydratedExecutionContext.class);\n\n        MutableHeap heap = new MutableHeap(\"addSecondSubscriptionMidStream\");\n        Subscription sub = mock(Subscription.class);\n        ConnectedResponse subscriptionResult = new ConnectedResponseImpl(heap, sub);\n        OperationDefinition operationDefinition = mock(OperationDefinition.class);\n\n        List<Update> expectedUpdates = new ArrayList<Update>();\n        expectedUpdates.add(createInitial(new InstallRoot(0, NodeType.OBJECT), new InstallField(0, 1, \"value\", NodeType.SCALAR), new SetScalar(1, 1)));\n        expectedUpdates.add(createUpdate(new SetScalar(1, 2)));\n        // new initial for new sub\n        expectedUpdates.add(createInitial(new InstallRoot(0, NodeType.OBJECT), new InstallField(0, 1, \"value\", NodeType.SCALAR), new SetScalar(1, 2)));\n        expectedUpdates.add(createUpdate(new SetScalar(1, 3)));\n\n        cougarOutput.setExpectedUpdates(expectedUpdates);\n\n        heap.beginUpdate();\n        SimpleConnectedObject object = objectProjector(SimpleConnectedObject.class).project(heap.ensureRoot(NodeType.OBJECT));\n        object.value().set(1);\n        heap.endUpdate();\n\n        MyIoSession session = new MyIoSession(String.valueOf(ioSessionId++));\n        session.setAttribute(CougarProtocol.PROTOCOL_VERSION_ATTR_NAME, CougarProtocol.TRANSPORT_PROTOCOL_VERSION_MAX_SUPPORTED);\n        when(command.getSession()).thenReturn(session);\n\n        subject.addSubscription(commandProcessor, command, subscriptionResult, operationDefinition, requestContext, null);\n\n        heap.beginUpdate();\n        object = objectProjector(SimpleConnectedObject.class).project(heap.ensureRoot(NodeType.OBJECT));\n        object.value().set(2);\n        heap.endUpdate();\n\n        MyIoSession session2 = new MyIoSession(String.valueOf(ioSessionId++));\n        session2.setAttribute(CougarProtocol.PROTOCOL_VERSION_ATTR_NAME, CougarProtocol.TRANSPORT_PROTOCOL_VERSION_MAX_SUPPORTED);\n        when(command.getSession()).thenReturn(session2);\n\n        subject.addSubscription(commandProcessor, command, subscriptionResult, operationDefinition, requestContext, null);\n\n        heap.beginUpdate();\n        object = objectProjector(SimpleConnectedObject.class).project(heap.ensureRoot(NodeType.OBJECT));\n        object.value().set(3);\n        heap.endUpdate();\n\n        assertExpectedUpdatesWritten();\n\n        // might be related to the optimisation whereby if we need to send the same message to multiple clients we serialise it only once\n        int updatesWritten = cougarOutput.getAllValues().size() - 2;\n\n        // +1 to include the initial update for that session\n        assertExpectedSessionWrites(session, updatesWritten + 1);\n        assertExpectedSessionWrites(session2, updatesWritten); // +1 for initial update, but -1 for the one this doesn't see\n\n        verify(sub, never()).close();\n        verify(sub, never()).close(any(Subscription.CloseReason.class));\n    }", "signature": "void addSecondSubscriptionMidStream()", "full_signature": "@Test public void addSecondSubscriptionMidStream()", "class_method_signature": "PooledServerConnectedObjectManagerTest.addSecondSubscriptionMidStream()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "writeSuccessResponse", "any", "any", "any", "mock", "mock", "mock", "mock", "add", "createInitial", "add", "createUpdate", "add", "createInitial", "add", "createUpdate", "setExpectedUpdates", "beginUpdate", "project", "objectProjector", "ensureRoot", "set", "value", "endUpdate", "valueOf", "setAttribute", "thenReturn", "when", "getSession", "addSubscription", "beginUpdate", "project", "objectProjector", "ensureRoot", "set", "value", "endUpdate", "valueOf", "setAttribute", "thenReturn", "when", "getSession", "addSubscription", "beginUpdate", "project", "objectProjector", "ensureRoot", "set", "value", "endUpdate", "assertExpectedUpdatesWritten", "size", "getAllValues", "assertExpectedSessionWrites", "assertExpectedSessionWrites", "close", "verify", "never", "close", "verify", "never", "any"]}, "focal_class": {"identifier": "PooledServerConnectedObjectManager", "superclass": "", "interfaces": "implements ServerConnectedObjectManager", "fields": [{"original_string": "private static Logger LOGGER = LoggerFactory.getLogger(PooledServerConnectedObjectManager.class);", "modifier": "private static", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(PooledServerConnectedObjectManager.class)", "var_name": "LOGGER"}, {"original_string": "private static final AtomicLong heapStateInstanceIdSource = new AtomicLong();", "modifier": "private static final", "type": "AtomicLong", "declarator": "heapStateInstanceIdSource = new AtomicLong()", "var_name": "heapStateInstanceIdSource"}, {"original_string": "private EventLogger eventLogger;", "modifier": "private", "type": "EventLogger", "declarator": "eventLogger", "var_name": "eventLogger"}, {"original_string": "private NioLogger nioLogger;", "modifier": "private", "type": "NioLogger", "declarator": "nioLogger", "var_name": "nioLogger"}, {"original_string": "private BlockingDeque<String> heapsWaitingForUpdate = new LinkedBlockingDeque<String>();", "modifier": "private", "type": "BlockingDeque<String>", "declarator": "heapsWaitingForUpdate = new LinkedBlockingDeque<String>()", "var_name": "heapsWaitingForUpdate"}, {"original_string": "private ReentrantLock subTermLock = new ReentrantLock();", "modifier": "private", "type": "ReentrantLock", "declarator": "subTermLock = new ReentrantLock()", "var_name": "subTermLock"}, {"original_string": "private Map<String, HeapState> heapStates = new HashMap<String, HeapState>();", "modifier": "private", "type": "Map<String, HeapState>", "declarator": "heapStates = new HashMap<String, HeapState>()", "var_name": "heapStates"}, {"original_string": "private Map<Long, String> heapUris = new HashMap<Long, String>();", "modifier": "private", "type": "Map<Long, String>", "declarator": "heapUris = new HashMap<Long, String>()", "var_name": "heapUris"}, {"original_string": "private Map<IoSession, Multiset<String>> heapsByClient = new HashMap<IoSession, Multiset<String>>();", "modifier": "private", "type": "Map<IoSession, Multiset<String>>", "declarator": "heapsByClient = new HashMap<IoSession, Multiset<String>>()", "var_name": "heapsByClient"}, {"original_string": "private AtomicLong heapIdGenerator = new AtomicLong(0);", "modifier": "private", "type": "AtomicLong", "declarator": "heapIdGenerator = new AtomicLong(0)", "var_name": "heapIdGenerator"}, {"original_string": "private CougarObjectIOFactory objectIOFactory;", "modifier": "private", "type": "CougarObjectIOFactory", "declarator": "objectIOFactory", "var_name": "objectIOFactory"}, {"original_string": "private int numProcessingThreads;", "modifier": "private", "type": "int", "declarator": "numProcessingThreads", "var_name": "numProcessingThreads"}, {"original_string": "private List<ConnectedObjectPusher> pushers = new ArrayList<ConnectedObjectPusher>();", "modifier": "private", "type": "List<ConnectedObjectPusher>", "declarator": "pushers = new ArrayList<ConnectedObjectPusher>()", "var_name": "pushers"}, {"original_string": "private int maxUpdateActionsPerMessage;", "modifier": "private", "type": "int", "declarator": "maxUpdateActionsPerMessage", "var_name": "maxUpdateActionsPerMessage"}, {"original_string": "private UUIDGenerator uuidGenerator = new UUIDGeneratorImpl();", "modifier": "private", "type": "UUIDGenerator", "declarator": "uuidGenerator = new UUIDGeneratorImpl()", "var_name": "uuidGenerator"}, {"original_string": "private Thread shutdownHook = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            LOGGER.info(\"Terminating all push subscriptions due to application shutdown.\");\n            terminateAllSubscriptions(NODE_SHUTDOWN);\n        }\n    }, \"PooledServerConnectedObjectManager-ShutdownHook\");", "modifier": "private", "type": "Thread", "declarator": "shutdownHook = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            LOGGER.info(\"Terminating all push subscriptions due to application shutdown.\");\n            terminateAllSubscriptions(NODE_SHUTDOWN);\n        }\n    }, \"PooledServerConnectedObjectManager-ShutdownHook\")", "var_name": "shutdownHook"}], "methods": [{"identifier": "getHeapStates", "parameters": "()", "modifiers": "", "return": "Map<String, HeapState>", "signature": "Map<String, HeapState> getHeapStates()", "full_signature": " Map<String, HeapState> getHeapStates()", "class_method_signature": "PooledServerConnectedObjectManager.getHeapStates()", "testcase": false, "constructor": false}, {"identifier": "getHeapUris", "parameters": "()", "modifiers": "public", "return": "Map<Long, String>", "signature": "Map<Long, String> getHeapUris()", "full_signature": "public Map<Long, String> getHeapUris()", "class_method_signature": "PooledServerConnectedObjectManager.getHeapUris()", "testcase": false, "constructor": false}, {"identifier": "getHeapsByClient", "parameters": "()", "modifiers": "", "return": "Map<IoSession, Multiset<String>>", "signature": "Map<IoSession, Multiset<String>> getHeapsByClient()", "full_signature": " Map<IoSession, Multiset<String>> getHeapsByClient()", "class_method_signature": "PooledServerConnectedObjectManager.getHeapsByClient()", "testcase": false, "constructor": false}, {"identifier": "getHeapsWaitingForUpdate", "parameters": "()", "modifiers": "", "return": "BlockingDeque<String>", "signature": "BlockingDeque<String> getHeapsWaitingForUpdate()", "full_signature": " BlockingDeque<String> getHeapsWaitingForUpdate()", "class_method_signature": "PooledServerConnectedObjectManager.getHeapsWaitingForUpdate()", "testcase": false, "constructor": false}, {"identifier": "getHeapsForSession", "parameters": "(IoSession session)", "modifiers": "public", "return": "List<String>", "signature": "List<String> getHeapsForSession(IoSession session)", "full_signature": "public List<String> getHeapsForSession(IoSession session)", "class_method_signature": "PooledServerConnectedObjectManager.getHeapsForSession(IoSession session)", "testcase": false, "constructor": false}, {"identifier": "getHeapStateForMonitoring", "parameters": "(String uri)", "modifiers": "public", "return": "HeapStateMonitoring", "signature": "HeapStateMonitoring getHeapStateForMonitoring(String uri)", "full_signature": "public HeapStateMonitoring getHeapStateForMonitoring(String uri)", "class_method_signature": "PooledServerConnectedObjectManager.getHeapStateForMonitoring(String uri)", "testcase": false, "constructor": false}, {"identifier": "setNioLogger", "parameters": "(NioLogger nioLogger)", "modifiers": "@Override public", "return": "void", "signature": "void setNioLogger(NioLogger nioLogger)", "full_signature": "@Override public void setNioLogger(NioLogger nioLogger)", "class_method_signature": "PooledServerConnectedObjectManager.setNioLogger(NioLogger nioLogger)", "testcase": false, "constructor": false}, {"identifier": "setObjectIOFactory", "parameters": "(CougarObjectIOFactory objectIOFactory)", "modifiers": "public", "return": "void", "signature": "void setObjectIOFactory(CougarObjectIOFactory objectIOFactory)", "full_signature": "public void setObjectIOFactory(CougarObjectIOFactory objectIOFactory)", "class_method_signature": "PooledServerConnectedObjectManager.setObjectIOFactory(CougarObjectIOFactory objectIOFactory)", "testcase": false, "constructor": false}, {"identifier": "setNumProcessingThreads", "parameters": "(int i)", "modifiers": "public", "return": "void", "signature": "void setNumProcessingThreads(int i)", "full_signature": "public void setNumProcessingThreads(int i)", "class_method_signature": "PooledServerConnectedObjectManager.setNumProcessingThreads(int i)", "testcase": false, "constructor": false}, {"identifier": "setEventLogger", "parameters": "(EventLogger eventLogger)", "modifiers": "public", "return": "void", "signature": "void setEventLogger(EventLogger eventLogger)", "full_signature": "public void setEventLogger(EventLogger eventLogger)", "class_method_signature": "PooledServerConnectedObjectManager.setEventLogger(EventLogger eventLogger)", "testcase": false, "constructor": false}, {"identifier": "setMaxUpdateActionsPerMessage", "parameters": "(int maxUpdateActionsPerMessage)", "modifiers": "public", "return": "void", "signature": "void setMaxUpdateActionsPerMessage(int maxUpdateActionsPerMessage)", "full_signature": "public void setMaxUpdateActionsPerMessage(int maxUpdateActionsPerMessage)", "class_method_signature": "PooledServerConnectedObjectManager.setMaxUpdateActionsPerMessage(int maxUpdateActionsPerMessage)", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void start()", "full_signature": "public void start()", "class_method_signature": "PooledServerConnectedObjectManager.start()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void stop()", "full_signature": "public void stop()", "class_method_signature": "PooledServerConnectedObjectManager.stop()", "testcase": false, "constructor": false}, {"identifier": "terminateAllSubscriptions", "parameters": "(Subscription.CloseReason reason)", "modifiers": "private", "return": "void", "signature": "void terminateAllSubscriptions(Subscription.CloseReason reason)", "full_signature": "private void terminateAllSubscriptions(Subscription.CloseReason reason)", "class_method_signature": "PooledServerConnectedObjectManager.terminateAllSubscriptions(Subscription.CloseReason reason)", "testcase": false, "constructor": false}, {"identifier": "processHeapStateCreation", "parameters": "(final ConnectedResponse result, final String heapUri)", "modifiers": "private", "return": "HeapState", "signature": "HeapState processHeapStateCreation(final ConnectedResponse result, final String heapUri)", "full_signature": "private HeapState processHeapStateCreation(final ConnectedResponse result, final String heapUri)", "class_method_signature": "PooledServerConnectedObjectManager.processHeapStateCreation(final ConnectedResponse result, final String heapUri)", "testcase": false, "constructor": false}, {"identifier": "addSubscription", "parameters": "(final SocketTransportCommandProcessor commandProcessor, final SocketTransportRPCCommand command, final ConnectedResponse result, final OperationDefinition operationDefinition, final DehydratedExecutionContext context, final LogExtension connectedObjectLogExtension)", "modifiers": "@Override public", "return": "void", "signature": "void addSubscription(final SocketTransportCommandProcessor commandProcessor, final SocketTransportRPCCommand command, final ConnectedResponse result, final OperationDefinition operationDefinition, final DehydratedExecutionContext context, final LogExtension connectedObjectLogExtension)", "full_signature": "@Override public void addSubscription(final SocketTransportCommandProcessor commandProcessor, final SocketTransportRPCCommand command, final ConnectedResponse result, final OperationDefinition operationDefinition, final DehydratedExecutionContext context, final LogExtension connectedObjectLogExtension)", "class_method_signature": "PooledServerConnectedObjectManager.addSubscription(final SocketTransportCommandProcessor commandProcessor, final SocketTransportRPCCommand command, final ConnectedResponse result, final OperationDefinition operationDefinition, final DehydratedExecutionContext context, final LogExtension connectedObjectLogExtension)", "testcase": false, "constructor": false}, {"identifier": "terminateSubscription", "parameters": "(IoSession session, TerminateSubscription payload)", "modifiers": "@Override public", "return": "void", "signature": "void terminateSubscription(IoSession session, TerminateSubscription payload)", "full_signature": "@Override public void terminateSubscription(IoSession session, TerminateSubscription payload)", "class_method_signature": "PooledServerConnectedObjectManager.terminateSubscription(IoSession session, TerminateSubscription payload)", "testcase": false, "constructor": false}, {"identifier": "terminateSubscription", "parameters": "(IoSession session, String heapUri, String subscriptionId, Subscription.CloseReason reason)", "modifiers": "public", "return": "void", "signature": "void terminateSubscription(IoSession session, String heapUri, String subscriptionId, Subscription.CloseReason reason)", "full_signature": "public void terminateSubscription(IoSession session, String heapUri, String subscriptionId, Subscription.CloseReason reason)", "class_method_signature": "PooledServerConnectedObjectManager.terminateSubscription(IoSession session, String heapUri, String subscriptionId, Subscription.CloseReason reason)", "testcase": false, "constructor": false}, {"identifier": "terminateSubscriptions", "parameters": "(IoSession session, String heapUri, Subscription.CloseReason reason)", "modifiers": "private", "return": "void", "signature": "void terminateSubscriptions(IoSession session, String heapUri, Subscription.CloseReason reason)", "full_signature": "private void terminateSubscriptions(IoSession session, String heapUri, Subscription.CloseReason reason)", "class_method_signature": "PooledServerConnectedObjectManager.terminateSubscriptions(IoSession session, String heapUri, Subscription.CloseReason reason)", "testcase": false, "constructor": false}, {"identifier": "terminateSubscriptions", "parameters": "(IoSession session, HeapState state, String heapUri, Subscription.CloseReason reason)", "modifiers": "private", "return": "void", "signature": "void terminateSubscriptions(IoSession session, HeapState state, String heapUri, Subscription.CloseReason reason)", "full_signature": "private void terminateSubscriptions(IoSession session, HeapState state, String heapUri, Subscription.CloseReason reason)", "class_method_signature": "PooledServerConnectedObjectManager.terminateSubscriptions(IoSession session, HeapState state, String heapUri, Subscription.CloseReason reason)", "testcase": false, "constructor": false}, {"identifier": "terminateSubscriptions", "parameters": "(IoSession session, Subscription.CloseReason reason)", "modifiers": "private", "return": "void", "signature": "void terminateSubscriptions(IoSession session, Subscription.CloseReason reason)", "full_signature": "private void terminateSubscriptions(IoSession session, Subscription.CloseReason reason)", "class_method_signature": "PooledServerConnectedObjectManager.terminateSubscriptions(IoSession session, Subscription.CloseReason reason)", "testcase": false, "constructor": false}, {"identifier": "terminateSubscriptions", "parameters": "(String heapUri, Subscription.CloseReason reason)", "modifiers": "private", "return": "void", "signature": "void terminateSubscriptions(String heapUri, Subscription.CloseReason reason)", "full_signature": "private void terminateSubscriptions(String heapUri, Subscription.CloseReason reason)", "class_method_signature": "PooledServerConnectedObjectManager.terminateSubscriptions(String heapUri, Subscription.CloseReason reason)", "testcase": false, "constructor": false}, {"identifier": "sessionOpened", "parameters": "(IoSession session)", "modifiers": "@Override public", "return": "void", "signature": "void sessionOpened(IoSession session)", "full_signature": "@Override public void sessionOpened(IoSession session)", "class_method_signature": "PooledServerConnectedObjectManager.sessionOpened(IoSession session)", "testcase": false, "constructor": false}, {"identifier": "sessionClosed", "parameters": "(IoSession session)", "modifiers": "@Override public", "return": "void", "signature": "void sessionClosed(IoSession session)", "full_signature": "@Override public void sessionClosed(IoSession session)", "class_method_signature": "PooledServerConnectedObjectManager.sessionClosed(IoSession session)", "testcase": false, "constructor": false}, {"identifier": "getNumberOfHeaps", "parameters": "()", "modifiers": "@ManagedAttribute(description = \"Number of active heaps\") public", "return": "int", "signature": "int getNumberOfHeaps()", "full_signature": "@ManagedAttribute(description = \"Number of active heaps\") public int getNumberOfHeaps()", "class_method_signature": "PooledServerConnectedObjectManager.getNumberOfHeaps()", "testcase": false, "constructor": false}, {"identifier": "getHeapSubscriptionCount", "parameters": "(String heapUri)", "modifiers": "@ManagedOperation(description = \"Number of subscriptions for the given heap URI\") public", "return": "int", "signature": "int getHeapSubscriptionCount(String heapUri)", "full_signature": "@ManagedOperation(description = \"Number of subscriptions for the given heap URI\") public int getHeapSubscriptionCount(String heapUri)", "class_method_signature": "PooledServerConnectedObjectManager.getHeapSubscriptionCount(String heapUri)", "testcase": false, "constructor": false}, {"identifier": "getHeapSessionCount", "parameters": "(String heapUri)", "modifiers": "@ManagedOperation(description = \"Number of sessions subscribed for the given heap URI\") public", "return": "int", "signature": "int getHeapSessionCount(String heapUri)", "full_signature": "@ManagedOperation(description = \"Number of sessions subscribed for the given heap URI\") public int getHeapSessionCount(String heapUri)", "class_method_signature": "PooledServerConnectedObjectManager.getHeapSessionCount(String heapUri)", "testcase": false, "constructor": false}, {"identifier": "hasHeapTerminated", "parameters": "(String heapUri)", "modifiers": "@ManagedOperation(description = \"Has the specified heap terminated\") public", "return": "boolean", "signature": "boolean hasHeapTerminated(String heapUri)", "full_signature": "@ManagedOperation(description = \"Has the specified heap terminated\") public boolean hasHeapTerminated(String heapUri)", "class_method_signature": "PooledServerConnectedObjectManager.hasHeapTerminated(String heapUri)", "testcase": false, "constructor": false}, {"identifier": "getLastUpdateId", "parameters": "(String heapUri)", "modifiers": "@ManagedOperation(description = \"Last received update Id\") public", "return": "long", "signature": "long getLastUpdateId(String heapUri)", "full_signature": "@ManagedOperation(description = \"Last received update Id\") public long getLastUpdateId(String heapUri)", "class_method_signature": "PooledServerConnectedObjectManager.getLastUpdateId(String heapUri)", "testcase": false, "constructor": false}, {"identifier": "showNumOfQueuedChanges", "parameters": "(String heapUri)", "modifiers": "@ManagedOperation(description = \"Number of updates queued for the specified heap\") public", "return": "long", "signature": "long showNumOfQueuedChanges(String heapUri)", "full_signature": "@ManagedOperation(description = \"Number of updates queued for the specified heap\") public long showNumOfQueuedChanges(String heapUri)", "class_method_signature": "PooledServerConnectedObjectManager.showNumOfQueuedChanges(String heapUri)", "testcase": false, "constructor": false}, {"identifier": "getNumProcessingThreads", "parameters": "()", "modifiers": "@ManagedAttribute(description = \"Number of pusher threads\") public", "return": "int", "signature": "int getNumProcessingThreads()", "full_signature": "@ManagedAttribute(description = \"Number of pusher threads\") public int getNumProcessingThreads()", "class_method_signature": "PooledServerConnectedObjectManager.getNumProcessingThreads()", "testcase": false, "constructor": false}], "file": "cougar-framework/socket-transport/src/main/java/com/betfair/cougar/transport/socket/PooledServerConnectedObjectManager.java"}, "focal_method": {"identifier": "addSubscription", "parameters": "(final SocketTransportCommandProcessor commandProcessor, final SocketTransportRPCCommand command, final ConnectedResponse result, final OperationDefinition operationDefinition, final DehydratedExecutionContext context, final LogExtension connectedObjectLogExtension)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void addSubscription(final SocketTransportCommandProcessor commandProcessor, final SocketTransportRPCCommand command, final ConnectedResponse result, final OperationDefinition operationDefinition, final DehydratedExecutionContext context, final LogExtension connectedObjectLogExtension) {\n        final String heapUri = result.getHeap().getUri();\n        HeapState heapState = null;\n        try {\n            boolean readyToContinue = false;\n\n            while (!readyToContinue) {\n                // only need this lock to modify the heapStates map, we need the state lock to modify the contained state later..\n                subTermLock.lock();\n                heapState = heapStates.get(heapUri);\n                boolean wasNewHeapState = heapState == null;\n                if (wasNewHeapState) {\n                    heapState = processHeapStateCreation(result, heapUri);\n                    readyToContinue = true;\n                }\n                // for existing heaps we lock in the same way as usual\n                else {\n                    // we have to release this lock now so we can get them in the right order, otherwise we could deadlock\n                    // this is safe since we know that at this moment in time there is a live heap state for this heapuri\n                    subTermLock.unlock();\n\n                    // between these 2 calls one of 3 things can happen:\n                    // 1: nothing\n                    // 2: the last subscriber to the heap state unsubscribes and the heap state is removed\n                    // 3: the last subscriber goes away and someone else comes through at the right moment and recreates it (less likely)\n\n                    // in the last case we need to just keep looping until we know for certain it hasn't happened...\n                    // what we need is a unique heapstate instance id which we can compare to... (AtomicLong should be sufficient)\n\n                    // now get them in the right order\n                    heapState.getUpdateLock().lock();\n                    subTermLock.lock();\n\n\n                    // so, in case 2 above the heap is now not in the map.. in which case we're going to subscribe to something just as it goes..\n                    // so, lets do that new state check once more\n                    if (!heapStates.containsKey(heapUri)) {\n                        heapState = processHeapStateCreation(result, heapUri);\n                        readyToContinue = true;\n                    }\n                    // ok, so it's still there, now we need to check if it's the same one..\n                    else {\n                        HeapState latestState = heapStates.get(heapUri);\n                        // case 1 above\n                        if (latestState.getInstanceId() == heapState.getInstanceId()) {\n                            readyToContinue = true;\n                        }\n                        // case 3 above\n                        else {\n                            // this shouldn't matter anymore as we've got a lock on a dead heap\n                            heapState.getUpdateLock().unlock();\n                            // reset our check state and go back round until we're happy\n                            heapState = latestState;\n                        }\n                    }\n                }\n            }\n\n            // right, now we've got both locks, in the right order and we've definitely got a heap state which everyone else can also get/has got\n\n            final HeapState finalHeapState = heapState;\n            // hmm,\n            final Subscription subscription = result.getSubscription();\n            result.getHeap().traverse(new UpdateProducingHeapListener() {\n                @Override\n                protected void doUpdate(Update u) {\n                    boolean updateContainsTermination = u.getActions().contains(TerminateHeap.INSTANCE);\n                    if (updateContainsTermination) {\n                        // note this won't notify this sub, which never got started. the publisher code won't expect a call back for this since\n                        // it's just terminated the heap, which implies it wants to disconnect all clients anyway\n                        terminateSubscriptions(command.getSession(), heapUri, REQUESTED_BY_PUBLISHER);\n                        commandProcessor.writeErrorResponse(command, context, new CougarFrameworkException(\"Subscription requested for terminated heap: \" + heapUri), true);\n                        return;\n                    }\n\n                    Multiset<String> heapsForThisClient = heapsByClient.get(command.getSession());\n                    if (heapsForThisClient == null) {\n                        heapsForThisClient = new Multiset<String>();\n                        heapsByClient.put(command.getSession(), heapsForThisClient);\n                    }\n\n                    long heapId = finalHeapState.getHeapId();\n\n                    final String subscriptionId = finalHeapState.addSubscription(connectedObjectLogExtension, subscription, command.getSession());\n                    subscription.addListener(new Subscription.SubscriptionListener() {\n                        @Override\n                        public void subscriptionClosed(Subscription subscription, Subscription.CloseReason reason) {\n                            if (reason == REQUESTED_BY_PUBLISHER) {\n                                PooledServerConnectedObjectManager.this.terminateSubscription(command.getSession(), heapUri, subscriptionId, reason);\n                            }\n                            // log end regardless of the reason\n                            finalHeapState.logSubscriptionEnd(subscriptionId, connectedObjectLogExtension, reason);\n                        }\n                    });\n                    boolean newHeapDefinition = heapsForThisClient.count(heapUri) == 0;\n                    heapsForThisClient.add(heapUri);\n\n                    NewHeapSubscription response;\n                    if (newHeapDefinition) {\n                        response = new NewHeapSubscription(heapId, subscriptionId, heapUri);\n                    } else {\n                        response = new NewHeapSubscription(heapId, subscriptionId);\n                    }\n\n                    // first tell the client about the heap\n                    ExecutionResult executionResult = new ExecutionResult(response);\n                    boolean successfulResponse = commandProcessor.writeSuccessResponse(command, executionResult, context);\n                    // so if we couldn't send the response it means we know the client isn't going to have a sub response, which means we need to clean up on our\n                    // end so we don't get warnings on the client about receiving updates for something it knows nothing about..\n                    if (!successfulResponse) {\n                        terminateSubscriptions(command.getSession(), heapUri, INTERNAL_ERROR);\n                    }\n\n                    if (newHeapDefinition) {\n                        // then add the sub initialisation to the update queue\n                        finalHeapState.getQueuedChanges().add(new QueuedHeapChange(new QueuedSubscription(command.getSession(), new InitialUpdate(u))));\n                        heapsWaitingForUpdate.add(heapUri);\n                    }\n                }\n            });\n        } finally {\n            subTermLock.unlock();\n            assert heapState != null;\n            heapState.getUpdateLock().unlock();\n        }\n    }", "signature": "void addSubscription(final SocketTransportCommandProcessor commandProcessor, final SocketTransportRPCCommand command, final ConnectedResponse result, final OperationDefinition operationDefinition, final DehydratedExecutionContext context, final LogExtension connectedObjectLogExtension)", "full_signature": "@Override public void addSubscription(final SocketTransportCommandProcessor commandProcessor, final SocketTransportRPCCommand command, final ConnectedResponse result, final OperationDefinition operationDefinition, final DehydratedExecutionContext context, final LogExtension connectedObjectLogExtension)", "class_method_signature": "PooledServerConnectedObjectManager.addSubscription(final SocketTransportCommandProcessor commandProcessor, final SocketTransportRPCCommand command, final ConnectedResponse result, final OperationDefinition operationDefinition, final DehydratedExecutionContext context, final LogExtension connectedObjectLogExtension)", "testcase": false, "constructor": false, "invocations": ["getUri", "getHeap", "lock", "get", "processHeapStateCreation", "unlock", "lock", "getUpdateLock", "lock", "containsKey", "processHeapStateCreation", "get", "getInstanceId", "getInstanceId", "unlock", "getUpdateLock", "getSubscription", "traverse", "getHeap", "contains", "getActions", "terminateSubscriptions", "getSession", "writeErrorResponse", "get", "getSession", "put", "getSession", "getHeapId", "addSubscription", "getSession", "addListener", "terminateSubscription", "getSession", "logSubscriptionEnd", "count", "add", "writeSuccessResponse", "terminateSubscriptions", "getSession", "add", "getQueuedChanges", "getSession", "add", "unlock", "unlock", "getUpdateLock"]}, "repository": {"repo_id": 13865967, "url": "https://github.com/betfair/cougar", "language": "Java", "is_fork": false, "fork_count": 18, "stargazer_count": 25, "size": 49594, "license": "licensed"}}