{"test_class": {"identifier": "StatsTest", "superclass": "", "interfaces": "", "fields": [], "file": "commons/src/test/java/org/apache/aurora/common/stats/StatsTest.java"}, "test_case": {"identifier": "testNotSame", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testNotSame() {\n    AtomicLong firstExport = Stats.exportLong(\"somevar\");\n    firstExport.incrementAndGet();\n    firstExport.incrementAndGet();\n    assertCounter(\"somevar\", 2L);\n    AtomicLong secondExport = Stats.exportLong(\"somevar\");\n    assertNotSame(firstExport, secondExport);\n    secondExport.incrementAndGet();\n    assertCounter(\"somevar\", 2L); // We keep the first one!\n  }", "signature": "void testNotSame()", "full_signature": "@Test public void testNotSame()", "class_method_signature": "StatsTest.testNotSame()", "testcase": true, "constructor": false, "invocations": ["exportLong", "incrementAndGet", "incrementAndGet", "assertCounter", "exportLong", "assertNotSame", "incrementAndGet", "assertCounter"]}, "focal_class": {"identifier": "Stats", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(Stats.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(Stats.class)", "var_name": "LOG"}, {"original_string": "private static final Pattern NOT_NAME_CHAR = Pattern.compile(\"[^A-Za-z0-9_/.-]\");", "modifier": "private static final", "type": "Pattern", "declarator": "NOT_NAME_CHAR = Pattern.compile(\"[^A-Za-z0-9_/.-]\")", "var_name": "NOT_NAME_CHAR"}, {"original_string": "private static final ConcurrentMap<String, Stat<?>> VAR_MAP = new MapMaker().makeMap();", "modifier": "private static final", "type": "ConcurrentMap<String, Stat<?>>", "declarator": "VAR_MAP = new MapMaker().makeMap()", "var_name": "VAR_MAP"}, {"original_string": "private static final Collection<RecordingStat<? extends Number>> ORDERED_NUMERIC_STATS =\n      new ConcurrentLinkedQueue<>();", "modifier": "private static final", "type": "Collection<RecordingStat<? extends Number>>", "declarator": "ORDERED_NUMERIC_STATS =\n      new ConcurrentLinkedQueue<>()", "var_name": "ORDERED_NUMERIC_STATS"}, {"original_string": "private static final Cache<String, RecordingStat<? extends Number>> NUMERIC_STATS =\n      CacheBuilder.newBuilder().build();", "modifier": "private static final", "type": "Cache<String, RecordingStat<? extends Number>>", "declarator": "NUMERIC_STATS =\n      CacheBuilder.newBuilder().build()", "var_name": "NUMERIC_STATS"}, {"original_string": "public static final StatsProvider STATS_PROVIDER = new StatsProvider() {\n    private final StatsProvider untracked = new StatsProvider() {\n      @Override public AtomicLong makeCounter(String name) {\n        final AtomicLong longVar = new AtomicLong();\n        Stats.exportStatic(new StatImpl<Long>(name) {\n          @Override public Long read() {\n            return longVar.get();\n          }\n        });\n        return longVar;\n      }\n\n      @Override public <T extends Number> Stat<T> makeGauge(String name, final Supplier<T> gauge) {\n        return Stats.exportStatic(new StatImpl<T>(name) {\n          @Override public T read() {\n            return gauge.get();\n          }\n        });\n      }\n\n      @Override public StatsProvider untracked() {\n        return this;\n      }\n\n      @Override public RequestTimer makeRequestTimer(String name) {\n        // TODO(William Farner): Add support for this once a caller shows interest in using it.\n        throw new UnsupportedOperationException();\n      }\n    };\n\n    @Override public <T extends Number> Stat<T> makeGauge(String name, final Supplier<T> gauge) {\n      return Stats.export(new StatImpl<T>(name) {\n        @Override public T read() {\n          return gauge.get();\n        }\n      });\n    }\n\n    @Override public AtomicLong makeCounter(String name) {\n      return Stats.exportLong(name);\n    }\n\n    @Override public StatsProvider untracked() {\n      return untracked;\n    }\n\n    @Override public RequestTimer makeRequestTimer(String name) {\n      return new RequestStats(name);\n    }\n  };", "modifier": "public static final", "type": "StatsProvider", "declarator": "STATS_PROVIDER = new StatsProvider() {\n    private final StatsProvider untracked = new StatsProvider() {\n      @Override public AtomicLong makeCounter(String name) {\n        final AtomicLong longVar = new AtomicLong();\n        Stats.exportStatic(new StatImpl<Long>(name) {\n          @Override public Long read() {\n            return longVar.get();\n          }\n        });\n        return longVar;\n      }\n\n      @Override public <T extends Number> Stat<T> makeGauge(String name, final Supplier<T> gauge) {\n        return Stats.exportStatic(new StatImpl<T>(name) {\n          @Override public T read() {\n            return gauge.get();\n          }\n        });\n      }\n\n      @Override public StatsProvider untracked() {\n        return this;\n      }\n\n      @Override public RequestTimer makeRequestTimer(String name) {\n        // TODO(William Farner): Add support for this once a caller shows interest in using it.\n        throw new UnsupportedOperationException();\n      }\n    };\n\n    @Override public <T extends Number> Stat<T> makeGauge(String name, final Supplier<T> gauge) {\n      return Stats.export(new StatImpl<T>(name) {\n        @Override public T read() {\n          return gauge.get();\n        }\n      });\n    }\n\n    @Override public AtomicLong makeCounter(String name) {\n      return Stats.exportLong(name);\n    }\n\n    @Override public StatsProvider untracked() {\n      return untracked;\n    }\n\n    @Override public RequestTimer makeRequestTimer(String name) {\n      return new RequestStats(name);\n    }\n  }", "var_name": "STATS_PROVIDER"}, {"original_string": "public static final StatRegistry STAT_REGISTRY = Stats::getNumericVariables;", "modifier": "public static final", "type": "StatRegistry", "declarator": "STAT_REGISTRY = Stats::getNumericVariables", "var_name": "STAT_REGISTRY"}], "methods": [{"identifier": "normalizeName", "parameters": "(String name)", "modifiers": "public static", "return": "String", "signature": "String normalizeName(String name)", "full_signature": "public static String normalizeName(String name)", "class_method_signature": "Stats.normalizeName(String name)", "testcase": false, "constructor": false}, {"identifier": "validateName", "parameters": "(String name)", "modifiers": "static", "return": "String", "signature": "String validateName(String name)", "full_signature": "static String validateName(String name)", "class_method_signature": "Stats.validateName(String name)", "testcase": false, "constructor": false}, {"identifier": "export", "parameters": "(Stat<T> var)", "modifiers": "public static", "return": "Stat<T>", "signature": "Stat<T> export(Stat<T> var)", "full_signature": "public static Stat<T> export(Stat<T> var)", "class_method_signature": "Stats.export(Stat<T> var)", "testcase": false, "constructor": false}, {"identifier": "exportString", "parameters": "(Stat<String> var)", "modifiers": "static", "return": "Stat<String>", "signature": "Stat<String> exportString(Stat<String> var)", "full_signature": "static Stat<String> exportString(Stat<String> var)", "class_method_signature": "Stats.exportString(Stat<String> var)", "testcase": false, "constructor": false}, {"identifier": "exportAll", "parameters": "(Iterable<Stat<? extends Number>> vars)", "modifiers": "static", "return": "void", "signature": "void exportAll(Iterable<Stat<? extends Number>> vars)", "full_signature": "static void exportAll(Iterable<Stat<? extends Number>> vars)", "class_method_signature": "Stats.exportAll(Iterable<Stat<? extends Number>> vars)", "testcase": false, "constructor": false}, {"identifier": "exportInt", "parameters": "(final String name)", "modifiers": "public static", "return": "AtomicInteger", "signature": "AtomicInteger exportInt(final String name)", "full_signature": "public static AtomicInteger exportInt(final String name)", "class_method_signature": "Stats.exportInt(final String name)", "testcase": false, "constructor": false}, {"identifier": "exportLong", "parameters": "(String name)", "modifiers": "public static", "return": "AtomicLong", "signature": "AtomicLong exportLong(String name)", "full_signature": "public static AtomicLong exportLong(String name)", "class_method_signature": "Stats.exportLong(String name)", "testcase": false, "constructor": false}, {"identifier": "exportStatic", "parameters": "(Stat<T> var)", "modifiers": "static", "return": "Stat<T>", "signature": "Stat<T> exportStatic(Stat<T> var)", "full_signature": "static Stat<T> exportStatic(Stat<T> var)", "class_method_signature": "Stats.exportStatic(Stat<T> var)", "testcase": false, "constructor": false}, {"identifier": "exportStaticInternal", "parameters": "(String name, Stat<?> stat)", "modifiers": "private static", "return": "void", "signature": "void exportStaticInternal(String name, Stat<?> stat)", "full_signature": "private static void exportStaticInternal(String name, Stat<?> stat)", "class_method_signature": "Stats.exportStaticInternal(String name, Stat<?> stat)", "testcase": false, "constructor": false}, {"identifier": "getVariables", "parameters": "()", "modifiers": "public static", "return": "Iterable<Stat<?>>", "signature": "Iterable<Stat<?>> getVariables()", "full_signature": "public static Iterable<Stat<?>> getVariables()", "class_method_signature": "Stats.getVariables()", "testcase": false, "constructor": false}, {"identifier": "getNumericVariables", "parameters": "()", "modifiers": "static", "return": "Iterable<RecordingStat<? extends Number>>", "signature": "Iterable<RecordingStat<? extends Number>> getNumericVariables()", "full_signature": "static Iterable<RecordingStat<? extends Number>> getNumericVariables()", "class_method_signature": "Stats.getNumericVariables()", "testcase": false, "constructor": false}, {"identifier": "flush", "parameters": "()", "modifiers": "@VisibleForTesting public static", "return": "void", "signature": "void flush()", "full_signature": "@VisibleForTesting public static void flush()", "class_method_signature": "Stats.flush()", "testcase": false, "constructor": false}, {"identifier": "getVariable", "parameters": "(String name)", "modifiers": "@VisibleForTesting public static", "return": "Stat<T>", "signature": "Stat<T> getVariable(String name)", "full_signature": "@VisibleForTesting public static Stat<T> getVariable(String name)", "class_method_signature": "Stats.getVariable(String name)", "testcase": false, "constructor": false}], "file": "commons/src/main/java/org/apache/aurora/common/stats/Stats.java"}, "focal_method": {"identifier": "exportLong", "parameters": "(String name)", "modifiers": "public static", "return": "AtomicLong", "body": "public static AtomicLong exportLong(String name) {\n    final AtomicLong longVar = new AtomicLong(0L);\n    export(new StatImpl<Long>(name) {\n      @Override public Long read() { return longVar.get(); }\n    });\n\n    return longVar;\n  }", "signature": "AtomicLong exportLong(String name)", "full_signature": "public static AtomicLong exportLong(String name)", "class_method_signature": "Stats.exportLong(String name)", "testcase": false, "constructor": false, "invocations": ["export", "get"]}, "repository": {"repo_id": 14135467, "url": "https://github.com/apache/attic-aurora", "language": "Java", "is_fork": false, "fork_count": 242, "stargazer_count": 625, "size": 30334, "license": "licensed"}}