{"test_class": {"identifier": "GapInterpolatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected static final short g = -9;", "modifier": "protected static final", "type": "short", "declarator": "g = -9", "var_name": "g"}, {"original_string": "protected static final short[][] testArr = new short[][]{\n        { g,1,1,2,2,2 },\n        { 1,1,g,g,2,2 },\n        { 1,1,g,2,2,2 },\n        { 2,2,g,3,3,3 },\n        { 2,2,2,3,g,3 },\n        { 2,2,g,3,g,g }\n    };", "modifier": "protected static final", "type": "short[][]", "declarator": "testArr = new short[][]{\n        { g,1,1,2,2,2 },\n        { 1,1,g,g,2,2 },\n        { 1,1,g,2,2,2 },\n        { 2,2,g,3,3,3 },\n        { 2,2,2,3,g,3 },\n        { 2,2,g,3,g,g }\n    }", "var_name": "testArr"}, {"original_string": "protected static final short[][] testArr2 = new short[][]{\n        { 1,1,1,1,1,1,2,2,2,2,2,2 },\n        { 1,1,1,g,1,1,2,2,2,2,2,2 },\n        { 1,1,1,g,1,1,2,2,2,2,2,2 },\n        { 1,1,1,1,1,1,2,g,g,g,g,g },\n        { g,1,1,1,1,1,2,2,2,2,2,2 },\n        { g,g,1,1,1,1,2,2,2,2,2,2 },\n        { g,g,2,2,2,2,3,3,3,3,3,3 },\n        { g,g,2,2,2,2,3,3,3,3,3,3 },\n        { g,g,g,2,2,2,3,g,g,g,g,3 },\n        { g,g,2,2,2,2,g,g,g,g,g,g },\n        { g,g,2,2,2,2,3,g,g,g,g,3 },\n        { 2,2,2,2,2,2,3,3,g,g,3,3 }\n    };", "modifier": "protected static final", "type": "short[][]", "declarator": "testArr2 = new short[][]{\n        { 1,1,1,1,1,1,2,2,2,2,2,2 },\n        { 1,1,1,g,1,1,2,2,2,2,2,2 },\n        { 1,1,1,g,1,1,2,2,2,2,2,2 },\n        { 1,1,1,1,1,1,2,g,g,g,g,g },\n        { g,1,1,1,1,1,2,2,2,2,2,2 },\n        { g,g,1,1,1,1,2,2,2,2,2,2 },\n        { g,g,2,2,2,2,3,3,3,3,3,3 },\n        { g,g,2,2,2,2,3,3,3,3,3,3 },\n        { g,g,g,2,2,2,3,g,g,g,g,3 },\n        { g,g,2,2,2,2,g,g,g,g,g,g },\n        { g,g,2,2,2,2,3,g,g,g,g,3 },\n        { 2,2,2,2,2,2,3,3,g,g,3,3 }\n    }", "var_name": "testArr2"}, {"original_string": "protected static final short[][] testArr3 = new short[][]{\n        { 1,1,1,1,1,1,2,2,2,2,2,2 },\n        { 1,1,1,g,g,g,g,g,g,g,2,2 },\n        { 1,1,1,g,g,g,g,g,g,g,2,2 },\n        { 1,1,1,g,g,g,g,g,g,g,g,g },\n        { g,1,g,g,g,g,g,g,g,2,2,2 },\n        { g,g,g,g,g,g,g,g,g,2,2,2 },\n        { g,g,g,g,g,g,g,g,g,3,3,3 },\n        { g,g,g,g,g,g,g,g,g,3,3,3 },\n        { g,g,g,g,g,g,g,g,g,g,g,3 },\n        { g,g,g,g,g,g,g,g,g,g,g,3 },\n        { g,g,2,2,2,2,3,g,g,g,g,3 },\n        { 2,2,2,2,2,2,3,3,g,g,3,3 }\n    };", "modifier": "protected static final", "type": "short[][]", "declarator": "testArr3 = new short[][]{\n        { 1,1,1,1,1,1,2,2,2,2,2,2 },\n        { 1,1,1,g,g,g,g,g,g,g,2,2 },\n        { 1,1,1,g,g,g,g,g,g,g,2,2 },\n        { 1,1,1,g,g,g,g,g,g,g,g,g },\n        { g,1,g,g,g,g,g,g,g,2,2,2 },\n        { g,g,g,g,g,g,g,g,g,2,2,2 },\n        { g,g,g,g,g,g,g,g,g,3,3,3 },\n        { g,g,g,g,g,g,g,g,g,3,3,3 },\n        { g,g,g,g,g,g,g,g,g,g,g,3 },\n        { g,g,g,g,g,g,g,g,g,g,g,3 },\n        { g,g,2,2,2,2,3,g,g,g,g,3 },\n        { 2,2,2,2,2,2,3,3,g,g,3,3 }\n    }", "var_name": "testArr3"}], "file": "maps4cim-core/src/test/java/de/nx42/maps4cim/util/arr2d/GapInterpolatorTest.java"}, "test_case": {"identifier": "testFullArray", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testFullArray() {\n        try {\n            GapInterpolator gip = new GapInterpolator(g);\n            float[][] result = copy(testArr3);\n            for (int y = 0; y < result.length; y++) {\n                for (int x = 0; x < result[0].length; x++) {\n                    if(result[y][x] == g) {\n                        result[y][x] = gip.star(testArr3, x, y);\n                    }\n                }\n            }\n        } catch(Exception e) {\n            fail(e.getMessage());\n        }\n    }", "signature": "void testFullArray()", "full_signature": "@Test public void testFullArray()", "class_method_signature": "GapInterpolatorTest.testFullArray()", "testcase": true, "constructor": false, "invocations": ["copy", "star", "fail", "getMessage"]}, "focal_class": {"identifier": "GapInterpolator", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected static final Interpolation igap = new Bicubic(new float[1][1]);", "modifier": "protected static final", "type": "Interpolation", "declarator": "igap = new Bicubic(new float[1][1])", "var_name": "igap"}, {"original_string": "protected static short gap;", "modifier": "protected static", "type": "short", "declarator": "gap", "var_name": "gap"}, {"original_string": "protected static final int notfound = -1;", "modifier": "protected static final", "type": "int", "declarator": "notfound = -1", "var_name": "notfound"}, {"original_string": "protected int limit = 64;", "modifier": "protected", "type": "int", "declarator": "limit = 64", "var_name": "limit"}], "methods": [{"identifier": "GapInterpolator", "parameters": "(short gap)", "modifiers": "public", "return": "", "signature": " GapInterpolator(short gap)", "full_signature": "public  GapInterpolator(short gap)", "class_method_signature": "GapInterpolator.GapInterpolator(short gap)", "testcase": false, "constructor": true}, {"identifier": "area", "parameters": "(short[][] arr, int x, int y)", "modifiers": "@Deprecated public", "return": "float", "signature": "float area(short[][] arr, int x, int y)", "full_signature": "@Deprecated public float area(short[][] arr, int x, int y)", "class_method_signature": "GapInterpolator.area(short[][] arr, int x, int y)", "testcase": false, "constructor": false}, {"identifier": "star", "parameters": "(short[][] arr, int x, int y)", "modifiers": "public", "return": "float", "signature": "float star(short[][] arr, int x, int y)", "full_signature": "public float star(short[][] arr, int x, int y)", "class_method_signature": "GapInterpolator.star(short[][] arr, int x, int y)", "testcase": false, "constructor": false}, {"identifier": "findNextValidIndex", "parameters": "(short[][] arr, Direction dir, int x, int y, int limit)", "modifiers": "protected", "return": "int", "signature": "int findNextValidIndex(short[][] arr, Direction dir, int x, int y, int limit)", "full_signature": "protected int findNextValidIndex(short[][] arr, Direction dir, int x, int y, int limit)", "class_method_signature": "GapInterpolator.findNextValidIndex(short[][] arr, Direction dir, int x, int y, int limit)", "testcase": false, "constructor": false}, {"identifier": "findNearestValidValue", "parameters": "(short[][] arr, int x, int y)", "modifiers": "protected", "return": "short", "signature": "short findNearestValidValue(short[][] arr, int x, int y)", "full_signature": "protected short findNearestValidValue(short[][] arr, int x, int y)", "class_method_signature": "GapInterpolator.findNearestValidValue(short[][] arr, int x, int y)", "testcase": false, "constructor": false}, {"identifier": "findNearestValidValue", "parameters": "(short[][] arr, int x, int y, int limit)", "modifiers": "protected", "return": "short", "signature": "short findNearestValidValue(short[][] arr, int x, int y, int limit)", "full_signature": "protected short findNearestValidValue(short[][] arr, int x, int y, int limit)", "class_method_signature": "GapInterpolator.findNearestValidValue(short[][] arr, int x, int y, int limit)", "testcase": false, "constructor": false}], "file": "maps4cim-core/src/main/java/de/nx42/maps4cim/util/arr2d/GapInterpolator.java"}, "focal_method": {"identifier": "star", "parameters": "(short[][] arr, int x, int y)", "modifiers": "public", "return": "float", "body": "public float star(short[][] arr, int x, int y) {\n\n        /*\n         * for each x and y:\n         * - get the first existing sample before and after (x1, x2, y1, y2)\n         * - calculate the relative position within these bounds (fracX, fracY)\n         * - get the remaining samples 0 and 3, so that the distance to 1 and 2\n         *   is as far as the distance between 1 and 2\n         *   * get y1, y2 for x0, x3\n         *   * get x1, x2 for y0, y3\n         *   * get x0y0, x3y0, x0y3 and x3y3 based on the found values\n         *\n         * handle special cases:\n         * - x/y1/2 out of bounds:\n         */\n\n        float[] samplesX = new float[4];\n        float[] samplesY = new float[4];\n\n        // indices of next valid samples\n        int x1 = findNextValidIndex(arr, Direction.X_MINUS, x, y, limit);\n        int x2 = findNextValidIndex(arr, Direction.X_PLUS, x, y, limit);\n        int y1 = findNextValidIndex(arr, Direction.Y_MINUS, x, y, limit);\n        int y2 = findNextValidIndex(arr, Direction.Y_PLUS, x, y, limit);\n\n        // decide whether valid indices were found for x and y\n        boolean useX = x1 >= 0;\n        boolean useY = y1 >= 0;\n\n        float interpX = 0;\n        float interpY = 0;\n\n        // calculate intepolated x value\n        if(useX) {\n            // shortest distance between valid values\n            int xWidth = x2 - x1;\n\n            // outer samples\n            int maxX = arr[0].length - 1;\n            int x0 = x1 - xWidth < 0 ? 0 : x1 - xWidth;\n            int x3 = x2 + xWidth > maxX ? maxX : x2 + xWidth;\n\n            // fill samples (get inner and calculate outer values)\n            samplesX[0] = findNearestValidValue(arr, x0, y, limit);\n            samplesX[1] = arr[y][x1];\n            samplesX[2] = arr[y][x2];\n            samplesX[3] = findNearestValidValue(arr, x3, y, limit);\n\n            // interpolate\n            float fracX = xWidth == 0 ? 0 : (x-x1) / (float) xWidth;\n            interpX = igap.interpolateSampleX(samplesX, fracX);\n        }\n\n        // calculate interpolated y value\n        if(useY) {\n            // shortest distance between valid values\n            int yWidth = y2 - y1;\n\n            // outer samples\n            int maxY = arr.length - 1;\n            int y0 = y1 - yWidth < 0 ? 0 : y1 - yWidth;\n            int y3 = y2 + yWidth > maxY ? maxY : y2 + yWidth;\n\n            // fill samples (get inner and calculate outer values)\n            samplesY[0] = findNearestValidValue(arr, x, y0, limit);\n            samplesY[1] = arr[y1][x];\n            samplesY[2] = arr[y2][x];\n            samplesY[3] = findNearestValidValue(arr, x, y3, limit);\n\n            // interpolate\n            float fracY = yWidth == 0 ? 0 : (y-y1) / (float) yWidth;\n            interpY = igap.interpolateSampleY(samplesY, fracY);\n        }\n\n        // return interpolated value\n        if(useX && useY) {\n            // return average of x and y interpolation\n            return (interpX + interpY) / 2f;\n        } else if(useX) {\n            return interpX;\n        } else if(useY) {\n            return interpY;\n        } else {\n            return 0;\n        }\n    }", "signature": "float star(short[][] arr, int x, int y)", "full_signature": "public float star(short[][] arr, int x, int y)", "class_method_signature": "GapInterpolator.star(short[][] arr, int x, int y)", "testcase": false, "constructor": false, "invocations": ["findNextValidIndex", "findNextValidIndex", "findNextValidIndex", "findNextValidIndex", "findNearestValidValue", "findNearestValidValue", "interpolateSampleX", "findNearestValidValue", "findNearestValidValue", "interpolateSampleY"]}, "repository": {"repo_id": 11799054, "url": "https://github.com/klamann/maps4cim", "language": "Java", "is_fork": false, "fork_count": 4, "stargazer_count": 18, "size": 1724, "license": "licensed"}}