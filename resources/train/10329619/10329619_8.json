{"test_class": {"identifier": "JWSTest", "superclass": "", "interfaces": "", "fields": [], "file": "jose/jws/src/test/java/org/apache/oltu/jose/jws/JWSTest.java"}, "test_case": {"identifier": "testValidate3", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testValidate3() throws InvalidKeySpecException, NoSuchAlgorithmException {\n        \n        final byte[] n = TokenDecoder.base64DecodeToByte(\"n4EPtAOCc9AlkeQHPzHStgAbgs7bTZLwUBZdR8_KuKPEHLd4rHVTeT-O-XV2jRojdNhxJWTDvNd7nqQ0VEiZQHz_AJmSCpMaJMRBSFKrKb2wqVwGU_NsYOYL-QtiWN2lbzcEe6XC0dApr5ydQLrHqkHHig3RBordaZ6Aj-oBHqFEHYpPe7Tpe-OfVfHd1E6cS6M1FZcD1NNLYD5lFHpPI9bTwJlsde3uhGqC0ZCuEHg8lhzwOHrtIQbS0FVbb9k3-tVTU4fg_3L_vniUFAKwuCLqKnS2BYwdq_mzSnbLY7h_qixoR7jig3__kRhuaxwUkRz5iaiQkqgc5gHdrNP5zw\");\n        final byte[] e =TokenDecoder.base64DecodeToByte(\"AQAB\");\n        final byte[] d = TokenDecoder.base64DecodeToByte(\"bWUC9B-EFRIo8kpGfh0ZuyGPvMNKvYWNtB_ikiH9k20eT-O1q_I78eiZkpXxXQ0UTEs2LsNRS-8uJbvQ-A1irkwMSMkK1J3XTGgdrhCku9gRldY7sNA_AKZGh-Q661_42rINLRCe8W-nZ34ui_qOfkLnK9QWDDqpaIsA-bMwWWSDFu2MUBYwkHTMEzLYGqOe04noqeq1hExBTHBOBdkMXiuFhUq1BU6l-DqEiWxqg82sXt2h-LMnT3046AOYJoRioz75tSUQfGCshWTBnP5uDjd18kKhyv07lhfSJdrPdM5Plyl21hsFf4L_mHCuoFau7gdsPfHPxxjVOcOpBrQzwQ\");\n\n        BigInteger N = new BigInteger(1, n);\n        BigInteger E = new BigInteger(1, e);\n        BigInteger D = new BigInteger(1, d);\n\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(N, E);\n        RSAPrivateKeySpec privKeySpec = new RSAPrivateKeySpec(N, D);\n        \n        String rsa256 = \"{\\\"kid\\\":\\\"bilbo.baggins@hobbiton.example\\\", \\\"alg\\\":\\\"RS256\\\"}\";\n        \n        String accessToken = \n                //header\n                TokenDecoder.base64Encode(rsa256)+\n                \".\"+\n                //payload\n                \"SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH\"+\n                \"lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk\"+\n                \"b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm\"+\n                \"UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4\"+\n                \".\"+\n                //signature\n                \"CQKOXffDcqJ490YwuiHW7JfsLNxrRXKzCYFIDZtvznxtfxUMkcvriV4y-2_UGPqqzLNF67ps3VfI_J_OYSIfeoNfawa9bDNKtoqflRyGlDSaNIJYVjvNqVSvTFwcPcUqyVACcABosJMuAd9UWPAvNkGwRuXQEU8dD4_5KTilLbogLB4-rkQnQUq29vfA3VTOw8btMimSrsx0OrUaaOB3U9b3EpWilBEpPqndHRmgL_BPktn9gfk9xSoeGybmQGXOMZrvzH3DOAb4Ga6gzZeZImcDw5O48GiO78ARk_PJ7JXj0ebYn7m0svK-meFQRUVIfcnYxOopde9QwG6rit3Nmg\";\n \n        JWS jws = new JWSReader().read(accessToken);\n        \n        SignatureMethod signatureMethod = new SignatureMethodRSAImpl(\"RS256\");\n        \n        RSAPublicKey rsaPublicKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);\n        \n        Assert.assertTrue(jws.validate(signatureMethod, new PublicKey(rsaPublicKey)));\n    }", "signature": "void testValidate3()", "full_signature": "@Test public void testValidate3()", "class_method_signature": "JWSTest.testValidate3()", "testcase": true, "constructor": false, "invocations": ["base64DecodeToByte", "base64DecodeToByte", "base64DecodeToByte", "getInstance", "base64Encode", "read", "generatePublic", "assertTrue", "validate"]}, "focal_class": {"identifier": "JWS", "superclass": "", "interfaces": "", "fields": [{"original_string": "private String rawString;", "modifier": "private", "type": "String", "declarator": "rawString", "var_name": "rawString"}, {"original_string": "private final Header header;", "modifier": "private final", "type": "Header", "declarator": "header", "var_name": "header"}, {"original_string": "private final String payload;", "modifier": "private final", "type": "String", "declarator": "payload", "var_name": "payload"}, {"original_string": "private final String signature;", "modifier": "private final", "type": "String", "declarator": "signature", "var_name": "signature"}], "methods": [{"identifier": "JWS", "parameters": "(Header header, String payload, String signature)", "modifiers": "", "return": "", "signature": " JWS(Header header, String payload, String signature)", "full_signature": "  JWS(Header header, String payload, String signature)", "class_method_signature": "JWS.JWS(Header header, String payload, String signature)", "testcase": false, "constructor": true}, {"identifier": "JWS", "parameters": "(String rawString, Header header, String payload, String signature)", "modifiers": "", "return": "", "signature": " JWS(String rawString, Header header, String payload, String signature)", "full_signature": "  JWS(String rawString, Header header, String payload, String signature)", "class_method_signature": "JWS.JWS(String rawString, Header header, String payload, String signature)", "testcase": false, "constructor": true}, {"identifier": "getHeader", "parameters": "()", "modifiers": "public", "return": "Header", "signature": "Header getHeader()", "full_signature": "public Header getHeader()", "class_method_signature": "JWS.getHeader()", "testcase": false, "constructor": false}, {"identifier": "getPayload", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getPayload()", "full_signature": "public String getPayload()", "class_method_signature": "JWS.getPayload()", "testcase": false, "constructor": false}, {"identifier": "getSignature", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getSignature()", "full_signature": "public String getSignature()", "class_method_signature": "JWS.getSignature()", "testcase": false, "constructor": false}, {"identifier": "acceptAlgorithm", "parameters": "(SignatureMethod<SK, VK> method)", "modifiers": "public", "return": "boolean", "signature": "boolean acceptAlgorithm(SignatureMethod<SK, VK> method)", "full_signature": "public boolean acceptAlgorithm(SignatureMethod<SK, VK> method)", "class_method_signature": "JWS.acceptAlgorithm(SignatureMethod<SK, VK> method)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(SignatureMethod<SK, VK> method,\n                                                                             VK verifyingKey)", "modifiers": "public", "return": "boolean", "signature": "boolean validate(SignatureMethod<SK, VK> method,\n                                                                             VK verifyingKey)", "full_signature": "public boolean validate(SignatureMethod<SK, VK> method,\n                                                                             VK verifyingKey)", "class_method_signature": "JWS.validate(SignatureMethod<SK, VK> method,\n                                                                             VK verifyingKey)", "testcase": false, "constructor": false}], "file": "jose/jws/src/main/java/org/apache/oltu/jose/jws/JWS.java"}, "focal_method": {"identifier": "validate", "parameters": "(SignatureMethod<SK, VK> method,\n                                                                             VK verifyingKey)", "modifiers": "public", "return": "boolean", "body": "public <SK extends SigningKey, VK extends VerifyingKey> boolean validate(SignatureMethod<SK, VK> method,\n                                                                             VK verifyingKey) {\n        if (!acceptAlgorithm(method)) {\n            throw new IllegalArgumentException(\"Impossible to verify current JWS signature with algorithm '\"\n                                               + method.getAlgorithm()\n                                               + \"', JWS header specifies message has been signed with '\"\n                                               + header.getAlgorithm()\n                                               + \"' algorithm.\");\n        }\n\n        if (verifyingKey == null) {\n            throw new IllegalArgumentException(\"A verifying key is required in order to verify the signature.\");\n        }\n\n        if (payload == null) {\n            throw new IllegalStateException(\"JWS token must have a payload.\");\n        }\n        if (signature == null) {\n            throw new IllegalStateException(\"JWS token must have a signature to be verified.\");\n        }\n        \n        if (rawString == null) {\n            return method.verify(signature, TokenDecoder.base64Encode(new JWSHeaderWriter().write(header)), TokenDecoder.base64Encode(payload), verifyingKey);\n        } else {\n            String jwt[] = rawString.split(\"\\\\.\");\n            return method.verify(jwt[2], jwt[0], jwt[1], verifyingKey);\n        }\n    }", "signature": "boolean validate(SignatureMethod<SK, VK> method,\n                                                                             VK verifyingKey)", "full_signature": "public boolean validate(SignatureMethod<SK, VK> method,\n                                                                             VK verifyingKey)", "class_method_signature": "JWS.validate(SignatureMethod<SK, VK> method,\n                                                                             VK verifyingKey)", "testcase": false, "constructor": false, "invocations": ["acceptAlgorithm", "getAlgorithm", "getAlgorithm", "verify", "base64Encode", "write", "base64Encode", "split", "verify"]}, "repository": {"repo_id": 10329619, "url": "https://github.com/apache/oltu", "stars": 151, "created": "5/28/2013 7:00:14 AM +00:00", "updates": "2020-01-27T09:31:03+00:00", "fork": "False", "license": "licensed"}}