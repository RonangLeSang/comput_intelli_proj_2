{"test_class": {"identifier": "MatchHostRuleTest", "superclass": "", "interfaces": "", "fields": [], "file": "auth/client/src/test/java/org/wildfly/security/auth/client/MatchHostRuleTest.java"}, "test_case": {"identifier": "testIPv6Matching", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testIPv6Matching() throws URISyntaxException {\n        // equivalent addresses should match\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"2001:db8:85a3:0:0:8a2e:370:7334\").matches(new URI(\"remote+http://[2001:db8:85a3:0:0:8a2e:370:7334]:9990\")));\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"2001:db8:85a3:0:0:8a2e:370:7334\").matches(new URI(\"remote+http://[2001:db8:85a3::8a2e:370:7334]:9990\")));\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"2001:db8:85a3::8a2e:370:7334\").matches(new URI(\"remote+http://[2001:db8:85a3:0:0:8a2e:370:7334]:9990\")));\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"2001:db8:85a3::8a2e:370:7334\").matches(new URI(\"remote+http://[2001:db8:85a3::8a2e:370:7334]:9990\")));\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"::1\").matches(new URI(\"remote+http://[::1]:9990\")));\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"::1\").matches(new URI(\"http-remoting://[0:0:0:0:0:0:0:1]:9990\")));\n\n        // IPv4 mapped IPv6 address\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"0:0:0:0:ffff:0:192.0.2.128\").matches(new URI(\"remote+http://[0:0:0:0:ffff:0:192.0.2.128]:9990\")));\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"0:0:0:0:ffff:0:192.0.2.128\").matches(new URI(\"remote+http://[::ffff:0:192.0.2.128]:9990\")));\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"::ffff:0:192.0.2.128\").matches(new URI(\"remote+http://[0:0:0:0:ffff:0:192.0.2.128]:9990\")));\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"::ffff:0:192.0.2.128\").matches(new URI(\"remote+http://[::ffff:0:192.0.2.128]:9990\")));\n\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"::ffff:0:0:0/96\").matches(new URI(\"remote+http://[::ffff:0:192.0.2.128]:9990\")));\n\n        // different case\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"::ffff:0:1\").matches(new URI(\"remote+http://[0:0:0:0:0:FFFF:0:1]:9990\")));\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"0:0:0:0:0:FFFF:0:1\").matches(new URI(\"remote+http://[::ffff:0:1]:9990\")));\n\n        // brackets in the spec\n        Assert.assertTrue(MatchRule.ALL.matchHost(\"[::1]\").matches(new URI(\"remote+http://[::1]:9990\")));\n\n        // prefix mustn't match\n        Assert.assertFalse(MatchRule.ALL.matchHost(\"2001:db8::1\").matches(new URI(\"remote+http://[2001:db8::10]:9990\")));\n    }", "signature": "void testIPv6Matching()", "full_signature": "@Test public void testIPv6Matching()", "class_method_signature": "MatchHostRuleTest.testIPv6Matching()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertTrue", "matches", "matchHost", "assertFalse", "matches", "matchHost"]}, "focal_class": {"identifier": "MatchHostRule", "superclass": "extends MatchRule", "interfaces": "", "fields": [{"original_string": "private static final Pattern validHostSpecPattern = Pattern.compile(\n        \"(\\\\*\\\\.)?([-a-z0-9_]+(?:\\\\.[-a-z0-9_]+)*)\",\n        Pattern.CASE_INSENSITIVE\n    );", "modifier": "private static final", "type": "Pattern", "declarator": "validHostSpecPattern = Pattern.compile(\n        \"(\\\\*\\\\.)?([-a-z0-9_]+(?:\\\\.[-a-z0-9_]+)*)\",\n        Pattern.CASE_INSENSITIVE\n    )", "var_name": "validHostSpecPattern"}, {"original_string": "private final boolean suffixMatch;", "modifier": "private final", "type": "boolean", "declarator": "suffixMatch", "var_name": "suffixMatch"}, {"original_string": "private final String hostSpec;", "modifier": "private final", "type": "String", "declarator": "hostSpec", "var_name": "hostSpec"}], "methods": [{"identifier": "MatchHostRule", "parameters": "(final MatchRule parent, String hostSpec)", "modifiers": "", "return": "", "signature": " MatchHostRule(final MatchRule parent, String hostSpec)", "full_signature": "  MatchHostRule(final MatchRule parent, String hostSpec)", "class_method_signature": "MatchHostRule.MatchHostRule(final MatchRule parent, String hostSpec)", "testcase": false, "constructor": true}, {"identifier": "matches", "parameters": "(final URI uri, final String abstractType, final String abstractTypeAuthority)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean matches(final URI uri, final String abstractType, final String abstractTypeAuthority)", "full_signature": "@Override public boolean matches(final URI uri, final String abstractType, final String abstractTypeAuthority)", "class_method_signature": "MatchHostRule.matches(final URI uri, final String abstractType, final String abstractTypeAuthority)", "testcase": false, "constructor": false}, {"identifier": "reparent", "parameters": "(final MatchRule newParent)", "modifiers": "@Override", "return": "MatchRule", "signature": "MatchRule reparent(final MatchRule newParent)", "full_signature": "@Override MatchRule reparent(final MatchRule newParent)", "class_method_signature": "MatchHostRule.reparent(final MatchRule newParent)", "testcase": false, "constructor": false}, {"identifier": "getMatchHost", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getMatchHost()", "full_signature": "@Override public String getMatchHost()", "class_method_signature": "MatchHostRule.getMatchHost()", "testcase": false, "constructor": false}, {"identifier": "isHostMatched", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isHostMatched()", "full_signature": "@Override public boolean isHostMatched()", "class_method_signature": "MatchHostRule.isHostMatched()", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "MatchHostRule.hashCode()", "testcase": false, "constructor": false}, {"identifier": "halfEqual", "parameters": "(final MatchRule other)", "modifiers": "@Override", "return": "boolean", "signature": "boolean halfEqual(final MatchRule other)", "full_signature": "@Override boolean halfEqual(final MatchRule other)", "class_method_signature": "MatchHostRule.halfEqual(final MatchRule other)", "testcase": false, "constructor": false}, {"identifier": "asString", "parameters": "(final StringBuilder b)", "modifiers": "@Override", "return": "StringBuilder", "signature": "StringBuilder asString(final StringBuilder b)", "full_signature": "@Override StringBuilder asString(final StringBuilder b)", "class_method_signature": "MatchHostRule.asString(final StringBuilder b)", "testcase": false, "constructor": false}], "file": "auth/client/src/main/java/org/wildfly/security/auth/client/MatchHostRule.java"}, "focal_method": {"identifier": "matches", "parameters": "(final URI uri, final String abstractType, final String abstractTypeAuthority)", "modifiers": "@Override public", "return": "boolean", "body": "@Override\n    public boolean matches(final URI uri, final String abstractType, final String abstractTypeAuthority) {\n        String host = uri.getHost();\n        if (host == null) {\n            return false;\n        }\n        final String canonHost = host.toLowerCase(Locale.ROOT);\n\n        if (suffixMatch) {\n            if (canonHost.equals(hostSpec)) {\n                return super.matches(uri, abstractType, abstractTypeAuthority);\n            }\n            if (canonHost.endsWith(hostSpec)) {\n                assert canonHost.length() > hostSpec.length(); // because otherwise it would be equal, which is tested above\n                return canonHost.codePointBefore(canonHost.length() - hostSpec.length()) == '.' && super.matches(uri, abstractType, abstractTypeAuthority);\n            }\n            return false;\n        } else {\n            return canonHost.equals(hostSpec) && super.matches(uri, abstractType, abstractTypeAuthority);\n        }\n    }", "signature": "boolean matches(final URI uri, final String abstractType, final String abstractTypeAuthority)", "full_signature": "@Override public boolean matches(final URI uri, final String abstractType, final String abstractTypeAuthority)", "class_method_signature": "MatchHostRule.matches(final URI uri, final String abstractType, final String abstractTypeAuthority)", "testcase": false, "constructor": false, "invocations": ["getHost", "toLowerCase", "equals", "matches", "endsWith", "length", "length", "codePointBefore", "length", "length", "matches", "equals", "matches"]}, "repository": {"repo_id": 13660977, "url": "https://github.com/wildfly-security/wildfly-elytron", "stars": 38, "created": "10/17/2013 8:57:07 PM +00:00", "updates": "2020-01-27T16:58:02+00:00", "fork": "False", "license": "licensed"}}