{"test_class": {"identifier": "MemcachedNodesManagerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private StorageClientCallback _mcc;", "modifier": "private", "type": "StorageClientCallback", "declarator": "_mcc", "var_name": "_mcc"}], "file": "core/src/test/java/de/javakaffee/web/msm/MemcachedNodesManagerTest.java"}, "test_case": {"identifier": "testCouchbaseNodesAndFailoverNodeShouldThrowException", "parameters": "()", "modifiers": "@Test(expectedExceptions = IllegalArgumentException.class) public", "return": "void", "body": "@Test(expectedExceptions = IllegalArgumentException.class)\n    public void testCouchbaseNodesAndFailoverNodeShouldThrowException() {\n        createFor(\"http://localhost:8091/pools\", \"n1\", null, _mcc);\n    }", "signature": "void testCouchbaseNodesAndFailoverNodeShouldThrowException()", "full_signature": "@Test(expectedExceptions = IllegalArgumentException.class) public void testCouchbaseNodesAndFailoverNodeShouldThrowException()", "class_method_signature": "MemcachedNodesManagerTest.testCouchbaseNodesAndFailoverNodeShouldThrowException()", "testcase": true, "constructor": false, "invocations": ["createFor"]}, "focal_class": {"identifier": "MemcachedNodesManager", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Log LOG = LogFactory.getLog(MemcachedNodesManager.class);", "modifier": "private static final", "type": "Log", "declarator": "LOG = LogFactory.getLog(MemcachedNodesManager.class)", "var_name": "LOG"}, {"original_string": "private static final String NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\";", "modifier": "private static final", "type": "String", "declarator": "NODE_REGEX = \"([\\\\w]+):([^:]+):([\\\\d]+)\"", "var_name": "NODE_REGEX"}, {"original_string": "private static final Pattern NODE_PATTERN = Pattern.compile( NODE_REGEX );", "modifier": "private static final", "type": "Pattern", "declarator": "NODE_PATTERN = Pattern.compile( NODE_REGEX )", "var_name": "NODE_PATTERN"}, {"original_string": "private static final String NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\";", "modifier": "private static final", "type": "String", "declarator": "NODES_REGEX = NODE_REGEX + \"(?:(?:\\\\s+|,)\" + NODE_REGEX + \")*\"", "var_name": "NODES_REGEX"}, {"original_string": "private static final Pattern NODES_PATTERN = Pattern.compile( NODES_REGEX );", "modifier": "private static final", "type": "Pattern", "declarator": "NODES_PATTERN = Pattern.compile( NODES_REGEX )", "var_name": "NODES_PATTERN"}, {"original_string": "private static final String SINGLE_NODE_REGEX = \"([^:]+):([\\\\d]+)\";", "modifier": "private static final", "type": "String", "declarator": "SINGLE_NODE_REGEX = \"([^:]+):([\\\\d]+)\"", "var_name": "SINGLE_NODE_REGEX"}, {"original_string": "private static final Pattern SINGLE_NODE_PATTERN = Pattern.compile( SINGLE_NODE_REGEX );", "modifier": "private static final", "type": "Pattern", "declarator": "SINGLE_NODE_PATTERN = Pattern.compile( SINGLE_NODE_REGEX )", "var_name": "SINGLE_NODE_PATTERN"}, {"original_string": "private static final String COUCHBASE_BUCKET_NODE_REGEX = \"http://([^:]+):([\\\\d]+)/[\\\\w]+\";", "modifier": "private static final", "type": "String", "declarator": "COUCHBASE_BUCKET_NODE_REGEX = \"http://([^:]+):([\\\\d]+)/[\\\\w]+\"", "var_name": "COUCHBASE_BUCKET_NODE_REGEX"}, {"original_string": "private static final Pattern COUCHBASE_BUCKET_NODE_PATTERN = Pattern.compile( COUCHBASE_BUCKET_NODE_REGEX );", "modifier": "private static final", "type": "Pattern", "declarator": "COUCHBASE_BUCKET_NODE_PATTERN = Pattern.compile( COUCHBASE_BUCKET_NODE_REGEX )", "var_name": "COUCHBASE_BUCKET_NODE_PATTERN"}, {"original_string": "private static final String COUCHBASE_BUCKET_NODES_REGEX = COUCHBASE_BUCKET_NODE_REGEX + \"(?:(?:\\\\s+|,)\" + COUCHBASE_BUCKET_NODE_REGEX + \")*\";", "modifier": "private static final", "type": "String", "declarator": "COUCHBASE_BUCKET_NODES_REGEX = COUCHBASE_BUCKET_NODE_REGEX + \"(?:(?:\\\\s+|,)\" + COUCHBASE_BUCKET_NODE_REGEX + \")*\"", "var_name": "COUCHBASE_BUCKET_NODES_REGEX"}, {"original_string": "private static final Pattern COUCHBASE_BUCKET_NODES_PATTERN = Pattern.compile( COUCHBASE_BUCKET_NODES_REGEX );", "modifier": "private static final", "type": "Pattern", "declarator": "COUCHBASE_BUCKET_NODES_PATTERN = Pattern.compile( COUCHBASE_BUCKET_NODES_REGEX )", "var_name": "COUCHBASE_BUCKET_NODES_PATTERN"}, {"original_string": "private static final int NODE_AVAILABILITY_CACHE_TTL = getSystemProperty(NODE_AVAILABILITY_CACHE_TTL_KEY, 1000);", "modifier": "private static final", "type": "int", "declarator": "NODE_AVAILABILITY_CACHE_TTL = getSystemProperty(NODE_AVAILABILITY_CACHE_TTL_KEY, 1000)", "var_name": "NODE_AVAILABILITY_CACHE_TTL"}, {"original_string": "private final String _memcachedNodes;", "modifier": "private final", "type": "String", "declarator": "_memcachedNodes", "var_name": "_memcachedNodes"}, {"original_string": "private final NodeIdList _primaryNodeIds;", "modifier": "private final", "type": "NodeIdList", "declarator": "_primaryNodeIds", "var_name": "_primaryNodeIds"}, {"original_string": "private final List<String> _failoverNodeIds;", "modifier": "private final", "type": "List<String>", "declarator": "_failoverNodeIds", "var_name": "_failoverNodeIds"}, {"original_string": "private final LinkedHashMap<InetSocketAddress, String> _address2Ids;", "modifier": "private final", "type": "LinkedHashMap<InetSocketAddress, String>", "declarator": "_address2Ids", "var_name": "_address2Ids"}, {"original_string": "private final boolean _encodeNodeIdInSessionId;", "modifier": "private final", "type": "boolean", "declarator": "_encodeNodeIdInSessionId", "var_name": "_encodeNodeIdInSessionId"}, {"original_string": "private final StorageKeyFormat _storageKeyFormat;", "modifier": "private final", "type": "StorageKeyFormat", "declarator": "_storageKeyFormat", "var_name": "_storageKeyFormat"}, {"original_string": "@Nullable\n\tprivate NodeIdService _nodeIdService;", "modifier": "@Nullable\n\tprivate", "type": "NodeIdService", "declarator": "_nodeIdService", "var_name": "_nodeIdService"}, {"original_string": "private SessionIdFormat _sessionIdFormat;", "modifier": "private", "type": "SessionIdFormat", "declarator": "_sessionIdFormat", "var_name": "_sessionIdFormat"}], "methods": [{"identifier": "MemcachedNodesManager", "parameters": "(final String memcachedNodes, @Nonnull final NodeIdList primaryNodeIds, @Nonnull final List<String> failoverNodeIds,\n\t\t\t@Nonnull final LinkedHashMap<InetSocketAddress, String> address2Ids,\n\t\t\t@Nullable final StorageKeyFormat storageKeyFormat, @Nullable final StorageClientCallback storageClientCallback)", "modifiers": "public", "return": "", "signature": " MemcachedNodesManager(final String memcachedNodes, @Nonnull final NodeIdList primaryNodeIds, @Nonnull final List<String> failoverNodeIds,\n\t\t\t@Nonnull final LinkedHashMap<InetSocketAddress, String> address2Ids,\n\t\t\t@Nullable final StorageKeyFormat storageKeyFormat, @Nullable final StorageClientCallback storageClientCallback)", "full_signature": "public  MemcachedNodesManager(final String memcachedNodes, @Nonnull final NodeIdList primaryNodeIds, @Nonnull final List<String> failoverNodeIds,\n\t\t\t@Nonnull final LinkedHashMap<InetSocketAddress, String> address2Ids,\n\t\t\t@Nullable final StorageKeyFormat storageKeyFormat, @Nullable final StorageClientCallback storageClientCallback)", "class_method_signature": "MemcachedNodesManager.MemcachedNodesManager(final String memcachedNodes, @Nonnull final NodeIdList primaryNodeIds, @Nonnull final List<String> failoverNodeIds,\n\t\t\t@Nonnull final LinkedHashMap<InetSocketAddress, String> address2Ids,\n\t\t\t@Nullable final StorageKeyFormat storageKeyFormat, @Nullable final StorageClientCallback storageClientCallback)", "testcase": false, "constructor": true}, {"identifier": "isCouchbaseConfig", "parameters": "(final String memcachedNodes)", "modifiers": "private", "return": "boolean", "signature": "boolean isCouchbaseConfig(final String memcachedNodes)", "full_signature": "private boolean isCouchbaseConfig(final String memcachedNodes)", "class_method_signature": "MemcachedNodesManager.isCouchbaseConfig(final String memcachedNodes)", "testcase": false, "constructor": false}, {"identifier": "createNodeAvailabilityCache", "parameters": "( final int size, final long ttlInMillis,\n            @Nonnull final StorageClientCallback storageClientCallback)", "modifiers": "protected", "return": "NodeAvailabilityCache<String>", "signature": "NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            @Nonnull final StorageClientCallback storageClientCallback)", "full_signature": "protected NodeAvailabilityCache<String> createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            @Nonnull final StorageClientCallback storageClientCallback)", "class_method_signature": "MemcachedNodesManager.createNodeAvailabilityCache( final int size, final long ttlInMillis,\n            @Nonnull final StorageClientCallback storageClientCallback)", "testcase": false, "constructor": false}, {"identifier": "createFor", "parameters": "(final String memcachedNodes, final String failoverNodes, final StorageKeyFormat storageKeyFormat,\n            final StorageClientCallback storageClientCallback)", "modifiers": "@Nonnull public static", "return": "MemcachedNodesManager", "signature": "MemcachedNodesManager createFor(final String memcachedNodes, final String failoverNodes, final StorageKeyFormat storageKeyFormat,\n            final StorageClientCallback storageClientCallback)", "full_signature": "@Nonnull public static MemcachedNodesManager createFor(final String memcachedNodes, final String failoverNodes, final StorageKeyFormat storageKeyFormat,\n            final StorageClientCallback storageClientCallback)", "class_method_signature": "MemcachedNodesManager.createFor(final String memcachedNodes, final String failoverNodes, final StorageKeyFormat storageKeyFormat,\n            final StorageClientCallback storageClientCallback)", "testcase": false, "constructor": false}, {"identifier": "getSingleShortNodeDefinition", "parameters": "(final Matcher singleNodeMatcher)", "modifiers": "private static", "return": "InetSocketAddress", "signature": "InetSocketAddress getSingleShortNodeDefinition(final Matcher singleNodeMatcher)", "full_signature": "private static InetSocketAddress getSingleShortNodeDefinition(final Matcher singleNodeMatcher)", "class_method_signature": "MemcachedNodesManager.getSingleShortNodeDefinition(final Matcher singleNodeMatcher)", "testcase": false, "constructor": false}, {"identifier": "getRegularNodeDefinition", "parameters": "(final Matcher matcher)", "modifiers": "private static", "return": "Pair<String, InetSocketAddress>", "signature": "Pair<String, InetSocketAddress> getRegularNodeDefinition(final Matcher matcher)", "full_signature": "private static Pair<String, InetSocketAddress> getRegularNodeDefinition(final Matcher matcher)", "class_method_signature": "MemcachedNodesManager.getRegularNodeDefinition(final Matcher matcher)", "testcase": false, "constructor": false}, {"identifier": "initFailoverNodes", "parameters": "(final String failoverNodes, final Collection<String> allNodeIds)", "modifiers": "private static", "return": "List<String>", "signature": "List<String> initFailoverNodes(final String failoverNodes, final Collection<String> allNodeIds)", "full_signature": "private static List<String> initFailoverNodes(final String failoverNodes, final Collection<String> allNodeIds)", "class_method_signature": "MemcachedNodesManager.initFailoverNodes(final String failoverNodes, final Collection<String> allNodeIds)", "testcase": false, "constructor": false}, {"identifier": "getMemcachedNodes", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getMemcachedNodes()", "full_signature": "public String getMemcachedNodes()", "class_method_signature": "MemcachedNodesManager.getMemcachedNodes()", "testcase": false, "constructor": false}, {"identifier": "getCountNodes", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getCountNodes()", "full_signature": "public int getCountNodes()", "class_method_signature": "MemcachedNodesManager.getCountNodes()", "testcase": false, "constructor": false}, {"identifier": "getPrimaryNodeIds", "parameters": "()", "modifiers": "@Nonnull public", "return": "NodeIdList", "signature": "NodeIdList getPrimaryNodeIds()", "full_signature": "@Nonnull public NodeIdList getPrimaryNodeIds()", "class_method_signature": "MemcachedNodesManager.getPrimaryNodeIds()", "testcase": false, "constructor": false}, {"identifier": "getFailoverNodeIds", "parameters": "()", "modifiers": "@Nonnull public", "return": "List<String>", "signature": "List<String> getFailoverNodeIds()", "full_signature": "@Nonnull public List<String> getFailoverNodeIds()", "class_method_signature": "MemcachedNodesManager.getFailoverNodeIds()", "testcase": false, "constructor": false}, {"identifier": "isEncodeNodeIdInSessionId", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isEncodeNodeIdInSessionId()", "full_signature": "public boolean isEncodeNodeIdInSessionId()", "class_method_signature": "MemcachedNodesManager.isEncodeNodeIdInSessionId()", "testcase": false, "constructor": false}, {"identifier": "getNodeId", "parameters": "(final InetSocketAddress socketAddress)", "modifiers": "@Nonnull public", "return": "String", "signature": "String getNodeId(final InetSocketAddress socketAddress)", "full_signature": "@Nonnull public String getNodeId(final InetSocketAddress socketAddress)", "class_method_signature": "MemcachedNodesManager.getNodeId(final InetSocketAddress socketAddress)", "testcase": false, "constructor": false}, {"identifier": "getNextPrimaryNodeId", "parameters": "(final String nodeId)", "modifiers": "@CheckForNull public", "return": "String", "signature": "String getNextPrimaryNodeId(final String nodeId)", "full_signature": "@CheckForNull public String getNextPrimaryNodeId(final String nodeId)", "class_method_signature": "MemcachedNodesManager.getNextPrimaryNodeId(final String nodeId)", "testcase": false, "constructor": false}, {"identifier": "getNextAvailableNodeId", "parameters": "(final String nodeId)", "modifiers": "public", "return": "String", "signature": "String getNextAvailableNodeId(final String nodeId)", "full_signature": "public String getNextAvailableNodeId(final String nodeId)", "class_method_signature": "MemcachedNodesManager.getNextAvailableNodeId(final String nodeId)", "testcase": false, "constructor": false}, {"identifier": "getSessionIdFormat", "parameters": "()", "modifiers": "@Nonnull public", "return": "SessionIdFormat", "signature": "SessionIdFormat getSessionIdFormat()", "full_signature": "@Nonnull public SessionIdFormat getSessionIdFormat()", "class_method_signature": "MemcachedNodesManager.getSessionIdFormat()", "testcase": false, "constructor": false}, {"identifier": "getStorageKeyFormat", "parameters": "()", "modifiers": "@Nonnull public", "return": "StorageKeyFormat", "signature": "StorageKeyFormat getStorageKeyFormat()", "full_signature": "@Nonnull public StorageKeyFormat getStorageKeyFormat()", "class_method_signature": "MemcachedNodesManager.getStorageKeyFormat()", "testcase": false, "constructor": false}, {"identifier": "getAllMemcachedAddresses", "parameters": "()", "modifiers": "@Nonnull public", "return": "List<InetSocketAddress>", "signature": "List<InetSocketAddress> getAllMemcachedAddresses()", "full_signature": "@Nonnull public List<InetSocketAddress> getAllMemcachedAddresses()", "class_method_signature": "MemcachedNodesManager.getAllMemcachedAddresses()", "testcase": false, "constructor": false}, {"identifier": "createSessionId", "parameters": "( @Nonnull final String sessionId )", "modifiers": "@Nonnull public", "return": "String", "signature": "String createSessionId( @Nonnull final String sessionId )", "full_signature": "@Nonnull public String createSessionId( @Nonnull final String sessionId )", "class_method_signature": "MemcachedNodesManager.createSessionId( @Nonnull final String sessionId )", "testcase": false, "constructor": false}, {"identifier": "setNodeAvailable", "parameters": "(@Nullable final String nodeId, final boolean available)", "modifiers": "public", "return": "void", "signature": "void setNodeAvailable(@Nullable final String nodeId, final boolean available)", "full_signature": "public void setNodeAvailable(@Nullable final String nodeId, final boolean available)", "class_method_signature": "MemcachedNodesManager.setNodeAvailable(@Nullable final String nodeId, final boolean available)", "testcase": false, "constructor": false}, {"identifier": "isNodeAvailable", "parameters": "(final String nodeId)", "modifiers": "public", "return": "boolean", "signature": "boolean isNodeAvailable(final String nodeId)", "full_signature": "public boolean isNodeAvailable(final String nodeId)", "class_method_signature": "MemcachedNodesManager.isNodeAvailable(final String nodeId)", "testcase": false, "constructor": false}, {"identifier": "isValidForMemcached", "parameters": "(final String sessionId)", "modifiers": "public", "return": "boolean", "signature": "boolean isValidForMemcached(final String sessionId)", "full_signature": "public boolean isValidForMemcached(final String sessionId)", "class_method_signature": "MemcachedNodesManager.isValidForMemcached(final String sessionId)", "testcase": false, "constructor": false}, {"identifier": "canHitMemcached", "parameters": "(final String sessionId)", "modifiers": "public", "return": "boolean", "signature": "boolean canHitMemcached(final String sessionId)", "full_signature": "public boolean canHitMemcached(final String sessionId)", "class_method_signature": "MemcachedNodesManager.canHitMemcached(final String sessionId)", "testcase": false, "constructor": false}, {"identifier": "onLoadFromMemcachedSuccess", "parameters": "(final String sessionId)", "modifiers": "public", "return": "void", "signature": "void onLoadFromMemcachedSuccess(final String sessionId)", "full_signature": "public void onLoadFromMemcachedSuccess(final String sessionId)", "class_method_signature": "MemcachedNodesManager.onLoadFromMemcachedSuccess(final String sessionId)", "testcase": false, "constructor": false}, {"identifier": "onLoadFromMemcachedFailure", "parameters": "(final String sessionId)", "modifiers": "public", "return": "void", "signature": "void onLoadFromMemcachedFailure(final String sessionId)", "full_signature": "public void onLoadFromMemcachedFailure(final String sessionId)", "class_method_signature": "MemcachedNodesManager.onLoadFromMemcachedFailure(final String sessionId)", "testcase": false, "constructor": false}, {"identifier": "setNodeAvailableForSessionId", "parameters": "(final String sessionId, final boolean available)", "modifiers": "public", "return": "String", "signature": "String setNodeAvailableForSessionId(final String sessionId, final boolean available)", "full_signature": "public String setNodeAvailableForSessionId(final String sessionId, final boolean available)", "class_method_signature": "MemcachedNodesManager.setNodeAvailableForSessionId(final String sessionId, final boolean available)", "testcase": false, "constructor": false}, {"identifier": "getNewSessionIdIfNodeFromSessionIdUnavailable", "parameters": "( @Nonnull final String sessionId )", "modifiers": "public", "return": "String", "signature": "String getNewSessionIdIfNodeFromSessionIdUnavailable( @Nonnull final String sessionId )", "full_signature": "public String getNewSessionIdIfNodeFromSessionIdUnavailable( @Nonnull final String sessionId )", "class_method_signature": "MemcachedNodesManager.getNewSessionIdIfNodeFromSessionIdUnavailable( @Nonnull final String sessionId )", "testcase": false, "constructor": false}, {"identifier": "changeSessionIdForTomcatFailover", "parameters": "( @Nonnull final String sessionId, final String jvmRoute )", "modifiers": "public", "return": "String", "signature": "String changeSessionIdForTomcatFailover( @Nonnull final String sessionId, final String jvmRoute )", "full_signature": "public String changeSessionIdForTomcatFailover( @Nonnull final String sessionId, final String jvmRoute )", "class_method_signature": "MemcachedNodesManager.changeSessionIdForTomcatFailover( @Nonnull final String sessionId, final String jvmRoute )", "testcase": false, "constructor": false}, {"identifier": "isCouchbaseBucketConfig", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isCouchbaseBucketConfig()", "full_signature": "public boolean isCouchbaseBucketConfig()", "class_method_signature": "MemcachedNodesManager.isCouchbaseBucketConfig()", "testcase": false, "constructor": false}, {"identifier": "isRedisConfig", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isRedisConfig()", "full_signature": "public boolean isRedisConfig()", "class_method_signature": "MemcachedNodesManager.isRedisConfig()", "testcase": false, "constructor": false}, {"identifier": "getCouchbaseBucketURIs", "parameters": "()", "modifiers": "public", "return": "List<URI>", "signature": "List<URI> getCouchbaseBucketURIs()", "full_signature": "public List<URI> getCouchbaseBucketURIs()", "class_method_signature": "MemcachedNodesManager.getCouchbaseBucketURIs()", "testcase": false, "constructor": false}], "file": "core/src/main/java/de/javakaffee/web/msm/MemcachedNodesManager.java"}, "focal_method": {"identifier": "createFor", "parameters": "(final String memcachedNodes, final String failoverNodes, final StorageKeyFormat storageKeyFormat,\n            final StorageClientCallback storageClientCallback)", "modifiers": "@Nonnull public static", "return": "MemcachedNodesManager", "body": "@Nonnull\n    public static MemcachedNodesManager createFor(final String memcachedNodes, final String failoverNodes, final StorageKeyFormat storageKeyFormat,\n            final StorageClientCallback storageClientCallback) {\n\t\tif ( memcachedNodes == null || memcachedNodes.trim().isEmpty() ) {\n\t\t\tthrow new IllegalArgumentException(\"null or empty memcachedNodes not allowed.\");\n\t\t}\n\t\t\n        // Support a Redis URL in the form \"redis://hostname:port\" or \"rediss://\" (for SSL connections) like the client \"Lettuce\" does\n\t\tif (memcachedNodes.startsWith(\"redis://\") || memcachedNodes.startsWith(\"rediss://\")) {\n\t\t    // Redis configuration\n\t\t    return new MemcachedNodesManager(memcachedNodes, new NodeIdList(), new ArrayList<String>(),\n\t\t            new LinkedHashMap<InetSocketAddress, String>(), storageKeyFormat, storageClientCallback);\n\t\t}\n\n        if ( !NODES_PATTERN.matcher( memcachedNodes ).matches() && !SINGLE_NODE_PATTERN.matcher(memcachedNodes).matches()\n        \t\t&& !COUCHBASE_BUCKET_NODES_PATTERN.matcher(memcachedNodes).matches()) {\n            throw new IllegalArgumentException( \"Configured memcachedNodes attribute has wrong format, must match \" + NODES_REGEX );\n        }\n\n        final Matcher singleNodeMatcher = SINGLE_NODE_PATTERN.matcher(memcachedNodes);\n\n        // we have a linked hashmap to have insertion order for addresses\n        final LinkedHashMap<InetSocketAddress, String> address2Ids = new LinkedHashMap<InetSocketAddress, String>(1);\n\n        /**\n         * If mutliple nodes are configured\n         */\n        if (singleNodeMatcher.matches()) {    // for single\n            address2Ids.put(getSingleShortNodeDefinition(singleNodeMatcher), null);\n        }\n        else if (COUCHBASE_BUCKET_NODES_PATTERN.matcher(memcachedNodes).matches()) {    // for couchbase\n            final Matcher matcher = COUCHBASE_BUCKET_NODE_PATTERN.matcher(memcachedNodes);\n            while (matcher.find()) {\n                final String hostname = matcher.group( 1 );\n                final int port = Integer.parseInt( matcher.group( 2 ) );\n                address2Ids.put(new InetSocketAddress( hostname, port ), null);\n            }\n            if (address2Ids.isEmpty()) {\n                throw new IllegalArgumentException(\"All nodes are also configured as failover nodes,\"\n                        + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\");\n            }\n        }\n        else { // If mutliple nodes are configured\n            final Matcher matcher = NODE_PATTERN.matcher( memcachedNodes);\n            while (matcher.find()) {\n                final Pair<String, InetSocketAddress> nodeInfo = getRegularNodeDefinition(matcher);\n                address2Ids.put(nodeInfo.getSecond(), nodeInfo.getFirst());\n            }\n            if (address2Ids.isEmpty()) {\n                throw new IllegalArgumentException(\"All nodes are also configured as failover nodes,\"\n                        + \" this is a configuration failure. In this case, you probably want to leave out the failoverNodes.\");\n            }\n        }\n\n        final List<String> failoverNodeIds = initFailoverNodes(failoverNodes, address2Ids.values());\n\n        // validate that for a single node there's no failover node specified as this does not make sense.\n        if(address2Ids.size() == 1 && failoverNodeIds.size() >= 1) {\n        \tthrow new IllegalArgumentException(\"For a single memcached node there should/must no failoverNodes be specified.\");\n        }\n\n        final NodeIdList primaryNodeIds = new NodeIdList();\n        for(final Map.Entry<InetSocketAddress, String> address2Id : address2Ids.entrySet()) {\n\t        final String nodeId = address2Id.getValue();\n\t\t\tif (nodeId != null && !failoverNodeIds.contains(nodeId) ) {\n\t        \tprimaryNodeIds.add(nodeId);\n\t        }\n        }\n\n        return new MemcachedNodesManager(memcachedNodes, primaryNodeIds, failoverNodeIds, address2Ids, storageKeyFormat, storageClientCallback);\n\t}", "signature": "MemcachedNodesManager createFor(final String memcachedNodes, final String failoverNodes, final StorageKeyFormat storageKeyFormat,\n            final StorageClientCallback storageClientCallback)", "full_signature": "@Nonnull public static MemcachedNodesManager createFor(final String memcachedNodes, final String failoverNodes, final StorageKeyFormat storageKeyFormat,\n            final StorageClientCallback storageClientCallback)", "class_method_signature": "MemcachedNodesManager.createFor(final String memcachedNodes, final String failoverNodes, final StorageKeyFormat storageKeyFormat,\n            final StorageClientCallback storageClientCallback)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "trim", "startsWith", "startsWith", "matches", "matcher", "matches", "matcher", "matches", "matcher", "matcher", "matches", "put", "getSingleShortNodeDefinition", "matches", "matcher", "matcher", "find", "group", "parseInt", "group", "put", "isEmpty", "matcher", "find", "getRegularNodeDefinition", "put", "getSecond", "getFirst", "isEmpty", "initFailoverNodes", "values", "size", "size", "entrySet", "getValue", "contains", "add"]}, "repository": {"repo_id": 152812, "url": "https://github.com/magro/memcached-session-manager", "language": "Java", "is_fork": false, "fork_count": 352, "stargazer_count": 743, "size": 5794, "license": "licensed"}}