{"test_class": {"identifier": "NovaErrorHandlerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private HttpCommand command;", "modifier": "private", "type": "HttpCommand", "declarator": "command", "var_name": "command"}, {"original_string": "HttpResponse noFixedIps = HttpResponse.builder().statusCode(400)\n         .message(\"HTTP/1.1 400 Bad Request\")\n         .payload(\"{\\\"badRequest\\\": {\\\"message\\\": \"+\n                  \"\\\"instance |71554| has no fixed_ips. unable to associate floating ip\\\", \\\"code\\\": 400}}\")\n         .build();", "modifier": "", "type": "HttpResponse", "declarator": "noFixedIps = HttpResponse.builder().statusCode(400)\n         .message(\"HTTP/1.1 400 Bad Request\")\n         .payload(\"{\\\"badRequest\\\": {\\\"message\\\": \"+\n                  \"\\\"instance |71554| has no fixed_ips. unable to associate floating ip\\\", \\\"code\\\": 400}}\")\n         .build()", "var_name": "noFixedIps"}, {"original_string": "HttpResponse alreadyExists = HttpResponse.builder().statusCode(400)\n         .message(\"HTTP/1.1 400 Bad Request\")\n         .payload(\"{\\\"badRequest\\\": {\\\"message\\\": \\\"Server with the name 'test' already exists\\\", \\\"code\\\": 400}}\")\n         .build();", "modifier": "", "type": "HttpResponse", "declarator": "alreadyExists = HttpResponse.builder().statusCode(400)\n         .message(\"HTTP/1.1 400 Bad Request\")\n         .payload(\"{\\\"badRequest\\\": {\\\"message\\\": \\\"Server with the name 'test' already exists\\\", \\\"code\\\": 400}}\")\n         .build()", "var_name": "alreadyExists"}, {"original_string": "HttpResponse quotaExceeded = HttpResponse.builder().statusCode(400)\n         .message(\"HTTP/1.1 400 Bad Request\")\n         .payload(\"{\\\"badRequest\\\": {\\\"message\\\": \\\"AddressLimitExceeded: Address quota exceeded. \" +\n                  \"You cannot create any more addresses\\\", \\\"code\\\": 400}}\")\n         .build();", "modifier": "", "type": "HttpResponse", "declarator": "quotaExceeded = HttpResponse.builder().statusCode(400)\n         .message(\"HTTP/1.1 400 Bad Request\")\n         .payload(\"{\\\"badRequest\\\": {\\\"message\\\": \\\"AddressLimitExceeded: Address quota exceeded. \" +\n                  \"You cannot create any more addresses\\\", \\\"code\\\": 400}}\")\n         .build()", "var_name": "quotaExceeded"}, {"original_string": "HttpResponse tooLarge = HttpResponse.builder().statusCode(413)\n         .message(\"HTTP/1.1 413 Request Entity Too Large\")\n         .payload(\"{\\\"badRequest\\\": {\\\"message\\\": \\\"Volume quota exceeded. You cannot create a volume of size 1G\\\", \" +\n                  \"\\\"code\\\": 413, \\\"retryAfter\\\": 0}}\")\n         .build();", "modifier": "", "type": "HttpResponse", "declarator": "tooLarge = HttpResponse.builder().statusCode(413)\n         .message(\"HTTP/1.1 413 Request Entity Too Large\")\n         .payload(\"{\\\"badRequest\\\": {\\\"message\\\": \\\"Volume quota exceeded. You cannot create a volume of size 1G\\\", \" +\n                  \"\\\"code\\\": 413, \\\"retryAfter\\\": 0}}\")\n         .build()", "var_name": "tooLarge"}, {"original_string": "HttpResponse retryAt = HttpResponse.builder().statusCode(413)\n         .message(\"HTTP/1.1 413 Request Entity Too Large\")\n         .payload(\"{ 'overLimit' : { 'code' : 413,\"\n                 + \" 'message' : 'OverLimit Retry...', \" \n                 + \" 'details' : 'Error Details...',\"\n                 + \" 'retryAt' : '2012-11-14T21:51:28UTC' }}\")\n         .build();", "modifier": "", "type": "HttpResponse", "declarator": "retryAt = HttpResponse.builder().statusCode(413)\n         .message(\"HTTP/1.1 413 Request Entity Too Large\")\n         .payload(\"{ 'overLimit' : { 'code' : 413,\"\n                 + \" 'message' : 'OverLimit Retry...', \" \n                 + \" 'details' : 'Error Details...',\"\n                 + \" 'retryAt' : '2012-11-14T21:51:28UTC' }}\")\n         .build()", "var_name": "retryAt"}, {"original_string": "HttpResponse retryAfter = HttpResponse.builder().statusCode(413)\n         .message(\"HTTP/1.1 413 Request Entity Too Large\")\n         .payload(\"{ 'overLimit': { 'message': 'This request was rate-limited.', \"\n                 + \" 'retryAfter': '54', \"\n                 + \" 'details': 'Only 1 POST request(s) can be made to \\\\'*\\\\' every minute.'\" + \" }}\")\n         .build();", "modifier": "", "type": "HttpResponse", "declarator": "retryAfter = HttpResponse.builder().statusCode(413)\n         .message(\"HTTP/1.1 413 Request Entity Too Large\")\n         .payload(\"{ 'overLimit': { 'message': 'This request was rate-limited.', \"\n                 + \" 'retryAfter': '54', \"\n                 + \" 'details': 'Only 1 POST request(s) can be made to \\\\'*\\\\' every minute.'\" + \" }}\")\n         .build()", "var_name": "retryAfter"}, {"original_string": "HttpResponse retryAfterTrumps = HttpResponse.builder().statusCode(413)\n         .message(\"HTTP/1.1 413 Request Entity Too Large\")\n         .payload(\"{ 'overLimit': {\"\n                 + \" 'message': 'This request was rate-limited.', \" \n                 + \" 'retryAfter': '54', \"\n                 + \" 'retryAt' : '2012-11-14T21:51:28UTC',\"\n                 + \" 'details': 'Only 1 POST request(s) can be made to \\\\'*\\\\' every minute.' }}\")\n         .build();", "modifier": "", "type": "HttpResponse", "declarator": "retryAfterTrumps = HttpResponse.builder().statusCode(413)\n         .message(\"HTTP/1.1 413 Request Entity Too Large\")\n         .payload(\"{ 'overLimit': {\"\n                 + \" 'message': 'This request was rate-limited.', \" \n                 + \" 'retryAfter': '54', \"\n                 + \" 'retryAt' : '2012-11-14T21:51:28UTC',\"\n                 + \" 'details': 'Only 1 POST request(s) can be made to \\\\'*\\\\' every minute.' }}\")\n         .build()", "var_name": "retryAfterTrumps"}, {"original_string": "HttpResponse badRetryAt = HttpResponse.builder().statusCode(413)\n         .message(\"HTTP/1.1 413 Request Entity Too Large\")\n         .payload(\"{ 'overLimit' : { 'code' : 413,\"\n                 + \" 'message' : 'OverLimit Retry...', \" \n                 + \" 'details' : 'Error Details...',\"\n                 + \" 'retryAt' : '2012-11-~~~:51:28UTC' }}\")\n         .build();", "modifier": "", "type": "HttpResponse", "declarator": "badRetryAt = HttpResponse.builder().statusCode(413)\n         .message(\"HTTP/1.1 413 Request Entity Too Large\")\n         .payload(\"{ 'overLimit' : { 'code' : 413,\"\n                 + \" 'message' : 'OverLimit Retry...', \" \n                 + \" 'details' : 'Error Details...',\"\n                 + \" 'retryAt' : '2012-11-~~~:51:28UTC' }}\")\n         .build()", "var_name": "badRetryAt"}, {"original_string": "DateCodec iso8601Seconds = new DateServiceIso8601SecondsCodec(new SimpleDateFormatDateService());", "modifier": "", "type": "DateCodec", "declarator": "iso8601Seconds = new DateServiceIso8601SecondsCodec(new SimpleDateFormatDateService())", "var_name": "iso8601Seconds"}, {"original_string": "Ticker y2k = new Ticker(){\n\n      @Override\n      public long read() {\n         return TimeUnit.MILLISECONDS.toNanos(iso8601Seconds.toDate(\"2012-11-14T20:51:28UTC\").getTime());\n      }\n      \n   };", "modifier": "", "type": "Ticker", "declarator": "y2k = new Ticker(){\n\n      @Override\n      public long read() {\n         return TimeUnit.MILLISECONDS.toNanos(iso8601Seconds.toDate(\"2012-11-14T20:51:28UTC\").getTime());\n      }\n      \n   }", "var_name": "y2k"}, {"original_string": "NovaErrorHandler fn = new NovaErrorHandler(HeaderToRetryAfterException.create(y2k, iso8601Seconds),\n         new OverLimitParser(new GsonWrapper(new Gson())));", "modifier": "", "type": "NovaErrorHandler", "declarator": "fn = new NovaErrorHandler(HeaderToRetryAfterException.create(y2k, iso8601Seconds),\n         new OverLimitParser(new GsonWrapper(new Gson())))", "var_name": "fn"}], "file": "apis/openstack-nova/src/test/java/org/jclouds/openstack/nova/v2_0/handlers/NovaErrorHandlerTest.java"}, "test_case": {"identifier": "test413WithRetryAfterTrumpsRetryAt", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n   public void test413WithRetryAfterTrumpsRetryAt() {\n      fn.handleError(command, retryAfterTrumps);\n\n      assertEquals(command.getException().getClass(), RetryAfterException.class);\n      assertEquals(command.getException().getMessage(), \"retry in 54 seconds\");\n   }", "signature": "void test413WithRetryAfterTrumpsRetryAt()", "full_signature": "@Test public void test413WithRetryAfterTrumpsRetryAt()", "class_method_signature": "NovaErrorHandlerTest.test413WithRetryAfterTrumpsRetryAt()", "testcase": true, "constructor": false, "invocations": ["handleError", "assertEquals", "getClass", "getException", "assertEquals", "getMessage", "getException"]}, "focal_class": {"identifier": "NovaErrorHandler", "superclass": "", "interfaces": "implements HttpErrorHandler", "fields": [{"original_string": "@Resource\n   protected Logger logger = Logger.NULL;", "modifier": "@Resource\n   protected", "type": "Logger", "declarator": "logger = Logger.NULL", "var_name": "logger"}, {"original_string": "protected final HeaderToRetryAfterException retryAfterParser;", "modifier": "protected final", "type": "HeaderToRetryAfterException", "declarator": "retryAfterParser", "var_name": "retryAfterParser"}, {"original_string": "protected final OverLimitParser overLimitParser;", "modifier": "protected final", "type": "OverLimitParser", "declarator": "overLimitParser", "var_name": "overLimitParser"}], "methods": [{"identifier": "NovaErrorHandler", "parameters": "(HeaderToRetryAfterException retryAfterParser, OverLimitParser overLimitParser)", "modifiers": "protected", "return": "", "signature": " NovaErrorHandler(HeaderToRetryAfterException retryAfterParser, OverLimitParser overLimitParser)", "full_signature": "protected  NovaErrorHandler(HeaderToRetryAfterException retryAfterParser, OverLimitParser overLimitParser)", "class_method_signature": "NovaErrorHandler.NovaErrorHandler(HeaderToRetryAfterException retryAfterParser, OverLimitParser overLimitParser)", "testcase": false, "constructor": true}, {"identifier": "NovaErrorHandler", "parameters": "(DateCodecFactory factory, OverLimitParser overLimitParser)", "modifiers": "@Inject public", "return": "", "signature": " NovaErrorHandler(DateCodecFactory factory, OverLimitParser overLimitParser)", "full_signature": "@Inject public  NovaErrorHandler(DateCodecFactory factory, OverLimitParser overLimitParser)", "class_method_signature": "NovaErrorHandler.NovaErrorHandler(DateCodecFactory factory, OverLimitParser overLimitParser)", "testcase": false, "constructor": true}, {"identifier": "handleError", "parameters": "(HttpCommand command, HttpResponse response)", "modifiers": "public", "return": "void", "signature": "void handleError(HttpCommand command, HttpResponse response)", "full_signature": "public void handleError(HttpCommand command, HttpResponse response)", "class_method_signature": "NovaErrorHandler.handleError(HttpCommand command, HttpResponse response)", "testcase": false, "constructor": false}, {"identifier": "parseAndBuildRetryException", "parameters": "(String json, String message, Exception exception)", "modifiers": "private", "return": "Exception", "signature": "Exception parseAndBuildRetryException(String json, String message, Exception exception)", "full_signature": "private Exception parseAndBuildRetryException(String json, String message, Exception exception)", "class_method_signature": "NovaErrorHandler.parseAndBuildRetryException(String json, String message, Exception exception)", "testcase": false, "constructor": false}], "file": "apis/openstack-nova/src/main/java/org/jclouds/openstack/nova/v2_0/handlers/NovaErrorHandler.java"}, "focal_method": {"identifier": "handleError", "parameters": "(HttpCommand command, HttpResponse response)", "modifiers": "public", "return": "void", "body": "public void handleError(HttpCommand command, HttpResponse response) {\n      // it is important to always read fully and close streams\n      byte[] data = closeClientButKeepContentStream(response);\n      String content = data != null ? emptyToNull(new String(data)) : null;\n\n      Exception exception = content != null ? new HttpResponseException(command, response, content)\n            : new HttpResponseException(command, response);\n      String requestLine = command.getCurrentRequest().getRequestLine();\n      String message = content != null ? content : String.format(\"%s -> %s\", requestLine, response.getStatusLine());\n      switch (response.getStatusCode()) {\n         case 400:\n            if (message.indexOf(\"quota exceeded\") != -1)\n               exception = new InsufficientResourcesException(message, exception);\n            else if (message.indexOf(\"has no fixed_ips\") != -1)\n               exception = new IllegalStateException(message, exception);\n            else if (message.indexOf(\"already exists\") != -1)\n               exception = new IllegalStateException(message, exception);\n            break;\n         case 401:\n         case 403:\n            exception = new AuthorizationException(message, exception);\n            break;\n         case 404:\n            if (!command.getCurrentRequest().getMethod().equals(\"DELETE\")) {\n               exception = new ResourceNotFoundException(message, exception);\n            }\n            break;\n         case 413:\n            if (content == null) {\n               exception = new InsufficientResourcesException(message, exception);\n               break;\n            }\n            exception = parseAndBuildRetryException(content, message, exception);\n      }\n      command.setException(exception);\n   }", "signature": "void handleError(HttpCommand command, HttpResponse response)", "full_signature": "public void handleError(HttpCommand command, HttpResponse response)", "class_method_signature": "NovaErrorHandler.handleError(HttpCommand command, HttpResponse response)", "testcase": false, "constructor": false, "invocations": ["closeClientButKeepContentStream", "emptyToNull", "getRequestLine", "getCurrentRequest", "format", "getStatusLine", "getStatusCode", "indexOf", "indexOf", "indexOf", "equals", "getMethod", "getCurrentRequest", "parseAndBuildRetryException", "setException"]}, "repository": {"repo_id": 489859, "url": "https://github.com/jclouds/legacy-jclouds", "language": "Java", "is_fork": false, "fork_count": 231, "stargazer_count": 477, "size": 74892, "license": "licensed"}}