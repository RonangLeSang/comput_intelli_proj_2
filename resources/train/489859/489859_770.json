{"test_class": {"identifier": "NodeToNodeMetadataTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "String resource = \"location\";", "modifier": "", "type": "String", "declarator": "resource = \"location\"", "var_name": "resource"}, {"original_string": "Location provider = expectedProviderLocationFromResource(resource);", "modifier": "", "type": "Location", "declarator": "provider = expectedProviderLocationFromResource(resource)", "var_name": "provider"}, {"original_string": "Map<String, Credentials> credentialStore = Maps.newLinkedHashMap();", "modifier": "", "type": "Map<String, Credentials>", "declarator": "credentialStore = Maps.newLinkedHashMap()", "var_name": "credentialStore"}, {"original_string": "NodeToNodeMetadata parser = new NodeToNodeMetadata(Suppliers.ofInstance(provider),\n         Suppliers.<Set<? extends Location>> ofInstance(ImmutableSet.of(provider, zoneCalled(\"virginia\", provider))),\n         new SupplyFromProviderURIOrNodesProperty(URI.create(\"test\")), credentialStore);", "modifier": "", "type": "NodeToNodeMetadata", "declarator": "parser = new NodeToNodeMetadata(Suppliers.ofInstance(provider),\n         Suppliers.<Set<? extends Location>> ofInstance(ImmutableSet.of(provider, zoneCalled(\"virginia\", provider))),\n         new SupplyFromProviderURIOrNodesProperty(URI.create(\"test\")), credentialStore)", "var_name": "parser"}], "file": "apis/byon/src/test/java/org/jclouds/byon/functions/NodeToNodeMetadataTest.java"}, "test_case": {"identifier": "testNodesParseLocation", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n   public void testNodesParseLocation() throws Exception {\n      assertEquals(parser.apply(NodesFromYamlTest.TEST2),\n            expectedNodeMetadataFromResource(resource, zoneCalled(\"virginia\", provider)));\n      assertEquals(credentialStore, ImmutableMap.of(\"node#cluster-1\", new Credentials(\"myUser\", NodesFromYamlTest.key)));\n   }", "signature": "void testNodesParseLocation()", "full_signature": "@Test public void testNodesParseLocation()", "class_method_signature": "NodeToNodeMetadataTest.testNodesParseLocation()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "apply", "expectedNodeMetadataFromResource", "zoneCalled", "assertEquals", "of"]}, "focal_class": {"identifier": "NodeToNodeMetadata", "superclass": "", "interfaces": "implements Function<Node, NodeMetadata>", "fields": [{"original_string": "@Resource\n   @Named(ComputeServiceConstants.COMPUTE_LOGGER)\n   protected Logger logger = Logger.NULL;", "modifier": "@Resource\n   @Named(ComputeServiceConstants.COMPUTE_LOGGER)\n   protected", "type": "Logger", "declarator": "logger = Logger.NULL", "var_name": "logger"}, {"original_string": "private final Supplier<Location> location;", "modifier": "private final", "type": "Supplier<Location>", "declarator": "location", "var_name": "location"}, {"original_string": "private final Supplier<Set<? extends Location>> locations;", "modifier": "private final", "type": "Supplier<Set<? extends Location>>", "declarator": "locations", "var_name": "locations"}, {"original_string": "private final Map<String, Credentials> credentialStore;", "modifier": "private final", "type": "Map<String, Credentials>", "declarator": "credentialStore", "var_name": "credentialStore"}, {"original_string": "private final Function<URI, InputStream> slurp;", "modifier": "private final", "type": "Function<URI, InputStream>", "declarator": "slurp", "var_name": "slurp"}], "methods": [{"identifier": "NodeToNodeMetadata", "parameters": "(Supplier<Location> location, @Memoized Supplier<Set<? extends Location>> locations,\n            Function<URI, InputStream> slurp, Map<String, Credentials> credentialStore)", "modifiers": "@Inject", "return": "", "signature": " NodeToNodeMetadata(Supplier<Location> location, @Memoized Supplier<Set<? extends Location>> locations,\n            Function<URI, InputStream> slurp, Map<String, Credentials> credentialStore)", "full_signature": "@Inject  NodeToNodeMetadata(Supplier<Location> location, @Memoized Supplier<Set<? extends Location>> locations,\n            Function<URI, InputStream> slurp, Map<String, Credentials> credentialStore)", "class_method_signature": "NodeToNodeMetadata.NodeToNodeMetadata(Supplier<Location> location, @Memoized Supplier<Set<? extends Location>> locations,\n            Function<URI, InputStream> slurp, Map<String, Credentials> credentialStore)", "testcase": false, "constructor": true}, {"identifier": "apply", "parameters": "(Node from)", "modifiers": "@Override public", "return": "NodeMetadata", "signature": "NodeMetadata apply(Node from)", "full_signature": "@Override public NodeMetadata apply(Node from)", "class_method_signature": "NodeToNodeMetadata.apply(Node from)", "testcase": false, "constructor": false}, {"identifier": "findLocationWithId", "parameters": "(final String locationId)", "modifiers": "private", "return": "Location", "signature": "Location findLocationWithId(final String locationId)", "full_signature": "private Location findLocationWithId(final String locationId)", "class_method_signature": "NodeToNodeMetadata.findLocationWithId(final String locationId)", "testcase": false, "constructor": false}], "file": "apis/byon/src/main/java/org/jclouds/byon/functions/NodeToNodeMetadata.java"}, "focal_method": {"identifier": "apply", "parameters": "(Node from)", "modifiers": "@Override public", "return": "NodeMetadata", "body": "@Override\n   public NodeMetadata apply(Node from) {\n      NodeMetadataBuilder builder = new NodeMetadataBuilder();\n      builder.ids(from.getId());\n      builder.name(from.getName());\n      builder.loginPort(from.getLoginPort());\n      builder.hostname(from.getHostname());\n      builder.location(findLocationWithId(from.getLocationId()));\n      builder.group(from.getGroup());\n      builder.tags(from.getTags());\n      builder.userMetadata(from.getMetadata());\n      builder.operatingSystem(OperatingSystem.builder().arch(from.getOsArch()).family(\n               OsFamily.fromValue(from.getOsFamily())).description(from.getOsDescription())\n               .version(from.getOsVersion()).build());\n      builder.status(Status.RUNNING);\n      builder.publicAddresses(ImmutableSet.<String> of(from.getHostname()));\n\n      if (from.getUsername() != null) {\n         Builder credBuilder = LoginCredentials.builder().user(from.getUsername());\n         if (from.getCredentialUrl() != null) {\n            try {\n               credBuilder.credential(Strings2.toStringAndClose(slurp.apply(from.getCredentialUrl())));\n            } catch (IOException e) {\n               logger.error(e, \"URI could not be read: %s\", from.getCredentialUrl());\n            }\n         } else if (from.getCredential() != null) {\n            credBuilder.credential(from.getCredential());\n         }\n         if (from.getSudoPassword() != null){\n            credBuilder.password(from.getSudoPassword());\n            credBuilder.authenticateSudo(true);\n         }\n         LoginCredentials creds = credBuilder.build();\n         builder.credentials(creds);\n         credentialStore.put(\"node#\" + from.getId(), creds);\n      }\n\n      return builder.build();\n   }", "signature": "NodeMetadata apply(Node from)", "full_signature": "@Override public NodeMetadata apply(Node from)", "class_method_signature": "NodeToNodeMetadata.apply(Node from)", "testcase": false, "constructor": false, "invocations": ["ids", "getId", "name", "getName", "loginPort", "getLoginPort", "hostname", "getHostname", "location", "findLocationWithId", "getLocationId", "group", "getGroup", "tags", "getTags", "userMetadata", "getMetadata", "operatingSystem", "build", "version", "description", "family", "arch", "builder", "getOsArch", "fromValue", "getOsFamily", "getOsDescription", "getOsVersion", "status", "publicAddresses", "of", "getHostname", "getUsername", "user", "builder", "getUsername", "getCredentialUrl", "credential", "toStringAndClose", "apply", "getCredentialUrl", "error", "getCredentialUrl", "getCredential", "credential", "getCredential", "getSudoPassword", "password", "getSudoPassword", "authenticateSudo", "build", "credentials", "put", "getId", "build"]}, "repository": {"repo_id": 489859, "url": "https://github.com/jclouds/legacy-jclouds", "language": "Java", "is_fork": false, "fork_count": 231, "stargazer_count": 477, "size": 74892, "license": "licensed"}}