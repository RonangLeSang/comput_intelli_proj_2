{"test_class": {"identifier": "ServerToNodeMetadataTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "Location provider = new LocationBuilder().scope(LocationScope.ZONE).id(\"dallas\").description(\"description\").build();", "modifier": "", "type": "Location", "declarator": "provider = new LocationBuilder().scope(LocationScope.ZONE).id(\"dallas\").description(\"description\").build()", "var_name": "provider"}, {"original_string": "GroupNamingConvention.Factory namingConvention = Guice.createInjector().getInstance(GroupNamingConvention.Factory.class);", "modifier": "", "type": "GroupNamingConvention.Factory", "declarator": "namingConvention = Guice.createInjector().getInstance(GroupNamingConvention.Factory.class)", "var_name": "namingConvention"}], "file": "apis/cloudservers/src/test/java/org/jclouds/cloudservers/compute/functions/ServerToNodeMetadataTest.java"}, "test_case": {"identifier": "testApplyWhereImageAndHardwareFound", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n   public void testApplyWhereImageAndHardwareFound()  {\n      Map<ServerStatus, Status> serverStateToNodeStatus = CloudServersComputeServiceContextModule.toPortableNodeStatus;\n      Set<org.jclouds.compute.domain.Image> images = ImmutableSet.of(CloudServersImageToImageTest.convertImage());\n      Set<org.jclouds.compute.domain.Hardware> hardwares = ImmutableSet.of(FlavorToHardwareTest.convertFlavor());\n      Server server = ParseServerFromJsonResponseTest.parseServer();\n\n      ServerToNodeMetadata parser = new ServerToNodeMetadata(serverStateToNodeStatus, Suppliers.<Set<? extends Image>> ofInstance(images), Suppliers\n               .ofInstance(provider), Suppliers.<Set<? extends Hardware>> ofInstance(hardwares), namingConvention);\n\n      NodeMetadata metadata = parser.apply(server);\n\n      assertEquals(\n            metadata,\n            new NodeMetadataBuilder()\n                  .status(Status.PENDING)\n                  .publicAddresses(ImmutableSet.of(\"67.23.10.132\", \"67.23.10.131\"))\n                  .privateAddresses(ImmutableSet.of(\"10.176.42.16\"))\n                  .imageId(\"2\")\n                  .hardware(\n                        new HardwareBuilder()\n                              .ids(\"1\")\n                              .name(\"256 MB Server\")\n                              .processors(ImmutableList.of(new Processor(1.0, 1.0)))\n                              .ram(256)\n                              .volumes(\n                                    ImmutableList.of(new VolumeBuilder().type(Volume.Type.LOCAL).size(10.0f)\n                                          .durable(true).bootDevice(true).build())).build())\n                  .operatingSystem(\n                        new OperatingSystem.Builder().family(OsFamily.CENTOS).description(\"CentOS 5.2\").version(\"5.2\")\n                              .is64Bit(true).build())\n                  .id(\"1234\")\n                  .providerId(\"1234\")\n                  .name(\"sample-server\")\n                  .group(\"sample\")\n                  .hostname(\"sample-server\")\n                  .location(\n                        new LocationBuilder().scope(LocationScope.HOST).id(\"e4d909c290d0fb1ca068ffaddf22cbd0\")\n                              .description(\"e4d909c290d0fb1ca068ffaddf22cbd0\").parent(provider).build())\n                  .userMetadata(ImmutableMap.of(\"Server Label\", \"Web Head 1\", \"Image Version\", \"2.1\")).build());\n   }", "signature": "void testApplyWhereImageAndHardwareFound()", "full_signature": "@Test public void testApplyWhereImageAndHardwareFound()", "class_method_signature": "ServerToNodeMetadataTest.testApplyWhereImageAndHardwareFound()", "testcase": true, "constructor": false, "invocations": ["of", "convertImage", "of", "convertFlavor", "parseServer", "ofInstance", "ofInstance", "ofInstance", "apply", "assertEquals", "build", "userMetadata", "location", "hostname", "group", "name", "providerId", "id", "operatingSystem", "hardware", "imageId", "privateAddresses", "publicAddresses", "status", "of", "of", "build", "volumes", "ram", "processors", "name", "ids", "of", "of", "build", "bootDevice", "durable", "size", "type", "build", "is64Bit", "version", "description", "family", "build", "parent", "description", "id", "scope", "of"]}, "focal_class": {"identifier": "ServerToNodeMetadata", "superclass": "", "interfaces": "implements Function<Server, NodeMetadata>", "fields": [{"original_string": "@Resource\n   @Named(ComputeServiceConstants.COMPUTE_LOGGER)\n   protected Logger logger = Logger.NULL;", "modifier": "@Resource\n   @Named(ComputeServiceConstants.COMPUTE_LOGGER)\n   protected", "type": "Logger", "declarator": "logger = Logger.NULL", "var_name": "logger"}, {"original_string": "protected final Supplier<Location> location;", "modifier": "protected final", "type": "Supplier<Location>", "declarator": "location", "var_name": "location"}, {"original_string": "protected final Map<ServerStatus, Status> serverToNodeStatus;", "modifier": "protected final", "type": "Map<ServerStatus, Status>", "declarator": "serverToNodeStatus", "var_name": "serverToNodeStatus"}, {"original_string": "protected final Supplier<Set<? extends Image>> images;", "modifier": "protected final", "type": "Supplier<Set<? extends Image>>", "declarator": "images", "var_name": "images"}, {"original_string": "protected final Supplier<Set<? extends Hardware>> hardwares;", "modifier": "protected final", "type": "Supplier<Set<? extends Hardware>>", "declarator": "hardwares", "var_name": "hardwares"}, {"original_string": "protected final GroupNamingConvention nodeNamingConvention;", "modifier": "protected final", "type": "GroupNamingConvention", "declarator": "nodeNamingConvention", "var_name": "nodeNamingConvention"}], "methods": [{"identifier": "ServerToNodeMetadata", "parameters": "(Map<ServerStatus, Status> serverStateToNodeStatus,\n            @Memoized Supplier<Set<? extends Image>> images, Supplier<Location> location,\n            @Memoized Supplier<Set<? extends Hardware>> hardwares,\n            GroupNamingConvention.Factory namingConvention)", "modifiers": "@Inject", "return": "", "signature": " ServerToNodeMetadata(Map<ServerStatus, Status> serverStateToNodeStatus,\n            @Memoized Supplier<Set<? extends Image>> images, Supplier<Location> location,\n            @Memoized Supplier<Set<? extends Hardware>> hardwares,\n            GroupNamingConvention.Factory namingConvention)", "full_signature": "@Inject  ServerToNodeMetadata(Map<ServerStatus, Status> serverStateToNodeStatus,\n            @Memoized Supplier<Set<? extends Image>> images, Supplier<Location> location,\n            @Memoized Supplier<Set<? extends Hardware>> hardwares,\n            GroupNamingConvention.Factory namingConvention)", "class_method_signature": "ServerToNodeMetadata.ServerToNodeMetadata(Map<ServerStatus, Status> serverStateToNodeStatus,\n            @Memoized Supplier<Set<? extends Image>> images, Supplier<Location> location,\n            @Memoized Supplier<Set<? extends Hardware>> hardwares,\n            GroupNamingConvention.Factory namingConvention)", "testcase": false, "constructor": true}, {"identifier": "apply", "parameters": "(Server from)", "modifiers": "@Override public", "return": "NodeMetadata", "signature": "NodeMetadata apply(Server from)", "full_signature": "@Override public NodeMetadata apply(Server from)", "class_method_signature": "ServerToNodeMetadata.apply(Server from)", "testcase": false, "constructor": false}, {"identifier": "parseHardware", "parameters": "(Server from)", "modifiers": "protected", "return": "Hardware", "signature": "Hardware parseHardware(Server from)", "full_signature": "protected Hardware parseHardware(Server from)", "class_method_signature": "ServerToNodeMetadata.parseHardware(Server from)", "testcase": false, "constructor": false}, {"identifier": "parseOperatingSystem", "parameters": "(Server from)", "modifiers": "protected", "return": "OperatingSystem", "signature": "OperatingSystem parseOperatingSystem(Server from)", "full_signature": "protected OperatingSystem parseOperatingSystem(Server from)", "class_method_signature": "ServerToNodeMetadata.parseOperatingSystem(Server from)", "testcase": false, "constructor": false}], "file": "apis/cloudservers/src/main/java/org/jclouds/cloudservers/compute/functions/ServerToNodeMetadata.java"}, "focal_method": {"identifier": "apply", "parameters": "(Server from)", "modifiers": "@Override public", "return": "NodeMetadata", "body": "@Override\n   public NodeMetadata apply(Server from) {\n      NodeMetadataBuilder builder = new NodeMetadataBuilder();\n      builder.ids(from.getId() + \"\");\n      builder.name(from.getName());\n      builder.hostname(from.getName());\n      builder.location(new LocationBuilder().scope(LocationScope.HOST).id(from.getHostId()).description(\n               from.getHostId()).parent(location.get()).build());\n      addMetadataAndParseTagsFromCommaDelimitedValue(builder, from.getMetadata());\n      builder.group(nodeNamingConvention.groupInUniqueNameOrNull(from.getName()));\n      builder.imageId(from.getImageId() + \"\");\n      builder.operatingSystem(parseOperatingSystem(from));\n      builder.hardware(parseHardware(from));\n      builder.status(serverToNodeStatus.get(from.getStatus()));\n      builder.publicAddresses(from.getAddresses().getPublicAddresses());\n      builder.privateAddresses(from.getAddresses().getPrivateAddresses());\n      return builder.build();\n   }", "signature": "NodeMetadata apply(Server from)", "full_signature": "@Override public NodeMetadata apply(Server from)", "class_method_signature": "ServerToNodeMetadata.apply(Server from)", "testcase": false, "constructor": false, "invocations": ["ids", "getId", "name", "getName", "hostname", "getName", "location", "build", "parent", "description", "id", "scope", "getHostId", "getHostId", "get", "addMetadataAndParseTagsFromCommaDelimitedValue", "getMetadata", "group", "groupInUniqueNameOrNull", "getName", "imageId", "getImageId", "operatingSystem", "parseOperatingSystem", "hardware", "parseHardware", "status", "get", "getStatus", "publicAddresses", "getPublicAddresses", "getAddresses", "privateAddresses", "getPrivateAddresses", "getAddresses", "build"]}, "repository": {"repo_id": 489859, "url": "https://github.com/jclouds/legacy-jclouds", "language": "Java", "is_fork": false, "fork_count": 231, "stargazer_count": 477, "size": 74892, "license": "licensed"}}