{"test_class": {"identifier": "RunningInstanceToNodeMetadataTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static Location provider = new LocationBuilder().scope(LocationScope.REGION).id(\"us-east-1\")\n            .description(\"us-east-1\").build();", "modifier": "static", "type": "Location", "declarator": "provider = new LocationBuilder().scope(LocationScope.REGION).id(\"us-east-1\")\n            .description(\"us-east-1\").build()", "var_name": "provider"}], "file": "apis/ec2/src/test/java/org/jclouds/ec2/compute/functions/RunningInstanceToNodeMetadataTest.java"}, "test_case": {"identifier": "testApplyWhereTagDoesntMatchAndLocationFoundAndImageAndHardwareNotFound", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n   public void testApplyWhereTagDoesntMatchAndLocationFoundAndImageAndHardwareNotFound() throws UnknownHostException {\n      RunningInstanceToNodeMetadata parser = createNodeParser(ImmutableSet.<Hardware> of(), ImmutableSet.of(provider),\n               ImmutableSet.<Image> of(), ImmutableMap.<String, Credentials> of());\n\n      RunningInstance server = firstInstanceFromResource(\"/describe_instances_running.xml\");\n      NodeMetadata expected = new NodeMetadataBuilder().hostname(\"ip-10-243-42-70\").status(Status.RUNNING).backendStatus(\"running\")\n               .privateAddresses(ImmutableSet.of(\"10.243.42.70\")).publicAddresses(ImmutableSet.of(\"174.129.81.68\"))\n               .imageId(\"us-east-1/ami-82e4b5c7\").id(\"us-east-1/i-0799056f\").providerId(\"i-0799056f\")\n               .location(provider).build();\n\n      assertEquals(parser.apply(server).toString(), expected.toString());\n   }", "signature": "void testApplyWhereTagDoesntMatchAndLocationFoundAndImageAndHardwareNotFound()", "full_signature": "@Test public void testApplyWhereTagDoesntMatchAndLocationFoundAndImageAndHardwareNotFound()", "class_method_signature": "RunningInstanceToNodeMetadataTest.testApplyWhereTagDoesntMatchAndLocationFoundAndImageAndHardwareNotFound()", "testcase": true, "constructor": false, "invocations": ["createNodeParser", "of", "of", "of", "of", "firstInstanceFromResource", "build", "location", "providerId", "id", "imageId", "publicAddresses", "privateAddresses", "backendStatus", "status", "hostname", "of", "of", "assertEquals", "toString", "apply", "toString"]}, "focal_class": {"identifier": "RunningInstanceToNodeMetadata", "superclass": "", "interfaces": "implements Function<RunningInstance, NodeMetadata>", "fields": [{"original_string": "@Resource\n   protected Logger logger = Logger.NULL;", "modifier": "@Resource\n   protected", "type": "Logger", "declarator": "logger = Logger.NULL", "var_name": "logger"}, {"original_string": "protected final Supplier<Set<? extends Location>> locations;", "modifier": "protected final", "type": "Supplier<Set<? extends Location>>", "declarator": "locations", "var_name": "locations"}, {"original_string": "protected final Supplier<Set<? extends Hardware>> hardware;", "modifier": "protected final", "type": "Supplier<Set<? extends Hardware>>", "declarator": "hardware", "var_name": "hardware"}, {"original_string": "protected final Supplier<LoadingCache<RegionAndName, ? extends Image>> imageMap;", "modifier": "protected final", "type": "Supplier<LoadingCache<RegionAndName, ? extends Image>>", "declarator": "imageMap", "var_name": "imageMap"}, {"original_string": "protected final Map<String, Credentials> credentialStore;", "modifier": "protected final", "type": "Map<String, Credentials>", "declarator": "credentialStore", "var_name": "credentialStore"}, {"original_string": "protected final Map<InstanceState, Status> instanceToNodeStatus;", "modifier": "protected final", "type": "Map<InstanceState, Status>", "declarator": "instanceToNodeStatus", "var_name": "instanceToNodeStatus"}, {"original_string": "protected final GroupNamingConvention.Factory namingConvention;", "modifier": "protected final", "type": "GroupNamingConvention.Factory", "declarator": "namingConvention", "var_name": "namingConvention"}], "methods": [{"identifier": "RunningInstanceToNodeMetadata", "parameters": "(Map<InstanceState, Status> instanceToNodeStatus,\n            Map<String, Credentials> credentialStore, Supplier<LoadingCache<RegionAndName, ? extends Image>> imageMap,\n            @Memoized Supplier<Set<? extends Location>> locations, @Memoized Supplier<Set<? extends Hardware>> hardware,\n            GroupNamingConvention.Factory namingConvention)", "modifiers": "@Inject protected", "return": "", "signature": " RunningInstanceToNodeMetadata(Map<InstanceState, Status> instanceToNodeStatus,\n            Map<String, Credentials> credentialStore, Supplier<LoadingCache<RegionAndName, ? extends Image>> imageMap,\n            @Memoized Supplier<Set<? extends Location>> locations, @Memoized Supplier<Set<? extends Hardware>> hardware,\n            GroupNamingConvention.Factory namingConvention)", "full_signature": "@Inject protected  RunningInstanceToNodeMetadata(Map<InstanceState, Status> instanceToNodeStatus,\n            Map<String, Credentials> credentialStore, Supplier<LoadingCache<RegionAndName, ? extends Image>> imageMap,\n            @Memoized Supplier<Set<? extends Location>> locations, @Memoized Supplier<Set<? extends Hardware>> hardware,\n            GroupNamingConvention.Factory namingConvention)", "class_method_signature": "RunningInstanceToNodeMetadata.RunningInstanceToNodeMetadata(Map<InstanceState, Status> instanceToNodeStatus,\n            Map<String, Credentials> credentialStore, Supplier<LoadingCache<RegionAndName, ? extends Image>> imageMap,\n            @Memoized Supplier<Set<? extends Location>> locations, @Memoized Supplier<Set<? extends Hardware>> hardware,\n            GroupNamingConvention.Factory namingConvention)", "testcase": false, "constructor": true}, {"identifier": "apply", "parameters": "(RunningInstance instance)", "modifiers": "@Override public", "return": "NodeMetadata", "signature": "NodeMetadata apply(RunningInstance instance)", "full_signature": "@Override public NodeMetadata apply(RunningInstance instance)", "class_method_signature": "RunningInstanceToNodeMetadata.apply(RunningInstance instance)", "testcase": false, "constructor": false}, {"identifier": "addCredentialsForInstance", "parameters": "(NodeMetadataBuilder builder, RunningInstance instance)", "modifiers": "protected", "return": "void", "signature": "void addCredentialsForInstance(NodeMetadataBuilder builder, RunningInstance instance)", "full_signature": "protected void addCredentialsForInstance(NodeMetadataBuilder builder, RunningInstance instance)", "class_method_signature": "RunningInstanceToNodeMetadata.addCredentialsForInstance(NodeMetadataBuilder builder, RunningInstance instance)", "testcase": false, "constructor": false}, {"identifier": "parseHardware", "parameters": "(final RunningInstance instance)", "modifiers": "protected", "return": "Hardware", "signature": "Hardware parseHardware(final RunningInstance instance)", "full_signature": "protected Hardware parseHardware(final RunningInstance instance)", "class_method_signature": "RunningInstanceToNodeMetadata.parseHardware(final RunningInstance instance)", "testcase": false, "constructor": false}, {"identifier": "addEBS", "parameters": "(final RunningInstance instance, Iterable<? extends Volume> volumes)", "modifiers": "@VisibleForTesting static", "return": "List<Volume>", "signature": "List<Volume> addEBS(final RunningInstance instance, Iterable<? extends Volume> volumes)", "full_signature": "@VisibleForTesting static List<Volume> addEBS(final RunningInstance instance, Iterable<? extends Volume> volumes)", "class_method_signature": "RunningInstanceToNodeMetadata.addEBS(final RunningInstance instance, Iterable<? extends Volume> volumes)", "testcase": false, "constructor": false}, {"identifier": "getGroupForInstance", "parameters": "(final RunningInstance instance)", "modifiers": "@VisibleForTesting", "return": "String", "signature": "String getGroupForInstance(final RunningInstance instance)", "full_signature": "@VisibleForTesting String getGroupForInstance(final RunningInstance instance)", "class_method_signature": "RunningInstanceToNodeMetadata.getGroupForInstance(final RunningInstance instance)", "testcase": false, "constructor": false}, {"identifier": "parseGroupFrom", "parameters": "(final RunningInstance instance, final Set<String> data)", "modifiers": "private", "return": "String", "signature": "String parseGroupFrom(final RunningInstance instance, final Set<String> data)", "full_signature": "private String parseGroupFrom(final RunningInstance instance, final Set<String> data)", "class_method_signature": "RunningInstanceToNodeMetadata.parseGroupFrom(final RunningInstance instance, final Set<String> data)", "testcase": false, "constructor": false}, {"identifier": "getHardwareForInstance", "parameters": "(final RunningInstance instance)", "modifiers": "@VisibleForTesting", "return": "Hardware", "signature": "Hardware getHardwareForInstance(final RunningInstance instance)", "full_signature": "@VisibleForTesting Hardware getHardwareForInstance(final RunningInstance instance)", "class_method_signature": "RunningInstanceToNodeMetadata.getHardwareForInstance(final RunningInstance instance)", "testcase": false, "constructor": false}, {"identifier": "getLocationForAvailabilityZoneOrRegion", "parameters": "(final RunningInstance instance)", "modifiers": "private", "return": "Location", "signature": "Location getLocationForAvailabilityZoneOrRegion(final RunningInstance instance)", "full_signature": "private Location getLocationForAvailabilityZoneOrRegion(final RunningInstance instance)", "class_method_signature": "RunningInstanceToNodeMetadata.getLocationForAvailabilityZoneOrRegion(final RunningInstance instance)", "testcase": false, "constructor": false}, {"identifier": "findLocationWithId", "parameters": "(final String locationId)", "modifiers": "private", "return": "Location", "signature": "Location findLocationWithId(final String locationId)", "full_signature": "private Location findLocationWithId(final String locationId)", "class_method_signature": "RunningInstanceToNodeMetadata.findLocationWithId(final String locationId)", "testcase": false, "constructor": false}], "file": "apis/ec2/src/main/java/org/jclouds/ec2/compute/functions/RunningInstanceToNodeMetadata.java"}, "focal_method": {"identifier": "apply", "parameters": "(RunningInstance instance)", "modifiers": "@Override public", "return": "NodeMetadata", "body": "@Override\n   public NodeMetadata apply(RunningInstance instance) {\n      if (instance == null || instance.getId() == null)\n         return null;\n      NodeMetadataBuilder builder = new NodeMetadataBuilder();\n      builder.name(instance.getTags().get(\"Name\"));\n      addMetadataAndParseTagsFromValuesOfEmptyString(builder, instance.getTags());\n      builder.providerId(instance.getId());\n      builder.id(instance.getRegion() + \"/\" + instance.getId());\n      String group = getGroupForInstance(instance);\n      builder.group(group);\n      // standard convention from aws-ec2, which might not be re-used outside.\n      if (instance.getPrivateDnsName() != null)\n         builder.hostname(instance.getPrivateDnsName().replaceAll(\"\\\\..*\", \"\"));\n      addCredentialsForInstance(builder, instance);\n      builder.status(instanceToNodeStatus.get(instance.getInstanceState()));\n      builder.backendStatus(instance.getRawState());\n\n      // collect all ip addresses into one bundle in case the api mistakenly put a private address\n      // into the public address field\n      Builder<String> addressesBuilder = ImmutableSet.builder();\n      if (emptyToNull(instance.getIpAddress()) != null)\n         addressesBuilder.add(instance.getIpAddress());\n      if (emptyToNull(instance.getPrivateIpAddress()) != null)\n         addressesBuilder.add(instance.getPrivateIpAddress());\n\n      Set<String> addresses = addressesBuilder.build();\n\n      builder.publicAddresses(filter(addresses, not(IsPrivateIPAddress.INSTANCE)));\n      builder.privateAddresses(filter(addresses, IsPrivateIPAddress.INSTANCE));\n      builder.hardware(parseHardware(instance));\n      Location location = getLocationForAvailabilityZoneOrRegion(instance);\n      builder.location(location);\n      builder.imageId(instance.getRegion() + \"/\" + instance.getImageId());\n\n      // extract the operating system from the image\n      RegionAndName regionAndName = new RegionAndName(instance.getRegion(), instance.getImageId());\n      try {\n         Image image = imageMap.get().getUnchecked(regionAndName);\n         if (image != null)\n            builder.operatingSystem(image.getOperatingSystem());\n      } catch (CacheLoader.InvalidCacheLoadException e) {\n         logger.debug(\"image not found for %s: %s\", regionAndName, e);\n      } catch (UncheckedExecutionException e) {\n         logger.debug(\"error getting image for %s: %s\", regionAndName, e);\n      }\n      return builder.build();\n   }", "signature": "NodeMetadata apply(RunningInstance instance)", "full_signature": "@Override public NodeMetadata apply(RunningInstance instance)", "class_method_signature": "RunningInstanceToNodeMetadata.apply(RunningInstance instance)", "testcase": false, "constructor": false, "invocations": ["getId", "name", "get", "getTags", "addMetadataAndParseTagsFromValuesOfEmptyString", "getTags", "providerId", "getId", "id", "getRegion", "getId", "getGroupForInstance", "group", "getPrivateDnsName", "hostname", "replaceAll", "getPrivateDnsName", "addCredentialsForInstance", "status", "get", "getInstanceState", "backendStatus", "getRawState", "builder", "emptyToNull", "getIpAddress", "add", "getIpAddress", "emptyToNull", "getPrivateIpAddress", "add", "getPrivateIpAddress", "build", "publicAddresses", "filter", "not", "privateAddresses", "filter", "hardware", "parseHardware", "getLocationForAvailabilityZoneOrRegion", "location", "imageId", "getRegion", "getImageId", "getRegion", "getImageId", "getUnchecked", "get", "operatingSystem", "getOperatingSystem", "debug", "debug", "build"]}, "repository": {"repo_id": 489859, "url": "https://github.com/jclouds/legacy-jclouds", "language": "Java", "is_fork": false, "fork_count": 231, "stargazer_count": 477, "size": 74892, "license": "licensed"}}