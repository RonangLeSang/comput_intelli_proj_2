{"test_class": {"identifier": "LexStringLiteralTest", "superclass": "", "interfaces": "", "fields": [], "file": "parsed/src/test/java/com/wyrdtech/parsed/lexer/LexStringLiteralTest.java"}, "test_case": {"identifier": "wysiwyg", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void wysiwyg() throws Exception {\n        String str = \"r\\\"a\\\\b\\\\nc\\\"\";\n\n        LexerStream ls = new LexerStream(new StringReader(str));\n        LexStringLiteral lex = new LexStringLiteral(new BaseTokenFactory(), ls);\n\n        Token tok = lex.read();\n\n        assertEquals(TokenType.LiteralUtf8, tok.getType());\n        assertTrue(tok.getValue() instanceof String);\n        assertEquals(\"a\\\\b\\\\nc\", tok.getValue());\n        assertEquals(1, tok.getLine());\n        assertEquals(1, tok.getCol());\n        assertEquals(1, tok.getEndLine());\n        assertEquals(10, tok.getEndCol());\n\n        assertEquals(-1, ls.read());\n    }", "signature": "void wysiwyg()", "full_signature": "@Test public void wysiwyg()", "class_method_signature": "LexStringLiteralTest.wysiwyg()", "testcase": true, "constructor": false, "invocations": ["read", "assertEquals", "getType", "assertTrue", "getValue", "assertEquals", "getValue", "assertEquals", "getLine", "assertEquals", "getCol", "assertEquals", "getEndLine", "assertEquals", "getEndCol", "assertEquals", "read"]}, "focal_class": {"identifier": "LexStringLiteral", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final TokenFactory factory;", "modifier": "private final", "type": "TokenFactory", "declarator": "factory", "var_name": "factory"}, {"original_string": "private final LexerStream in_stream;", "modifier": "private final", "type": "LexerStream", "declarator": "in_stream", "var_name": "in_stream"}], "methods": [{"identifier": "LexStringLiteral", "parameters": "(TokenFactory factory, LexerStream in_stream)", "modifiers": "public", "return": "", "signature": " LexStringLiteral(TokenFactory factory, LexerStream in_stream)", "full_signature": "public  LexStringLiteral(TokenFactory factory, LexerStream in_stream)", "class_method_signature": "LexStringLiteral.LexStringLiteral(TokenFactory factory, LexerStream in_stream)", "testcase": false, "constructor": true}, {"identifier": "read", "parameters": "()", "modifiers": "public", "return": "Token", "signature": "Token read()", "full_signature": "public Token read()", "class_method_signature": "LexStringLiteral.read()", "testcase": false, "constructor": false}], "file": "parsed/src/main/java/com/wyrdtech/parsed/lexer/LexStringLiteral.java"}, "focal_method": {"identifier": "read", "parameters": "()", "modifiers": "public", "return": "Token", "body": "public Token read() throws IOException, LexerException\n    {\n        int start_index = in_stream.getPosition();\n        int start_line = in_stream.getLine();\n        int start_col = in_stream.getCol();\n\n        boolean is_literal = false;\n\n        int next = in_stream.peek();\n        if (next == -1) {\n            throw new LexerException(start_line, start_col, \"Unexpected end of input stream when parsing string literal\");\n        }\n\n        if (next == 'r') {\n            is_literal = true;\n            in_stream.read();\n            next = in_stream.peek();\n        }\n\n        int initial = next;\n        if (initial == '`') {\n            is_literal = true;\n        }\n\n        TokenType type = TokenType.LiteralUtf8;\n\n        StringBuilder sb = new StringBuilder();\n        in_stream.read(); // consume opening quote\n\n        next = in_stream.peek();\n        while (next != -1 && next != initial) {\n\n            if (next == '\\\\' && !is_literal) {\n                sb.append(Character.toChars(LexEscape.read(in_stream)));\n            } else {\n                sb.append(Character.toChars(in_stream.read()));\n            }\n\n            next = in_stream.peek();\n        }\n\n        if (next == -1) {\n            throw new LexerException(start_line, start_col, \"Unexpected end of input stream when parsing string literal\");\n        }\n\n        in_stream.read(); // consume closing quote\n        next = in_stream.peek();\n\n        // end of literal, check for suffix\n        if (next == 'c') {\n            type = TokenType.LiteralUtf8;\n            in_stream.read();\n        }\n        else if (next == 'w') {\n            type = TokenType.LiteralUtf16;\n            in_stream.read();\n        }\n        else if (next == 'd') {\n            type = TokenType.LiteralUtf32;\n            in_stream.read();\n        }\n\n\n        return factory.create(type,\n                              start_index,\n                              start_line,\n                              start_col,\n                              in_stream.getPosition(),\n                              in_stream.getLine(),\n                              in_stream.getCol(),\n                              sb.toString());\n    }", "signature": "Token read()", "full_signature": "public Token read()", "class_method_signature": "LexStringLiteral.read()", "testcase": false, "constructor": false, "invocations": ["getPosition", "getLine", "getCol", "peek", "read", "peek", "read", "peek", "append", "toChars", "read", "append", "toChars", "read", "peek", "read", "peek", "read", "read", "read", "create", "getPosition", "getLine", "getCol", "toString"]}, "repository": {"repo_id": 9779351, "url": "https://github.com/jerpowers/intelliD", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 5, "size": 1077, "license": "licensed"}}