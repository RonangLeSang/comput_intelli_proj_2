{"test_class": {"identifier": "LexOperatorTest", "superclass": "", "interfaces": "", "fields": [], "file": "parsed/src/test/java/com/wyrdtech/parsed/lexer/LexOperatorTest.java"}, "test_case": {"identifier": "mod", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void mod() throws Exception {\n        String str = \"a%=b%c;\";\n\n        LexerStream ls = new LexerStream(new StringReader(str));\n        LexOperator lex = new LexOperator(new BaseTokenFactory(), ls);\n\n        ls.read();\n\n        Token tok = lex.read();\n\n        assertEquals(TokenType.ModAssign, tok.getType());\n        assertEquals(1, tok.getLine());\n        assertEquals(2, tok.getCol());\n        assertEquals(1, tok.getEndLine());\n        assertEquals(4, tok.getEndCol());\n\n        ls.read();\n\n        tok = lex.read();\n\n        assertEquals(TokenType.Mod, tok.getType());\n        assertEquals(1, tok.getLine());\n        assertEquals(5, tok.getCol());\n        assertEquals(1, tok.getEndLine());\n        assertEquals(6, tok.getEndCol());\n\n        assertEquals('c', ls.read());\n\n        tok = lex.read();\n        assertEquals(TokenType.Semicolon, tok.getType());\n\n        assertEquals(-1, ls.read());\n    }", "signature": "void mod()", "full_signature": "@Test public void mod()", "class_method_signature": "LexOperatorTest.mod()", "testcase": true, "constructor": false, "invocations": ["read", "read", "assertEquals", "getType", "assertEquals", "getLine", "assertEquals", "getCol", "assertEquals", "getEndLine", "assertEquals", "getEndCol", "read", "read", "assertEquals", "getType", "assertEquals", "getLine", "assertEquals", "getCol", "assertEquals", "getEndLine", "assertEquals", "getEndCol", "assertEquals", "read", "read", "assertEquals", "getType", "assertEquals", "read"]}, "focal_class": {"identifier": "LexOperator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final TokenFactory factory;", "modifier": "private final", "type": "TokenFactory", "declarator": "factory", "var_name": "factory"}, {"original_string": "private final LexerStream in_stream;", "modifier": "private final", "type": "LexerStream", "declarator": "in_stream", "var_name": "in_stream"}], "methods": [{"identifier": "LexOperator", "parameters": "(TokenFactory factory, LexerStream in_stream)", "modifiers": "public", "return": "", "signature": " LexOperator(TokenFactory factory, LexerStream in_stream)", "full_signature": "public  LexOperator(TokenFactory factory, LexerStream in_stream)", "class_method_signature": "LexOperator.LexOperator(TokenFactory factory, LexerStream in_stream)", "testcase": false, "constructor": true}, {"identifier": "read", "parameters": "()", "modifiers": "public", "return": "Token", "signature": "Token read()", "full_signature": "public Token read()", "class_method_signature": "LexOperator.read()", "testcase": false, "constructor": false}], "file": "parsed/src/main/java/com/wyrdtech/parsed/lexer/LexOperator.java"}, "focal_method": {"identifier": "read", "parameters": "()", "modifiers": "public", "return": "Token", "body": "public Token read() throws IOException, LexerException\n    {\n        int index = in_stream.getPosition();\n        int line = in_stream.getLine();\n        int col = in_stream.getCol();\n\n        int next = in_stream.peek();\n        if (next == -1) {\n            // end of stream!\n            throw new LexerException(in_stream.getLine(), in_stream.getCol(), \"Unexpected end of input stream when parsing operator\");\n        }\n\n        // If we have a '.' may be a literal, in which case don't want to consume here\n        if (next == '.') {\n            int tmp = in_stream.peek(2);\n            if (tmp > 0 && Character.isDigit(tmp)) {\n                throw new LexerException(in_stream.getLine(), in_stream.getCol(), \"Literal float encountered when operator '.' expected\");\n            }\n        }\n\n        // Everything else we consume the first char, check it and next\n        char cur = (char)in_stream.read();\n        next = in_stream.peek();\n\n        switch (cur)\n        {\n            case '+':\n                switch (next)\n                {\n                    case '+':\n                        in_stream.read();\n                        return factory.create(TokenType.Increment, index, line, col, 2);\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.PlusAssign, index, line, col, 2);\n                }\n                return factory.create(TokenType.Plus, index, line, col);\n            case '-':\n                switch (next)\n                {\n                    case '-':\n                        in_stream.read();\n                        return factory.create(TokenType.Decrement, index, line, col, 2);\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.MinusAssign, index, line, col, 2);\n                }\n                return factory.create(TokenType.Minus, index, line, col);\n            case '*':\n                switch (next)\n                {\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.TimesAssign, index, line, col, 2);\n                    default:\n                        break;\n                }\n                return factory.create(TokenType.Times, index, line, col);\n            case '/':\n                switch (next)\n                {\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.DivAssign, index, line, col, 2);\n                }\n                return factory.create(TokenType.Div, index, line, col);\n            case '%':\n                switch (next)\n                {\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.ModAssign, index, line, col, 2);\n                }\n                return factory.create(TokenType.Mod, index, line, col);\n            case '&':\n                switch (next)\n                {\n                    case '&':\n                        in_stream.read();\n                        return factory.create(TokenType.LogicalAnd, index, line, col, 2);\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.BitwiseAndAssign, index, line, col, 2);\n                }\n                return factory.create(TokenType.BitwiseAnd, index, line, col);\n            case '|':\n                switch (next)\n                {\n                    case '|':\n                        in_stream.read();\n                        return factory.create(TokenType.LogicalOr, index, line, col, 2);\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.BitwiseOrAssign, index, line, col, 2);\n                }\n                return factory.create(TokenType.BitwiseOr, index, line, col);\n            case '^':\n                switch (next)\n                {\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.XorAssign, index, line, col, 2);\n                    case '^':\n                        in_stream.read();\n                        if (in_stream.peek() == '=')\n                        {\n                            in_stream.read();\n                            return factory.create(TokenType.PowAssign, index, line, col, 3);\n                        }\n                        return factory.create(TokenType.Pow, index, line, col, 2);\n                }\n                return factory.create(TokenType.Xor, index, line, col);\n            case '!':\n                switch (next)\n                {\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.NotEqual, index, line, col, 2); // !=\n\n                    case '<':\n                        in_stream.read();\n                        switch (in_stream.peek())\n                        {\n                            case '=':\n                                in_stream.read();\n                                return factory.create(TokenType.UnorderedOrGreater, index, line, col, 3); // !<=\n                            case '>':\n                                in_stream.read();\n                                switch (in_stream.peek())\n                                {\n                                    case '=':\n                                        in_stream.read();\n                                        return factory.create(TokenType.Unordered, index, line, col, 4); // !<>=\n                                }\n                                return factory.create(TokenType.UnorderedOrEqual, index, line, col, 3); // !<>\n                        }\n                        return factory.create(TokenType.UnorderedGreaterOrEqual, index, line, col, 2); // !<\n\n                    case '>':\n                        in_stream.read();\n                        switch (in_stream.peek())\n                        {\n                            case '=':\n                                in_stream.read();\n                                return factory.create(TokenType.UnorderedOrLess, index, line, col, 3); // !>=\n                            default:\n                                break;\n                        }\n                        return factory.create(TokenType.UnorderedLessOrEqual, index, line, col, 2); // !>\n\n                }\n                return factory.create(TokenType.Not, index, line, col);\n            case '~':\n                switch (next)\n                {\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.TildeAssign, index, line, col, 2);\n                }\n                return factory.create(TokenType.Tilde, index, line, col);\n            case '=':\n                switch (next)\n                {\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.Equal, index, line, col, 2);\n                    case '>':\n                        in_stream.read();\n                        return factory.create(TokenType.GoesTo, index, line, col, 2);\n                }\n                return factory.create(TokenType.Assign, index, line, col);\n            case '<':\n                switch (next)\n                {\n                    case '<':\n                        in_stream.read();\n                        switch (in_stream.peek())\n                        {\n                            case '=':\n                                in_stream.read();\n                                return factory.create(TokenType.ShiftLeftAssign, index, line, col, 3);\n                            default:\n                                break;\n                        }\n                        return factory.create(TokenType.ShiftLeft, index, line, col, 2);\n                    case '>':\n                        in_stream.read();\n                        switch (in_stream.peek())\n                        {\n                            case '=':\n                                in_stream.read();\n                                return factory.create(TokenType.LessEqualOrGreater, index, line, col, 3);\n                            default:\n                                break;\n                        }\n                        return factory.create(TokenType.LessOrGreater, index, line, col, 2);\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.LessEqual, index, line, col, 2);\n                }\n                return factory.create(TokenType.LessThan, index, line, col);\n            case '>':\n                switch (next)\n                {\n                    case '>':\n                        in_stream.read();\n                        int p = in_stream.peek();\n                        if (p != -1)\n                        {\n                            switch ((char)p)\n                            {\n                                case '=':\n                                    in_stream.read();\n                                    return factory.create(TokenType.ShiftRightAssign, index, line, col, 3);\n                                case '>':\n                                    in_stream.read();\n                                    int q = in_stream.peek();\n                                    if (q != -1 && q == '=')\n                                    {\n                                        in_stream.read();\n                                        return factory.create(TokenType.TripleRightShiftAssign, index, line, col, 4);\n                                    }\n                                    return factory.create(TokenType.ShiftRightUnsigned, index, line, col, 3); // >>>\n                            }\n                        }\n                        return factory.create(TokenType.ShiftRight, index, line, col, 2);\n                    case '=':\n                        in_stream.read();\n                        return factory.create(TokenType.GreaterEqual, index, line, col, 2);\n                }\n                return factory.create(TokenType.GreaterThan, index, line, col);\n            case '?':\n                return factory.create(TokenType.Question, index, line, col);\n            case '$':\n                return factory.create(TokenType.Dollar, index, line, col);\n            case ';':\n                return factory.create(TokenType.Semicolon, index, line, col);\n            case ':':\n                return factory.create(TokenType.Colon, index, line, col);\n            case ',':\n                return factory.create(TokenType.Comma, index, line, col);\n            case '.':\n                if (next == '.')\n                {\n                    in_stream.read();\n                    int p = in_stream.peek();\n                    if (p != -1 && p == '.') {\n                        in_stream.read();\n                        return factory.create(TokenType.TripleDot, index, line, col, 3);\n                    }\n                    return factory.create(TokenType.DoubleDot, index, line, col, 2);\n                }\n                return factory.create(TokenType.Dot, index, line, col);\n            case ')':\n                return factory.create(TokenType.CloseParenthesis, index, line, col);\n            case '(':\n                return factory.create(TokenType.OpenParenthesis, index, line, col);\n            case ']':\n                return factory.create(TokenType.CloseSquareBracket, index, line, col);\n            case '[':\n                return factory.create(TokenType.OpenSquareBracket, index, line, col);\n            case '}':\n                return factory.create(TokenType.CloseCurlyBrace, index, line, col);\n            case '{':\n                return factory.create(TokenType.OpenCurlyBrace, index, line, col);\n            case '#':\n                return factory.create(TokenType.Hash, index, line, col);\n            default:\n                return null;\n        }\n    }", "signature": "Token read()", "full_signature": "public Token read()", "class_method_signature": "LexOperator.read()", "testcase": false, "constructor": false, "invocations": ["getPosition", "getLine", "getCol", "peek", "getLine", "getCol", "peek", "isDigit", "getLine", "getCol", "read", "peek", "read", "create", "read", "create", "create", "read", "create", "read", "create", "create", "read", "create", "create", "read", "create", "create", "read", "create", "create", "read", "create", "read", "create", "create", "read", "create", "read", "create", "create", "read", "create", "read", "peek", "read", "create", "create", "create", "read", "create", "read", "peek", "read", "create", "read", "peek", "read", "create", "create", "create", "read", "peek", "read", "create", "create", "create", "read", "create", "create", "read", "create", "read", "create", "create", "read", "peek", "read", "create", "create", "read", "peek", "read", "create", "create", "read", "create", "create", "read", "peek", "read", "create", "read", "peek", "read", "create", "create", "create", "read", "create", "create", "create", "create", "create", "create", "create", "read", "peek", "read", "create", "create", "create", "create", "create", "create", "create", "create", "create", "create"]}, "repository": {"repo_id": 9779351, "url": "https://github.com/jerpowers/intelliD", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 5, "size": 1077, "license": "licensed"}}