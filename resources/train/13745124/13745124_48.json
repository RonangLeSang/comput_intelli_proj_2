{"test_class": {"identifier": "FileTreeTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final PathService pathService =\n      PathServiceTest.fakePathService(\n          new PathType(true, '/') {\n            @Override\n            public ParseResult parsePath(String path) {\n              String root = null;\n              if (path.matches(\"^[/$!].*\")) {\n                root = path.substring(0, 1);\n                path = path.substring(1);\n              }\n              return new ParseResult(root, Splitter.on('/').omitEmptyStrings().split(path));\n            }\n\n            @Override\n            public String toString(@NullableDecl String root, Iterable<String> names) {\n              root = Strings.nullToEmpty(root);\n              return root + Joiner.on('/').join(names);\n            }\n\n            @Override\n            public String toUriPath(String root, Iterable<String> names, boolean directory) {\n              // need to add extra / to differentiate between paths \"/$foo/bar\" and \"$foo/bar\".\n              return \"/\" + toString(root, names);\n            }\n\n            @Override\n            public ParseResult parseUriPath(String uriPath) {\n              checkArgument(\n                  uriPath.matches(\"^/[/$!].*\"), \"uriPath (%s) must start with // or /$ or /!\");\n              return parsePath(uriPath.substring(1)); // skip leading /\n            }\n          },\n          false);", "modifier": "private final", "type": "PathService", "declarator": "pathService =\n      PathServiceTest.fakePathService(\n          new PathType(true, '/') {\n            @Override\n            public ParseResult parsePath(String path) {\n              String root = null;\n              if (path.matches(\"^[/$!].*\")) {\n                root = path.substring(0, 1);\n                path = path.substring(1);\n              }\n              return new ParseResult(root, Splitter.on('/').omitEmptyStrings().split(path));\n            }\n\n            @Override\n            public String toString(@NullableDecl String root, Iterable<String> names) {\n              root = Strings.nullToEmpty(root);\n              return root + Joiner.on('/').join(names);\n            }\n\n            @Override\n            public String toUriPath(String root, Iterable<String> names, boolean directory) {\n              // need to add extra / to differentiate between paths \"/$foo/bar\" and \"$foo/bar\".\n              return \"/\" + toString(root, names);\n            }\n\n            @Override\n            public ParseResult parseUriPath(String uriPath) {\n              checkArgument(\n                  uriPath.matches(\"^/[/$!].*\"), \"uriPath (%s) must start with // or /$ or /!\");\n              return parsePath(uriPath.substring(1)); // skip leading /\n            }\n          },\n          false)", "var_name": "pathService"}, {"original_string": "private FileTree fileTree;", "modifier": "private", "type": "FileTree", "declarator": "fileTree", "var_name": "fileTree"}, {"original_string": "private File workingDirectory;", "modifier": "private", "type": "File", "declarator": "workingDirectory", "var_name": "workingDirectory"}, {"original_string": "private final Map<String, File> files = new HashMap<>();", "modifier": "private final", "type": "Map<String, File>", "declarator": "files = new HashMap<>()", "var_name": "files"}], "file": "jimfs/src/test/java/com/google/common/jimfs/FileTreeTest.java"}, "test_case": {"identifier": "testLookup_absolute_intermediateSymlink_parentExists", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testLookup_absolute_intermediateSymlink_parentExists() throws IOException {\n    assertParentExists(lookup(\"/work/four/five/baz\"), \"foo\");\n    assertParentExists(lookup(\"/work/four/six/baz\"), \"one\");\n  }", "signature": "void testLookup_absolute_intermediateSymlink_parentExists()", "full_signature": "@Test public void testLookup_absolute_intermediateSymlink_parentExists()", "class_method_signature": "FileTreeTest.testLookup_absolute_intermediateSymlink_parentExists()", "testcase": true, "constructor": false, "invocations": ["assertParentExists", "lookup", "assertParentExists", "lookup"]}, "focal_class": {"identifier": "FileTree", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int MAX_SYMBOLIC_LINK_DEPTH = 40;", "modifier": "private static final", "type": "int", "declarator": "MAX_SYMBOLIC_LINK_DEPTH = 40", "var_name": "MAX_SYMBOLIC_LINK_DEPTH"}, {"original_string": "private static final ImmutableList<Name> EMPTY_PATH_NAMES = ImmutableList.of(Name.SELF);", "modifier": "private static final", "type": "ImmutableList<Name>", "declarator": "EMPTY_PATH_NAMES = ImmutableList.of(Name.SELF)", "var_name": "EMPTY_PATH_NAMES"}, {"original_string": "private final ImmutableSortedMap<Name, Directory> roots;", "modifier": "private final", "type": "ImmutableSortedMap<Name, Directory>", "declarator": "roots", "var_name": "roots"}], "methods": [{"identifier": "FileTree", "parameters": "(Map<Name, Directory> roots)", "modifiers": "", "return": "", "signature": " FileTree(Map<Name, Directory> roots)", "full_signature": "  FileTree(Map<Name, Directory> roots)", "class_method_signature": "FileTree.FileTree(Map<Name, Directory> roots)", "testcase": false, "constructor": true}, {"identifier": "getRootDirectoryNames", "parameters": "()", "modifiers": "public", "return": "ImmutableSortedSet<Name>", "signature": "ImmutableSortedSet<Name> getRootDirectoryNames()", "full_signature": "public ImmutableSortedSet<Name> getRootDirectoryNames()", "class_method_signature": "FileTree.getRootDirectoryNames()", "testcase": false, "constructor": false}, {"identifier": "getRoot", "parameters": "(Name name)", "modifiers": "@NullableDecl public", "return": "DirectoryEntry", "signature": "DirectoryEntry getRoot(Name name)", "full_signature": "@NullableDecl public DirectoryEntry getRoot(Name name)", "class_method_signature": "FileTree.getRoot(Name name)", "testcase": false, "constructor": false}, {"identifier": "lookUp", "parameters": "(\n      File workingDirectory, JimfsPath path, Set<? super LinkOption> options)", "modifiers": "public", "return": "DirectoryEntry", "signature": "DirectoryEntry lookUp(\n      File workingDirectory, JimfsPath path, Set<? super LinkOption> options)", "full_signature": "public DirectoryEntry lookUp(\n      File workingDirectory, JimfsPath path, Set<? super LinkOption> options)", "class_method_signature": "FileTree.lookUp(\n      File workingDirectory, JimfsPath path, Set<? super LinkOption> options)", "testcase": false, "constructor": false}, {"identifier": "lookUp", "parameters": "(\n      File dir, JimfsPath path, Set<? super LinkOption> options, int linkDepth)", "modifiers": "@NullableDecl private", "return": "DirectoryEntry", "signature": "DirectoryEntry lookUp(\n      File dir, JimfsPath path, Set<? super LinkOption> options, int linkDepth)", "full_signature": "@NullableDecl private DirectoryEntry lookUp(\n      File dir, JimfsPath path, Set<? super LinkOption> options, int linkDepth)", "class_method_signature": "FileTree.lookUp(\n      File dir, JimfsPath path, Set<? super LinkOption> options, int linkDepth)", "testcase": false, "constructor": false}, {"identifier": "lookUp", "parameters": "(\n      File dir, Iterable<Name> names, Set<? super LinkOption> options, int linkDepth)", "modifiers": "@NullableDecl private", "return": "DirectoryEntry", "signature": "DirectoryEntry lookUp(\n      File dir, Iterable<Name> names, Set<? super LinkOption> options, int linkDepth)", "full_signature": "@NullableDecl private DirectoryEntry lookUp(\n      File dir, Iterable<Name> names, Set<? super LinkOption> options, int linkDepth)", "class_method_signature": "FileTree.lookUp(\n      File dir, Iterable<Name> names, Set<? super LinkOption> options, int linkDepth)", "testcase": false, "constructor": false}, {"identifier": "lookUpLast", "parameters": "(\n      @NullableDecl File dir, Name name, Set<? super LinkOption> options, int linkDepth)", "modifiers": "@NullableDecl private", "return": "DirectoryEntry", "signature": "DirectoryEntry lookUpLast(\n      @NullableDecl File dir, Name name, Set<? super LinkOption> options, int linkDepth)", "full_signature": "@NullableDecl private DirectoryEntry lookUpLast(\n      @NullableDecl File dir, Name name, Set<? super LinkOption> options, int linkDepth)", "class_method_signature": "FileTree.lookUpLast(\n      @NullableDecl File dir, Name name, Set<? super LinkOption> options, int linkDepth)", "testcase": false, "constructor": false}, {"identifier": "followSymbolicLink", "parameters": "(File dir, SymbolicLink link, int linkDepth)", "modifiers": "@NullableDecl private", "return": "DirectoryEntry", "signature": "DirectoryEntry followSymbolicLink(File dir, SymbolicLink link, int linkDepth)", "full_signature": "@NullableDecl private DirectoryEntry followSymbolicLink(File dir, SymbolicLink link, int linkDepth)", "class_method_signature": "FileTree.followSymbolicLink(File dir, SymbolicLink link, int linkDepth)", "testcase": false, "constructor": false}, {"identifier": "getRealEntry", "parameters": "(DirectoryEntry entry)", "modifiers": "@NullableDecl private", "return": "DirectoryEntry", "signature": "DirectoryEntry getRealEntry(DirectoryEntry entry)", "full_signature": "@NullableDecl private DirectoryEntry getRealEntry(DirectoryEntry entry)", "class_method_signature": "FileTree.getRealEntry(DirectoryEntry entry)", "testcase": false, "constructor": false}, {"identifier": "toDirectory", "parameters": "(@NullableDecl File file)", "modifiers": "@NullableDecl private", "return": "Directory", "signature": "Directory toDirectory(@NullableDecl File file)", "full_signature": "@NullableDecl private Directory toDirectory(@NullableDecl File file)", "class_method_signature": "FileTree.toDirectory(@NullableDecl File file)", "testcase": false, "constructor": false}, {"identifier": "isEmpty", "parameters": "(ImmutableList<Name> names)", "modifiers": "private static", "return": "boolean", "signature": "boolean isEmpty(ImmutableList<Name> names)", "full_signature": "private static boolean isEmpty(ImmutableList<Name> names)", "class_method_signature": "FileTree.isEmpty(ImmutableList<Name> names)", "testcase": false, "constructor": false}], "file": "jimfs/src/main/java/com/google/common/jimfs/FileTree.java"}, "focal_method": {"identifier": "lookUp", "parameters": "(\n      File workingDirectory, JimfsPath path, Set<? super LinkOption> options)", "modifiers": "public", "return": "DirectoryEntry", "body": "public DirectoryEntry lookUp(\n      File workingDirectory, JimfsPath path, Set<? super LinkOption> options) throws IOException {\n    checkNotNull(path);\n    checkNotNull(options);\n\n    DirectoryEntry result = lookUp(workingDirectory, path, options, 0);\n    if (result == null) {\n      // an intermediate file in the path did not exist or was not a directory\n      throw new NoSuchFileException(path.toString());\n    }\n    return result;\n  }", "signature": "DirectoryEntry lookUp(\n      File workingDirectory, JimfsPath path, Set<? super LinkOption> options)", "full_signature": "public DirectoryEntry lookUp(\n      File workingDirectory, JimfsPath path, Set<? super LinkOption> options)", "class_method_signature": "FileTree.lookUp(\n      File workingDirectory, JimfsPath path, Set<? super LinkOption> options)", "testcase": false, "constructor": false, "invocations": ["checkNotNull", "checkNotNull", "lookUp", "toString"]}, "repository": {"repo_id": 13745124, "url": "https://github.com/google/jimfs", "stars": 1731, "created": "10/21/2013 2:39:27 PM +00:00", "updates": "2020-01-27T18:46:07+00:00", "fork": "False", "license": "licensed"}}